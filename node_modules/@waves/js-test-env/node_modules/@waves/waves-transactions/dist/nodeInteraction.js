"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.broadcast = exports.stateChanges = exports.rewards = exports.scriptMeta = exports.scriptInfo = exports.accountDataByKey = exports.accountData = exports.assetBalance = exports.balanceDetails = exports.balance = exports.transactionById = exports.waitNBlocks = exports.waitForTxWithNConfirmations = exports.waitForTx = exports.waitForHeight = exports.currentHeight = void 0;
const tx_route = __importStar(require("@waves/node-api-js/cjs/api-node/transactions"));
const blocks_route = __importStar(require("@waves/node-api-js/cjs/api-node/blocks"));
const addresses_route = __importStar(require("@waves/node-api-js/cjs/api-node/addresses"));
const assets_route = __importStar(require("@waves/node-api-js/cjs/api-node/assets"));
const rewards_route = __importStar(require("@waves/node-api-js/cjs/api-node/rewards"));
const debug_route = __importStar(require("@waves/node-api-js/cjs/api-node/debug"));
const delay = (timeout) => {
    const t = {};
    const p = new Promise((resolve, _) => {
        t.resolve = resolve;
        t.id = setTimeout(() => resolve(), timeout);
    });
    p.cancel = () => {
        t.resolve();
        clearTimeout(t.id);
    };
    return p;
};
const rerun = (f, expired, t = 1000) => delay(t).then(_ => expired ?
    Promise.reject(new Error('Tx wait stopped: timeout')) :
    f());
const DEFAULT_NODE_REQUEST_OPTIONS = {
    timeout: 120000,
    apiBase: 'https://nodes.wavesplatform.com',
};
exports.currentHeight = (apiBase, requestOptions) => __awaiter(void 0, void 0, void 0, function* () {
    return blocks_route.fetchHeight(apiBase, requestOptions).then(({ height }) => height);
});
function waitForHeight(height, options, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const { timeout, apiBase } = Object.assign(Object.assign({}, DEFAULT_NODE_REQUEST_OPTIONS), options);
        let expired = false;
        const to = delay(timeout);
        to.then(() => expired = true);
        const promise = () => exports.currentHeight(apiBase, requestOptions)
            .then(x => {
            if (x >= height) {
                to.cancel();
                return x;
            }
            else {
                return rerun(promise, expired, 10000);
            }
        }).catch(_ => rerun(promise, expired));
        return promise();
    });
}
exports.waitForHeight = waitForHeight;
/**
 * Resolves when specified txId is mined into block
 * @param txId - waves address as base58 string
 * @param options
 */
function waitForTx(txId, options, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const { timeout, apiBase } = Object.assign(Object.assign({}, DEFAULT_NODE_REQUEST_OPTIONS), options);
        let expired = false;
        const to = delay(timeout);
        to.then(() => expired = true);
        const promise = () => tx_route.fetchInfo(apiBase, txId, requestOptions)
            .then(x => {
            to.cancel();
            return x; //todo: fix types
        })
            .catch(_ => delay(1000)
            .then(_ => expired ?
            Promise.reject(new Error('Tx wait stopped: timeout')) :
            promise()));
        return promise();
    });
}
exports.waitForTx = waitForTx;
const process400 = (resp) => resp.status === 400
    ? Promise.reject(Object.assign(new Error(), resp.data))
    : resp;
function waitForTxWithNConfirmations(txId, confirmations, options, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const { timeout } = Object.assign(Object.assign({}, DEFAULT_NODE_REQUEST_OPTIONS), options);
        let expired = false;
        const to = delay(timeout);
        to.then(() => expired = true);
        let tx = yield waitForTx(txId, options, requestOptions);
        let txHeight = tx.height;
        let currentHeight = tx.height;
        while (txHeight + confirmations > currentHeight) {
            if (expired)
                throw new Error('Tx wait stopped: timeout');
            yield waitForHeight(txHeight + confirmations, options, requestOptions);
            tx = yield waitForTx(txId, options, requestOptions);
            txHeight = tx.height;
        }
        return tx;
    });
}
exports.waitForTxWithNConfirmations = waitForTxWithNConfirmations;
function waitNBlocks(blocksCount, options = DEFAULT_NODE_REQUEST_OPTIONS, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const { apiBase } = Object.assign(Object.assign({}, DEFAULT_NODE_REQUEST_OPTIONS), options);
        const height = yield exports.currentHeight(apiBase, requestOptions);
        const target = height + blocksCount;
        // console.log(`current height: ${height} target: ${target}`)
        return yield waitForHeight(target, options, requestOptions);
    });
}
exports.waitNBlocks = waitNBlocks;
/**
 * Get account effective balance
 * @param txId - transaction ID as base58 string
 * @param nodeUrl - node address to ask balance from. E.g. https://nodes.wavesplatform.com/
 */
function transactionById(txId, nodeUrl, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        return tx_route.fetchInfo(nodeUrl, txId, requestOptions); //todo: fix types
    });
}
exports.transactionById = transactionById;
/**
 * Get account effective balance
 * @param address - waves address as base58 string
 * @param nodeUrl - node address to ask balance from. E.g. https://nodes.wavesplatform.com/
 */
function balance(address, nodeUrl, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        return addresses_route.fetchBalance(nodeUrl, address, requestOptions).then(d => +d.balance);
    });
}
exports.balance = balance;
/**
 * Retrieve full information about waves account balance. Effective, generating etc
 * @param address - waves address as base58 string
 * @param nodeUrl - node address to ask balance from. E.g. https://nodes.wavesplatform.com/
 */
function balanceDetails(address, nodeUrl, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        return addresses_route.fetchBalanceDetails(nodeUrl, address, requestOptions);
    });
}
exports.balanceDetails = balanceDetails;
/**
 * Retrieve information about specific asset account balance
 * @param assetId - id of asset
 * @param address - waves address as base58 string
 * @param nodeUrl - node address to ask balance from. E.g. https://nodes.wavesplatform.com/
 */
function assetBalance(assetId, address, nodeUrl, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        return assets_route.fetchAssetsBalance(nodeUrl, address, requestOptions)
            .then(x => x.balances.filter(bal => bal.assetId === assetId))
            .then(filtered => { var _a; return (_a = filtered[0]) === null || _a === void 0 ? void 0 : _a.balance; });
    });
}
exports.assetBalance = assetBalance;
function accountData(options, nodeUrl, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        let address;
        let match;
        if (typeof options === 'string') {
            address = options;
            match = undefined;
        }
        else {
            address = options.address;
            match = options.match && encodeURIComponent(typeof options.match === 'string'
                ? options.match
                : options.match.source);
        }
        const data = yield addresses_route.data(nodeUrl, address, { matches: match }, requestOptions); //todo fix type
        return data.reduce((acc, item) => (Object.assign(Object.assign({}, acc), { [item.key]: item })), {});
    });
}
exports.accountData = accountData;
/**
 * Get data from account dictionary by key
 * @param address - waves address as base58 string
 * @param key - dictionary key
 * @param nodeUrl - node address to ask data from. E.g. https://nodes.wavesplatform.com/
 */
function accountDataByKey(key, address, nodeUrl, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        return addresses_route.fetchDataKey(nodeUrl, address, key, requestOptions).catch((e) => {
            if (e.error === 304)
                return null;
            else
                throw e;
        });
    });
}
exports.accountDataByKey = accountDataByKey;
/**
 * Get account script info
 * @param address - waves address as base58 string
 * @param nodeUrl - node address to ask data from. E.g. https://nodes.wavesplatform.com/
 */
function scriptInfo(address, nodeUrl, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        return addresses_route.fetchScriptInfo(nodeUrl, address, requestOptions);
    });
}
exports.scriptInfo = scriptInfo;
/**
 * Get account script meta, i.e., available callable functions
 * @param address - waves address as base58 string
 * @param nodeUrl - node address to ask data from. E.g. https://nodes.wavesplatform.com/
 */
function scriptMeta(address, nodeUrl, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        return addresses_route.fetchScriptInfoMeta(nodeUrl, address, requestOptions);
    });
}
exports.scriptMeta = scriptMeta;
function rewards(...args) {
    return __awaiter(this, void 0, void 0, function* () {
        let nodeUrl;
        let _height = undefined;
        if (args[1] !== undefined) {
            nodeUrl = args[1];
            _height = args[0];
        }
        else {
            nodeUrl = args[0];
        }
        return rewards_route.fetchRewards(nodeUrl, _height);
    });
}
exports.rewards = rewards;
/**
 * Get invokeScript tx state changes
 * @param transactionId - invokeScript transaction id as base58 string
 * @param nodeUrl - node address to ask data from. E.g. https://nodes.wavesplatform.com/
 */
function stateChanges(transactionId, nodeUrl, requestOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        return debug_route.fetchStateChangesByTxId(nodeUrl, transactionId, requestOptions).then((t) => t.stateChanges); //todo: fix types
    });
}
exports.stateChanges = stateChanges;
/**
 * Sends transaction to waves node
 * IMPORTANT: You cannot broadcast order. Orders should be sent to matcher via submitOrder method
 * @param tx - transaction to send
 * @param nodeUrl - node address to send tx to. E.g. https://nodes.wavesplatform.com/
 */
function broadcast(tx, nodeUrl, requestOptions) {
    return tx_route.broadcast(nodeUrl, tx, requestOptions);
}
exports.broadcast = broadcast;
//# sourceMappingURL=nodeInteraction.js.map