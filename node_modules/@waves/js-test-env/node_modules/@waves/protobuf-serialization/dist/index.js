/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.waves = (function() {

    var waves = {};

    waves.Amount = (function() {

        function Amount(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        Amount.prototype.assetId = $util.newBuffer([]);
        Amount.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        Amount.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetId != null && m.hasOwnProperty("assetId"))
                w.uint32(10).bytes(m.assetId);
            if (m.amount != null && m.hasOwnProperty("amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        Amount.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.Amount();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetId = r.bytes();
                    break;
                case 2:
                    m.amount = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Amount;
    })();

    waves.Block = (function() {

        function Block(p) {
            this.transactions = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        Block.prototype.header = null;
        Block.prototype.signature = $util.newBuffer([]);
        Block.prototype.transactions = $util.emptyArray;

        Block.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && m.hasOwnProperty("header"))
                $root.waves.Block.Header.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.signature != null && m.hasOwnProperty("signature"))
                w.uint32(18).bytes(m.signature);
            if (m.transactions != null && m.transactions.length) {
                for (var i = 0; i < m.transactions.length; ++i)
                    $root.waves.SignedTransaction.encode(m.transactions[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        Block.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.Block();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.waves.Block.Header.decode(r, r.uint32());
                    break;
                case 2:
                    m.signature = r.bytes();
                    break;
                case 3:
                    if (!(m.transactions && m.transactions.length))
                        m.transactions = [];
                    m.transactions.push($root.waves.SignedTransaction.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        Block.Header = (function() {

            function Header(p) {
                this.featureVotes = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Header.prototype.chainId = 0;
            Header.prototype.reference = $util.newBuffer([]);
            Header.prototype.baseTarget = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            Header.prototype.generationSignature = $util.newBuffer([]);
            Header.prototype.featureVotes = $util.emptyArray;
            Header.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            Header.prototype.version = 0;
            Header.prototype.generator = $util.newBuffer([]);
            Header.prototype.rewardVote = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            Header.prototype.transactionsRoot = $util.newBuffer([]);

            Header.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.chainId != null && m.hasOwnProperty("chainId"))
                    w.uint32(8).int32(m.chainId);
                if (m.reference != null && m.hasOwnProperty("reference"))
                    w.uint32(18).bytes(m.reference);
                if (m.baseTarget != null && m.hasOwnProperty("baseTarget"))
                    w.uint32(24).int64(m.baseTarget);
                if (m.generationSignature != null && m.hasOwnProperty("generationSignature"))
                    w.uint32(34).bytes(m.generationSignature);
                if (m.featureVotes != null && m.featureVotes.length) {
                    w.uint32(42).fork();
                    for (var i = 0; i < m.featureVotes.length; ++i)
                        w.uint32(m.featureVotes[i]);
                    w.ldelim();
                }
                if (m.timestamp != null && m.hasOwnProperty("timestamp"))
                    w.uint32(48).int64(m.timestamp);
                if (m.version != null && m.hasOwnProperty("version"))
                    w.uint32(56).int32(m.version);
                if (m.generator != null && m.hasOwnProperty("generator"))
                    w.uint32(66).bytes(m.generator);
                if (m.rewardVote != null && m.hasOwnProperty("rewardVote"))
                    w.uint32(72).int64(m.rewardVote);
                if (m.transactionsRoot != null && m.hasOwnProperty("transactionsRoot"))
                    w.uint32(82).bytes(m.transactionsRoot);
                return w;
            };

            Header.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.Block.Header();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.chainId = r.int32();
                        break;
                    case 2:
                        m.reference = r.bytes();
                        break;
                    case 3:
                        m.baseTarget = r.int64();
                        break;
                    case 4:
                        m.generationSignature = r.bytes();
                        break;
                    case 5:
                        if (!(m.featureVotes && m.featureVotes.length))
                            m.featureVotes = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.featureVotes.push(r.uint32());
                        } else
                            m.featureVotes.push(r.uint32());
                        break;
                    case 6:
                        m.timestamp = r.int64();
                        break;
                    case 7:
                        m.version = r.int32();
                        break;
                    case 8:
                        m.generator = r.bytes();
                        break;
                    case 9:
                        m.rewardVote = r.int64();
                        break;
                    case 10:
                        m.transactionsRoot = r.bytes();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Header;
        })();

        return Block;
    })();

    waves.MicroBlock = (function() {

        function MicroBlock(p) {
            this.transactions = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        MicroBlock.prototype.version = 0;
        MicroBlock.prototype.reference = $util.newBuffer([]);
        MicroBlock.prototype.updatedBlockSignature = $util.newBuffer([]);
        MicroBlock.prototype.senderPublicKey = $util.newBuffer([]);
        MicroBlock.prototype.transactions = $util.emptyArray;

        MicroBlock.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.version != null && m.hasOwnProperty("version"))
                w.uint32(8).int32(m.version);
            if (m.reference != null && m.hasOwnProperty("reference"))
                w.uint32(18).bytes(m.reference);
            if (m.updatedBlockSignature != null && m.hasOwnProperty("updatedBlockSignature"))
                w.uint32(26).bytes(m.updatedBlockSignature);
            if (m.senderPublicKey != null && m.hasOwnProperty("senderPublicKey"))
                w.uint32(34).bytes(m.senderPublicKey);
            if (m.transactions != null && m.transactions.length) {
                for (var i = 0; i < m.transactions.length; ++i)
                    $root.waves.SignedTransaction.encode(m.transactions[i], w.uint32(42).fork()).ldelim();
            }
            return w;
        };

        MicroBlock.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.MicroBlock();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.version = r.int32();
                    break;
                case 2:
                    m.reference = r.bytes();
                    break;
                case 3:
                    m.updatedBlockSignature = r.bytes();
                    break;
                case 4:
                    m.senderPublicKey = r.bytes();
                    break;
                case 5:
                    if (!(m.transactions && m.transactions.length))
                        m.transactions = [];
                    m.transactions.push($root.waves.SignedTransaction.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return MicroBlock;
    })();

    waves.SignedMicroBlock = (function() {

        function SignedMicroBlock(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SignedMicroBlock.prototype.microBlock = null;
        SignedMicroBlock.prototype.signature = $util.newBuffer([]);
        SignedMicroBlock.prototype.totalBlockId = $util.newBuffer([]);

        SignedMicroBlock.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.microBlock != null && m.hasOwnProperty("microBlock"))
                $root.waves.MicroBlock.encode(m.microBlock, w.uint32(10).fork()).ldelim();
            if (m.signature != null && m.hasOwnProperty("signature"))
                w.uint32(18).bytes(m.signature);
            if (m.totalBlockId != null && m.hasOwnProperty("totalBlockId"))
                w.uint32(26).bytes(m.totalBlockId);
            return w;
        };

        SignedMicroBlock.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.SignedMicroBlock();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.microBlock = $root.waves.MicroBlock.decode(r, r.uint32());
                    break;
                case 2:
                    m.signature = r.bytes();
                    break;
                case 3:
                    m.totalBlockId = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SignedMicroBlock;
    })();

    waves.events = (function() {

        var events = {};

        events.BlockchainUpdated = (function() {

            function BlockchainUpdated(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            BlockchainUpdated.prototype.id = $util.newBuffer([]);
            BlockchainUpdated.prototype.height = 0;
            BlockchainUpdated.prototype.append = null;
            BlockchainUpdated.prototype.rollback = null;

            var $oneOfFields;

            Object.defineProperty(BlockchainUpdated.prototype, "update", {
                get: $util.oneOfGetter($oneOfFields = ["append", "rollback"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            BlockchainUpdated.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.id != null && m.hasOwnProperty("id"))
                    w.uint32(10).bytes(m.id);
                if (m.height != null && m.hasOwnProperty("height"))
                    w.uint32(16).int32(m.height);
                if (m.append != null && m.hasOwnProperty("append"))
                    $root.waves.events.BlockchainUpdated.Append.encode(m.append, w.uint32(90).fork()).ldelim();
                if (m.rollback != null && m.hasOwnProperty("rollback"))
                    $root.waves.events.BlockchainUpdated.Rollback.encode(m.rollback, w.uint32(98).fork()).ldelim();
                return w;
            };

            BlockchainUpdated.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.BlockchainUpdated();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.id = r.bytes();
                        break;
                    case 2:
                        m.height = r.int32();
                        break;
                    case 11:
                        m.append = $root.waves.events.BlockchainUpdated.Append.decode(r, r.uint32());
                        break;
                    case 12:
                        m.rollback = $root.waves.events.BlockchainUpdated.Rollback.decode(r, r.uint32());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            BlockchainUpdated.Append = (function() {

                function Append(p) {
                    this.transactionIds = [];
                    this.transactionStateUpdates = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                Append.prototype.block = null;
                Append.prototype.microBlock = null;
                Append.prototype.transactionIds = $util.emptyArray;
                Append.prototype.stateUpdate = null;
                Append.prototype.transactionStateUpdates = $util.emptyArray;

                var $oneOfFields;

                Object.defineProperty(Append.prototype, "body", {
                    get: $util.oneOfGetter($oneOfFields = ["block", "microBlock"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                Append.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.block != null && m.hasOwnProperty("block"))
                        $root.waves.events.BlockchainUpdated.Append.BlockAppend.encode(m.block, w.uint32(10).fork()).ldelim();
                    if (m.microBlock != null && m.hasOwnProperty("microBlock"))
                        $root.waves.events.BlockchainUpdated.Append.MicroBlockAppend.encode(m.microBlock, w.uint32(18).fork()).ldelim();
                    if (m.transactionIds != null && m.transactionIds.length) {
                        for (var i = 0; i < m.transactionIds.length; ++i)
                            w.uint32(26).bytes(m.transactionIds[i]);
                    }
                    if (m.stateUpdate != null && m.hasOwnProperty("stateUpdate"))
                        $root.waves.events.StateUpdate.encode(m.stateUpdate, w.uint32(90).fork()).ldelim();
                    if (m.transactionStateUpdates != null && m.transactionStateUpdates.length) {
                        for (var i = 0; i < m.transactionStateUpdates.length; ++i)
                            $root.waves.events.StateUpdate.encode(m.transactionStateUpdates[i], w.uint32(98).fork()).ldelim();
                    }
                    return w;
                };

                Append.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.BlockchainUpdated.Append();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.block = $root.waves.events.BlockchainUpdated.Append.BlockAppend.decode(r, r.uint32());
                            break;
                        case 2:
                            m.microBlock = $root.waves.events.BlockchainUpdated.Append.MicroBlockAppend.decode(r, r.uint32());
                            break;
                        case 3:
                            if (!(m.transactionIds && m.transactionIds.length))
                                m.transactionIds = [];
                            m.transactionIds.push(r.bytes());
                            break;
                        case 11:
                            m.stateUpdate = $root.waves.events.StateUpdate.decode(r, r.uint32());
                            break;
                        case 12:
                            if (!(m.transactionStateUpdates && m.transactionStateUpdates.length))
                                m.transactionStateUpdates = [];
                            m.transactionStateUpdates.push($root.waves.events.StateUpdate.decode(r, r.uint32()));
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                Append.BlockAppend = (function() {

                    function BlockAppend(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    BlockAppend.prototype.block = null;
                    BlockAppend.prototype.updatedWavesAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    BlockAppend.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.block != null && m.hasOwnProperty("block"))
                            $root.waves.Block.encode(m.block, w.uint32(10).fork()).ldelim();
                        if (m.updatedWavesAmount != null && m.hasOwnProperty("updatedWavesAmount"))
                            w.uint32(16).int64(m.updatedWavesAmount);
                        return w;
                    };

                    BlockAppend.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.BlockchainUpdated.Append.BlockAppend();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.block = $root.waves.Block.decode(r, r.uint32());
                                break;
                            case 2:
                                m.updatedWavesAmount = r.int64();
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    return BlockAppend;
                })();

                Append.MicroBlockAppend = (function() {

                    function MicroBlockAppend(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    MicroBlockAppend.prototype.microBlock = null;
                    MicroBlockAppend.prototype.updatedTransactionsRoot = $util.newBuffer([]);

                    MicroBlockAppend.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.microBlock != null && m.hasOwnProperty("microBlock"))
                            $root.waves.SignedMicroBlock.encode(m.microBlock, w.uint32(10).fork()).ldelim();
                        if (m.updatedTransactionsRoot != null && m.hasOwnProperty("updatedTransactionsRoot"))
                            w.uint32(18).bytes(m.updatedTransactionsRoot);
                        return w;
                    };

                    MicroBlockAppend.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.BlockchainUpdated.Append.MicroBlockAppend();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.microBlock = $root.waves.SignedMicroBlock.decode(r, r.uint32());
                                break;
                            case 2:
                                m.updatedTransactionsRoot = r.bytes();
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    return MicroBlockAppend;
                })();

                return Append;
            })();

            BlockchainUpdated.Rollback = (function() {

                function Rollback(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                Rollback.prototype.type = 0;

                Rollback.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.type != null && m.hasOwnProperty("type"))
                        w.uint32(8).int32(m.type);
                    return w;
                };

                Rollback.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.BlockchainUpdated.Rollback();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.type = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                Rollback.RollbackType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "BLOCK"] = 0;
                    values[valuesById[1] = "MICROBLOCK"] = 1;
                    return values;
                })();

                return Rollback;
            })();

            return BlockchainUpdated;
        })();

        events.StateUpdate = (function() {

            function StateUpdate(p) {
                this.balances = [];
                this.leases = [];
                this.dataEntries = [];
                this.assets = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            StateUpdate.prototype.balances = $util.emptyArray;
            StateUpdate.prototype.leases = $util.emptyArray;
            StateUpdate.prototype.dataEntries = $util.emptyArray;
            StateUpdate.prototype.assets = $util.emptyArray;

            StateUpdate.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.balances != null && m.balances.length) {
                    for (var i = 0; i < m.balances.length; ++i)
                        $root.waves.events.StateUpdate.BalanceUpdate.encode(m.balances[i], w.uint32(10).fork()).ldelim();
                }
                if (m.leases != null && m.leases.length) {
                    for (var i = 0; i < m.leases.length; ++i)
                        $root.waves.events.StateUpdate.LeasingUpdate.encode(m.leases[i], w.uint32(18).fork()).ldelim();
                }
                if (m.dataEntries != null && m.dataEntries.length) {
                    for (var i = 0; i < m.dataEntries.length; ++i)
                        $root.waves.events.StateUpdate.DataEntryUpdate.encode(m.dataEntries[i], w.uint32(26).fork()).ldelim();
                }
                if (m.assets != null && m.assets.length) {
                    for (var i = 0; i < m.assets.length; ++i)
                        $root.waves.events.StateUpdate.AssetStateUpdate.encode(m.assets[i], w.uint32(34).fork()).ldelim();
                }
                return w;
            };

            StateUpdate.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.StateUpdate();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.balances && m.balances.length))
                            m.balances = [];
                        m.balances.push($root.waves.events.StateUpdate.BalanceUpdate.decode(r, r.uint32()));
                        break;
                    case 2:
                        if (!(m.leases && m.leases.length))
                            m.leases = [];
                        m.leases.push($root.waves.events.StateUpdate.LeasingUpdate.decode(r, r.uint32()));
                        break;
                    case 3:
                        if (!(m.dataEntries && m.dataEntries.length))
                            m.dataEntries = [];
                        m.dataEntries.push($root.waves.events.StateUpdate.DataEntryUpdate.decode(r, r.uint32()));
                        break;
                    case 4:
                        if (!(m.assets && m.assets.length))
                            m.assets = [];
                        m.assets.push($root.waves.events.StateUpdate.AssetStateUpdate.decode(r, r.uint32()));
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            StateUpdate.BalanceUpdate = (function() {

                function BalanceUpdate(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                BalanceUpdate.prototype.address = $util.newBuffer([]);
                BalanceUpdate.prototype.amount = null;

                BalanceUpdate.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && m.hasOwnProperty("address"))
                        w.uint32(10).bytes(m.address);
                    if (m.amount != null && m.hasOwnProperty("amount"))
                        $root.waves.Amount.encode(m.amount, w.uint32(18).fork()).ldelim();
                    return w;
                };

                BalanceUpdate.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.StateUpdate.BalanceUpdate();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m.amount = $root.waves.Amount.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BalanceUpdate;
            })();

            StateUpdate.LeasingUpdate = (function() {

                function LeasingUpdate(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                LeasingUpdate.prototype.address = $util.newBuffer([]);
                LeasingUpdate.prototype["in"] = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                LeasingUpdate.prototype.out = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                LeasingUpdate.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && m.hasOwnProperty("address"))
                        w.uint32(10).bytes(m.address);
                    if (m["in"] != null && m.hasOwnProperty("in"))
                        w.uint32(16).int64(m["in"]);
                    if (m.out != null && m.hasOwnProperty("out"))
                        w.uint32(24).int64(m.out);
                    return w;
                };

                LeasingUpdate.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.StateUpdate.LeasingUpdate();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m["in"] = r.int64();
                            break;
                        case 3:
                            m.out = r.int64();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return LeasingUpdate;
            })();

            StateUpdate.DataEntryUpdate = (function() {

                function DataEntryUpdate(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                DataEntryUpdate.prototype.address = $util.newBuffer([]);
                DataEntryUpdate.prototype.dataEntry = null;

                DataEntryUpdate.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && m.hasOwnProperty("address"))
                        w.uint32(10).bytes(m.address);
                    if (m.dataEntry != null && m.hasOwnProperty("dataEntry"))
                        $root.waves.DataTransactionData.DataEntry.encode(m.dataEntry, w.uint32(18).fork()).ldelim();
                    return w;
                };

                DataEntryUpdate.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.StateUpdate.DataEntryUpdate();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m.dataEntry = $root.waves.DataTransactionData.DataEntry.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return DataEntryUpdate;
            })();

            StateUpdate.AssetStateUpdate = (function() {

                function AssetStateUpdate(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                AssetStateUpdate.prototype.assetId = $util.newBuffer([]);
                AssetStateUpdate.prototype.decimals = 0;
                AssetStateUpdate.prototype.name = "";
                AssetStateUpdate.prototype.description = "";
                AssetStateUpdate.prototype.reissuable = false;
                AssetStateUpdate.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                AssetStateUpdate.prototype.scriptInfo = null;
                AssetStateUpdate.prototype.sponsorship = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                AssetStateUpdate.prototype.nft = false;
                AssetStateUpdate.prototype.assetExistedBefore = false;
                AssetStateUpdate.prototype.safeVolume = $util.newBuffer([]);

                AssetStateUpdate.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.assetId != null && m.hasOwnProperty("assetId"))
                        w.uint32(10).bytes(m.assetId);
                    if (m.decimals != null && m.hasOwnProperty("decimals"))
                        w.uint32(16).int32(m.decimals);
                    if (m.name != null && m.hasOwnProperty("name"))
                        w.uint32(26).string(m.name);
                    if (m.description != null && m.hasOwnProperty("description"))
                        w.uint32(34).string(m.description);
                    if (m.reissuable != null && m.hasOwnProperty("reissuable"))
                        w.uint32(40).bool(m.reissuable);
                    if (m.volume != null && m.hasOwnProperty("volume"))
                        w.uint32(48).int64(m.volume);
                    if (m.scriptInfo != null && m.hasOwnProperty("scriptInfo"))
                        $root.waves.events.StateUpdate.AssetStateUpdate.AssetScriptInfo.encode(m.scriptInfo, w.uint32(58).fork()).ldelim();
                    if (m.sponsorship != null && m.hasOwnProperty("sponsorship"))
                        w.uint32(64).int64(m.sponsorship);
                    if (m.nft != null && m.hasOwnProperty("nft"))
                        w.uint32(72).bool(m.nft);
                    if (m.assetExistedBefore != null && m.hasOwnProperty("assetExistedBefore"))
                        w.uint32(160).bool(m.assetExistedBefore);
                    if (m.safeVolume != null && m.hasOwnProperty("safeVolume"))
                        w.uint32(170).bytes(m.safeVolume);
                    return w;
                };

                AssetStateUpdate.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.StateUpdate.AssetStateUpdate();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.assetId = r.bytes();
                            break;
                        case 2:
                            m.decimals = r.int32();
                            break;
                        case 3:
                            m.name = r.string();
                            break;
                        case 4:
                            m.description = r.string();
                            break;
                        case 5:
                            m.reissuable = r.bool();
                            break;
                        case 6:
                            m.volume = r.int64();
                            break;
                        case 7:
                            m.scriptInfo = $root.waves.events.StateUpdate.AssetStateUpdate.AssetScriptInfo.decode(r, r.uint32());
                            break;
                        case 8:
                            m.sponsorship = r.int64();
                            break;
                        case 9:
                            m.nft = r.bool();
                            break;
                        case 20:
                            m.assetExistedBefore = r.bool();
                            break;
                        case 21:
                            m.safeVolume = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                AssetStateUpdate.AssetScriptInfo = (function() {

                    function AssetScriptInfo(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    AssetScriptInfo.prototype.script = $util.newBuffer([]);
                    AssetScriptInfo.prototype.complexity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    AssetScriptInfo.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.script != null && m.hasOwnProperty("script"))
                            w.uint32(10).bytes(m.script);
                        if (m.complexity != null && m.hasOwnProperty("complexity"))
                            w.uint32(16).int64(m.complexity);
                        return w;
                    };

                    AssetScriptInfo.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.StateUpdate.AssetStateUpdate.AssetScriptInfo();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.script = r.bytes();
                                break;
                            case 2:
                                m.complexity = r.int64();
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    return AssetScriptInfo;
                })();

                return AssetStateUpdate;
            })();

            return StateUpdate;
        })();

        events.grpc = (function() {

            var grpc = {};

            grpc.BlockchainUpdatesApi = (function() {

                function BlockchainUpdatesApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (BlockchainUpdatesApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = BlockchainUpdatesApi;


                Object.defineProperty(BlockchainUpdatesApi.prototype.getBlockUpdate = function getBlockUpdate(request, callback) {
                    return this.rpcCall(getBlockUpdate, $root.waves.events.grpc.GetBlockUpdateRequest, $root.waves.events.grpc.GetBlockUpdateResponse, request, callback);
                }, "name", { value: "GetBlockUpdate" });


                Object.defineProperty(BlockchainUpdatesApi.prototype.getBlockUpdatesRange = function getBlockUpdatesRange(request, callback) {
                    return this.rpcCall(getBlockUpdatesRange, $root.waves.events.grpc.GetBlockUpdatesRangeRequest, $root.waves.events.grpc.GetBlockUpdatesRangeResponse, request, callback);
                }, "name", { value: "GetBlockUpdatesRange" });


                Object.defineProperty(BlockchainUpdatesApi.prototype.subscribe = function subscribe(request, callback) {
                    return this.rpcCall(subscribe, $root.waves.events.grpc.SubscribeRequest, $root.waves.events.grpc.SubscribeEvent, request, callback);
                }, "name", { value: "Subscribe" });

                return BlockchainUpdatesApi;
            })();

            grpc.GetBlockUpdateRequest = (function() {

                function GetBlockUpdateRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                GetBlockUpdateRequest.prototype.height = 0;

                GetBlockUpdateRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.height != null && m.hasOwnProperty("height"))
                        w.uint32(8).int32(m.height);
                    return w;
                };

                GetBlockUpdateRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.grpc.GetBlockUpdateRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.height = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return GetBlockUpdateRequest;
            })();

            grpc.GetBlockUpdateResponse = (function() {

                function GetBlockUpdateResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                GetBlockUpdateResponse.prototype.update = null;

                GetBlockUpdateResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.update != null && m.hasOwnProperty("update"))
                        $root.waves.events.BlockchainUpdated.encode(m.update, w.uint32(10).fork()).ldelim();
                    return w;
                };

                GetBlockUpdateResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.grpc.GetBlockUpdateResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.update = $root.waves.events.BlockchainUpdated.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return GetBlockUpdateResponse;
            })();

            grpc.GetBlockUpdatesRangeRequest = (function() {

                function GetBlockUpdatesRangeRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                GetBlockUpdatesRangeRequest.prototype.fromHeight = 0;
                GetBlockUpdatesRangeRequest.prototype.toHeight = 0;

                GetBlockUpdatesRangeRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.fromHeight != null && m.hasOwnProperty("fromHeight"))
                        w.uint32(8).int32(m.fromHeight);
                    if (m.toHeight != null && m.hasOwnProperty("toHeight"))
                        w.uint32(16).int32(m.toHeight);
                    return w;
                };

                GetBlockUpdatesRangeRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.grpc.GetBlockUpdatesRangeRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.fromHeight = r.int32();
                            break;
                        case 2:
                            m.toHeight = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return GetBlockUpdatesRangeRequest;
            })();

            grpc.GetBlockUpdatesRangeResponse = (function() {

                function GetBlockUpdatesRangeResponse(p) {
                    this.updates = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                GetBlockUpdatesRangeResponse.prototype.updates = $util.emptyArray;

                GetBlockUpdatesRangeResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.updates != null && m.updates.length) {
                        for (var i = 0; i < m.updates.length; ++i)
                            $root.waves.events.BlockchainUpdated.encode(m.updates[i], w.uint32(10).fork()).ldelim();
                    }
                    return w;
                };

                GetBlockUpdatesRangeResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.grpc.GetBlockUpdatesRangeResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            if (!(m.updates && m.updates.length))
                                m.updates = [];
                            m.updates.push($root.waves.events.BlockchainUpdated.decode(r, r.uint32()));
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return GetBlockUpdatesRangeResponse;
            })();

            grpc.SubscribeRequest = (function() {

                function SubscribeRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                SubscribeRequest.prototype.fromHeight = 0;
                SubscribeRequest.prototype.toHeight = 0;

                SubscribeRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.fromHeight != null && m.hasOwnProperty("fromHeight"))
                        w.uint32(8).int32(m.fromHeight);
                    if (m.toHeight != null && m.hasOwnProperty("toHeight"))
                        w.uint32(16).int32(m.toHeight);
                    return w;
                };

                SubscribeRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.grpc.SubscribeRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.fromHeight = r.int32();
                            break;
                        case 2:
                            m.toHeight = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return SubscribeRequest;
            })();

            grpc.SubscribeEvent = (function() {

                function SubscribeEvent(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                SubscribeEvent.prototype.update = null;

                SubscribeEvent.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.update != null && m.hasOwnProperty("update"))
                        $root.waves.events.BlockchainUpdated.encode(m.update, w.uint32(10).fork()).ldelim();
                    return w;
                };

                SubscribeEvent.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.events.grpc.SubscribeEvent();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.update = $root.waves.events.BlockchainUpdated.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return SubscribeEvent;
            })();

            return grpc;
        })();

        return events;
    })();

    waves.InvokeScriptResult = (function() {

        function InvokeScriptResult(p) {
            this.data = [];
            this.transfers = [];
            this.issues = [];
            this.reissues = [];
            this.burns = [];
            this.sponsorFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        InvokeScriptResult.prototype.data = $util.emptyArray;
        InvokeScriptResult.prototype.transfers = $util.emptyArray;
        InvokeScriptResult.prototype.issues = $util.emptyArray;
        InvokeScriptResult.prototype.reissues = $util.emptyArray;
        InvokeScriptResult.prototype.burns = $util.emptyArray;
        InvokeScriptResult.prototype.errorMessage = null;
        InvokeScriptResult.prototype.sponsorFees = $util.emptyArray;

        InvokeScriptResult.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.data != null && m.data.length) {
                for (var i = 0; i < m.data.length; ++i)
                    $root.waves.DataTransactionData.DataEntry.encode(m.data[i], w.uint32(10).fork()).ldelim();
            }
            if (m.transfers != null && m.transfers.length) {
                for (var i = 0; i < m.transfers.length; ++i)
                    $root.waves.InvokeScriptResult.Payment.encode(m.transfers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.issues != null && m.issues.length) {
                for (var i = 0; i < m.issues.length; ++i)
                    $root.waves.InvokeScriptResult.Issue.encode(m.issues[i], w.uint32(26).fork()).ldelim();
            }
            if (m.reissues != null && m.reissues.length) {
                for (var i = 0; i < m.reissues.length; ++i)
                    $root.waves.InvokeScriptResult.Reissue.encode(m.reissues[i], w.uint32(34).fork()).ldelim();
            }
            if (m.burns != null && m.burns.length) {
                for (var i = 0; i < m.burns.length; ++i)
                    $root.waves.InvokeScriptResult.Burn.encode(m.burns[i], w.uint32(42).fork()).ldelim();
            }
            if (m.errorMessage != null && m.hasOwnProperty("errorMessage"))
                $root.waves.InvokeScriptResult.ErrorMessage.encode(m.errorMessage, w.uint32(50).fork()).ldelim();
            if (m.sponsorFees != null && m.sponsorFees.length) {
                for (var i = 0; i < m.sponsorFees.length; ++i)
                    $root.waves.InvokeScriptResult.SponsorFee.encode(m.sponsorFees[i], w.uint32(58).fork()).ldelim();
            }
            return w;
        };

        InvokeScriptResult.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.InvokeScriptResult();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.data && m.data.length))
                        m.data = [];
                    m.data.push($root.waves.DataTransactionData.DataEntry.decode(r, r.uint32()));
                    break;
                case 2:
                    if (!(m.transfers && m.transfers.length))
                        m.transfers = [];
                    m.transfers.push($root.waves.InvokeScriptResult.Payment.decode(r, r.uint32()));
                    break;
                case 3:
                    if (!(m.issues && m.issues.length))
                        m.issues = [];
                    m.issues.push($root.waves.InvokeScriptResult.Issue.decode(r, r.uint32()));
                    break;
                case 4:
                    if (!(m.reissues && m.reissues.length))
                        m.reissues = [];
                    m.reissues.push($root.waves.InvokeScriptResult.Reissue.decode(r, r.uint32()));
                    break;
                case 5:
                    if (!(m.burns && m.burns.length))
                        m.burns = [];
                    m.burns.push($root.waves.InvokeScriptResult.Burn.decode(r, r.uint32()));
                    break;
                case 6:
                    m.errorMessage = $root.waves.InvokeScriptResult.ErrorMessage.decode(r, r.uint32());
                    break;
                case 7:
                    if (!(m.sponsorFees && m.sponsorFees.length))
                        m.sponsorFees = [];
                    m.sponsorFees.push($root.waves.InvokeScriptResult.SponsorFee.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        InvokeScriptResult.Payment = (function() {

            function Payment(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Payment.prototype.address = $util.newBuffer([]);
            Payment.prototype.amount = null;

            Payment.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.address != null && m.hasOwnProperty("address"))
                    w.uint32(10).bytes(m.address);
                if (m.amount != null && m.hasOwnProperty("amount"))
                    $root.waves.Amount.encode(m.amount, w.uint32(18).fork()).ldelim();
                return w;
            };

            Payment.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.InvokeScriptResult.Payment();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.address = r.bytes();
                        break;
                    case 2:
                        m.amount = $root.waves.Amount.decode(r, r.uint32());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Payment;
        })();

        InvokeScriptResult.Issue = (function() {

            function Issue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Issue.prototype.assetId = $util.newBuffer([]);
            Issue.prototype.name = "";
            Issue.prototype.description = "";
            Issue.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            Issue.prototype.decimals = 0;
            Issue.prototype.reissuable = false;
            Issue.prototype.script = $util.newBuffer([]);
            Issue.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            Issue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.assetId != null && m.hasOwnProperty("assetId"))
                    w.uint32(10).bytes(m.assetId);
                if (m.name != null && m.hasOwnProperty("name"))
                    w.uint32(18).string(m.name);
                if (m.description != null && m.hasOwnProperty("description"))
                    w.uint32(26).string(m.description);
                if (m.amount != null && m.hasOwnProperty("amount"))
                    w.uint32(32).int64(m.amount);
                if (m.decimals != null && m.hasOwnProperty("decimals"))
                    w.uint32(40).int32(m.decimals);
                if (m.reissuable != null && m.hasOwnProperty("reissuable"))
                    w.uint32(48).bool(m.reissuable);
                if (m.script != null && m.hasOwnProperty("script"))
                    w.uint32(58).bytes(m.script);
                if (m.nonce != null && m.hasOwnProperty("nonce"))
                    w.uint32(64).int64(m.nonce);
                return w;
            };

            Issue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.InvokeScriptResult.Issue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.assetId = r.bytes();
                        break;
                    case 2:
                        m.name = r.string();
                        break;
                    case 3:
                        m.description = r.string();
                        break;
                    case 4:
                        m.amount = r.int64();
                        break;
                    case 5:
                        m.decimals = r.int32();
                        break;
                    case 6:
                        m.reissuable = r.bool();
                        break;
                    case 7:
                        m.script = r.bytes();
                        break;
                    case 8:
                        m.nonce = r.int64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Issue;
        })();

        InvokeScriptResult.Reissue = (function() {

            function Reissue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Reissue.prototype.assetId = $util.newBuffer([]);
            Reissue.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            Reissue.prototype.isReissuable = false;

            Reissue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.assetId != null && m.hasOwnProperty("assetId"))
                    w.uint32(10).bytes(m.assetId);
                if (m.amount != null && m.hasOwnProperty("amount"))
                    w.uint32(16).int64(m.amount);
                if (m.isReissuable != null && m.hasOwnProperty("isReissuable"))
                    w.uint32(24).bool(m.isReissuable);
                return w;
            };

            Reissue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.InvokeScriptResult.Reissue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.assetId = r.bytes();
                        break;
                    case 2:
                        m.amount = r.int64();
                        break;
                    case 3:
                        m.isReissuable = r.bool();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Reissue;
        })();

        InvokeScriptResult.Burn = (function() {

            function Burn(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Burn.prototype.assetId = $util.newBuffer([]);
            Burn.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            Burn.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.assetId != null && m.hasOwnProperty("assetId"))
                    w.uint32(10).bytes(m.assetId);
                if (m.amount != null && m.hasOwnProperty("amount"))
                    w.uint32(16).int64(m.amount);
                return w;
            };

            Burn.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.InvokeScriptResult.Burn();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.assetId = r.bytes();
                        break;
                    case 2:
                        m.amount = r.int64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Burn;
        })();

        InvokeScriptResult.SponsorFee = (function() {

            function SponsorFee(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            SponsorFee.prototype.minFee = null;

            SponsorFee.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.minFee != null && m.hasOwnProperty("minFee"))
                    $root.waves.Amount.encode(m.minFee, w.uint32(10).fork()).ldelim();
                return w;
            };

            SponsorFee.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.InvokeScriptResult.SponsorFee();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.minFee = $root.waves.Amount.decode(r, r.uint32());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return SponsorFee;
        })();

        InvokeScriptResult.ErrorMessage = (function() {

            function ErrorMessage(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            ErrorMessage.prototype.code = 0;
            ErrorMessage.prototype.text = "";

            ErrorMessage.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.code != null && m.hasOwnProperty("code"))
                    w.uint32(8).int32(m.code);
                if (m.text != null && m.hasOwnProperty("text"))
                    w.uint32(18).string(m.text);
                return w;
            };

            ErrorMessage.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.InvokeScriptResult.ErrorMessage();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.code = r.int32();
                        break;
                    case 2:
                        m.text = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return ErrorMessage;
        })();

        return InvokeScriptResult;
    })();

    waves.node = (function() {

        var node = {};

        node.grpc = (function() {

            var grpc = {};

            grpc.AccountsApi = (function() {

                function AccountsApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AccountsApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AccountsApi;


                Object.defineProperty(AccountsApi.prototype.getBalances = function getBalances(request, callback) {
                    return this.rpcCall(getBalances, $root.waves.node.grpc.BalancesRequest, $root.waves.node.grpc.BalanceResponse, request, callback);
                }, "name", { value: "GetBalances" });


                Object.defineProperty(AccountsApi.prototype.getScript = function getScript(request, callback) {
                    return this.rpcCall(getScript, $root.waves.node.grpc.AccountRequest, $root.waves.node.grpc.ScriptData, request, callback);
                }, "name", { value: "GetScript" });


                Object.defineProperty(AccountsApi.prototype.getActiveLeases = function getActiveLeases(request, callback) {
                    return this.rpcCall(getActiveLeases, $root.waves.node.grpc.AccountRequest, $root.waves.node.grpc.TransactionResponse, request, callback);
                }, "name", { value: "GetActiveLeases" });


                Object.defineProperty(AccountsApi.prototype.getDataEntries = function getDataEntries(request, callback) {
                    return this.rpcCall(getDataEntries, $root.waves.node.grpc.DataRequest, $root.waves.node.grpc.DataEntryResponse, request, callback);
                }, "name", { value: "GetDataEntries" });


                Object.defineProperty(AccountsApi.prototype.resolveAlias = function resolveAlias(request, callback) {
                    return this.rpcCall(resolveAlias, $root.google.protobuf.StringValue, $root.google.protobuf.BytesValue, request, callback);
                }, "name", { value: "ResolveAlias" });

                return AccountsApi;
            })();

            grpc.AccountRequest = (function() {

                function AccountRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                AccountRequest.prototype.address = $util.newBuffer([]);

                AccountRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && m.hasOwnProperty("address"))
                        w.uint32(10).bytes(m.address);
                    return w;
                };

                AccountRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.AccountRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return AccountRequest;
            })();

            grpc.DataRequest = (function() {

                function DataRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                DataRequest.prototype.address = $util.newBuffer([]);
                DataRequest.prototype.key = "";

                DataRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && m.hasOwnProperty("address"))
                        w.uint32(10).bytes(m.address);
                    if (m.key != null && m.hasOwnProperty("key"))
                        w.uint32(18).string(m.key);
                    return w;
                };

                DataRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.DataRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m.key = r.string();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return DataRequest;
            })();

            grpc.BalancesRequest = (function() {

                function BalancesRequest(p) {
                    this.assets = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                BalancesRequest.prototype.address = $util.newBuffer([]);
                BalancesRequest.prototype.assets = $util.emptyArray;

                BalancesRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && m.hasOwnProperty("address"))
                        w.uint32(10).bytes(m.address);
                    if (m.assets != null && m.assets.length) {
                        for (var i = 0; i < m.assets.length; ++i)
                            w.uint32(34).bytes(m.assets[i]);
                    }
                    return w;
                };

                BalancesRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.BalancesRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 4:
                            if (!(m.assets && m.assets.length))
                                m.assets = [];
                            m.assets.push(r.bytes());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BalancesRequest;
            })();

            grpc.BalanceResponse = (function() {

                function BalanceResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                BalanceResponse.prototype.waves = null;
                BalanceResponse.prototype.asset = null;

                var $oneOfFields;

                Object.defineProperty(BalanceResponse.prototype, "balance", {
                    get: $util.oneOfGetter($oneOfFields = ["waves", "asset"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                BalanceResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.waves != null && m.hasOwnProperty("waves"))
                        $root.waves.node.grpc.BalanceResponse.WavesBalances.encode(m.waves, w.uint32(10).fork()).ldelim();
                    if (m.asset != null && m.hasOwnProperty("asset"))
                        $root.waves.Amount.encode(m.asset, w.uint32(18).fork()).ldelim();
                    return w;
                };

                BalanceResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.BalanceResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.waves = $root.waves.node.grpc.BalanceResponse.WavesBalances.decode(r, r.uint32());
                            break;
                        case 2:
                            m.asset = $root.waves.Amount.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                BalanceResponse.WavesBalances = (function() {

                    function WavesBalances(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    WavesBalances.prototype.regular = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                    WavesBalances.prototype.generating = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                    WavesBalances.prototype.available = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                    WavesBalances.prototype.effective = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                    WavesBalances.prototype.leaseIn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                    WavesBalances.prototype.leaseOut = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    WavesBalances.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.regular != null && m.hasOwnProperty("regular"))
                            w.uint32(8).int64(m.regular);
                        if (m.generating != null && m.hasOwnProperty("generating"))
                            w.uint32(16).int64(m.generating);
                        if (m.available != null && m.hasOwnProperty("available"))
                            w.uint32(24).int64(m.available);
                        if (m.effective != null && m.hasOwnProperty("effective"))
                            w.uint32(32).int64(m.effective);
                        if (m.leaseIn != null && m.hasOwnProperty("leaseIn"))
                            w.uint32(40).int64(m.leaseIn);
                        if (m.leaseOut != null && m.hasOwnProperty("leaseOut"))
                            w.uint32(48).int64(m.leaseOut);
                        return w;
                    };

                    WavesBalances.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.BalanceResponse.WavesBalances();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.regular = r.int64();
                                break;
                            case 2:
                                m.generating = r.int64();
                                break;
                            case 3:
                                m.available = r.int64();
                                break;
                            case 4:
                                m.effective = r.int64();
                                break;
                            case 5:
                                m.leaseIn = r.int64();
                                break;
                            case 6:
                                m.leaseOut = r.int64();
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    return WavesBalances;
                })();

                return BalanceResponse;
            })();

            grpc.DataEntryResponse = (function() {

                function DataEntryResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                DataEntryResponse.prototype.address = $util.newBuffer([]);
                DataEntryResponse.prototype.entry = null;

                DataEntryResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && m.hasOwnProperty("address"))
                        w.uint32(10).bytes(m.address);
                    if (m.entry != null && m.hasOwnProperty("entry"))
                        $root.waves.DataTransactionData.DataEntry.encode(m.entry, w.uint32(18).fork()).ldelim();
                    return w;
                };

                DataEntryResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.DataEntryResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m.entry = $root.waves.DataTransactionData.DataEntry.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return DataEntryResponse;
            })();

            grpc.ScriptData = (function() {

                function ScriptData(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                ScriptData.prototype.scriptBytes = $util.newBuffer([]);
                ScriptData.prototype.scriptText = "";
                ScriptData.prototype.complexity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                ScriptData.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.scriptBytes != null && m.hasOwnProperty("scriptBytes"))
                        w.uint32(10).bytes(m.scriptBytes);
                    if (m.scriptText != null && m.hasOwnProperty("scriptText"))
                        w.uint32(18).string(m.scriptText);
                    if (m.complexity != null && m.hasOwnProperty("complexity"))
                        w.uint32(24).int64(m.complexity);
                    return w;
                };

                ScriptData.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.ScriptData();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.scriptBytes = r.bytes();
                            break;
                        case 2:
                            m.scriptText = r.string();
                            break;
                        case 3:
                            m.complexity = r.int64();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return ScriptData;
            })();

            grpc.AssetsApi = (function() {

                function AssetsApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AssetsApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AssetsApi;


                Object.defineProperty(AssetsApi.prototype.getInfo = function getInfo(request, callback) {
                    return this.rpcCall(getInfo, $root.waves.node.grpc.AssetRequest, $root.waves.node.grpc.AssetInfoResponse, request, callback);
                }, "name", { value: "GetInfo" });


                Object.defineProperty(AssetsApi.prototype.getNFTList = function getNFTList(request, callback) {
                    return this.rpcCall(getNFTList, $root.waves.node.grpc.NFTRequest, $root.waves.node.grpc.NFTResponse, request, callback);
                }, "name", { value: "GetNFTList" });

                return AssetsApi;
            })();

            grpc.AssetRequest = (function() {

                function AssetRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                AssetRequest.prototype.assetId = $util.newBuffer([]);

                AssetRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.assetId != null && m.hasOwnProperty("assetId"))
                        w.uint32(10).bytes(m.assetId);
                    return w;
                };

                AssetRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.AssetRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.assetId = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return AssetRequest;
            })();

            grpc.NFTRequest = (function() {

                function NFTRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                NFTRequest.prototype.address = $util.newBuffer([]);
                NFTRequest.prototype.limit = 0;
                NFTRequest.prototype.afterAssetId = $util.newBuffer([]);

                NFTRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && m.hasOwnProperty("address"))
                        w.uint32(10).bytes(m.address);
                    if (m.limit != null && m.hasOwnProperty("limit"))
                        w.uint32(16).int32(m.limit);
                    if (m.afterAssetId != null && m.hasOwnProperty("afterAssetId"))
                        w.uint32(26).bytes(m.afterAssetId);
                    return w;
                };

                NFTRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.NFTRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m.limit = r.int32();
                            break;
                        case 3:
                            m.afterAssetId = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return NFTRequest;
            })();

            grpc.NFTResponse = (function() {

                function NFTResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                NFTResponse.prototype.assetId = $util.newBuffer([]);
                NFTResponse.prototype.assetInfo = null;

                NFTResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.assetId != null && m.hasOwnProperty("assetId"))
                        w.uint32(10).bytes(m.assetId);
                    if (m.assetInfo != null && m.hasOwnProperty("assetInfo"))
                        $root.waves.node.grpc.AssetInfoResponse.encode(m.assetInfo, w.uint32(18).fork()).ldelim();
                    return w;
                };

                NFTResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.NFTResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.assetId = r.bytes();
                            break;
                        case 2:
                            m.assetInfo = $root.waves.node.grpc.AssetInfoResponse.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return NFTResponse;
            })();

            grpc.AssetInfoResponse = (function() {

                function AssetInfoResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                AssetInfoResponse.prototype.issuer = $util.newBuffer([]);
                AssetInfoResponse.prototype.name = "";
                AssetInfoResponse.prototype.description = "";
                AssetInfoResponse.prototype.decimals = 0;
                AssetInfoResponse.prototype.reissuable = false;
                AssetInfoResponse.prototype.totalVolume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                AssetInfoResponse.prototype.script = null;
                AssetInfoResponse.prototype.sponsorship = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                AssetInfoResponse.prototype.issueTransaction = null;
                AssetInfoResponse.prototype.sponsorBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                AssetInfoResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.issuer != null && m.hasOwnProperty("issuer"))
                        w.uint32(10).bytes(m.issuer);
                    if (m.name != null && m.hasOwnProperty("name"))
                        w.uint32(18).string(m.name);
                    if (m.description != null && m.hasOwnProperty("description"))
                        w.uint32(26).string(m.description);
                    if (m.decimals != null && m.hasOwnProperty("decimals"))
                        w.uint32(32).int32(m.decimals);
                    if (m.reissuable != null && m.hasOwnProperty("reissuable"))
                        w.uint32(40).bool(m.reissuable);
                    if (m.totalVolume != null && m.hasOwnProperty("totalVolume"))
                        w.uint32(48).int64(m.totalVolume);
                    if (m.script != null && m.hasOwnProperty("script"))
                        $root.waves.node.grpc.ScriptData.encode(m.script, w.uint32(58).fork()).ldelim();
                    if (m.sponsorship != null && m.hasOwnProperty("sponsorship"))
                        w.uint32(64).int64(m.sponsorship);
                    if (m.sponsorBalance != null && m.hasOwnProperty("sponsorBalance"))
                        w.uint32(80).int64(m.sponsorBalance);
                    if (m.issueTransaction != null && m.hasOwnProperty("issueTransaction"))
                        $root.waves.SignedTransaction.encode(m.issueTransaction, w.uint32(90).fork()).ldelim();
                    return w;
                };

                AssetInfoResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.AssetInfoResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.issuer = r.bytes();
                            break;
                        case 2:
                            m.name = r.string();
                            break;
                        case 3:
                            m.description = r.string();
                            break;
                        case 4:
                            m.decimals = r.int32();
                            break;
                        case 5:
                            m.reissuable = r.bool();
                            break;
                        case 6:
                            m.totalVolume = r.int64();
                            break;
                        case 7:
                            m.script = $root.waves.node.grpc.ScriptData.decode(r, r.uint32());
                            break;
                        case 8:
                            m.sponsorship = r.int64();
                            break;
                        case 11:
                            m.issueTransaction = $root.waves.SignedTransaction.decode(r, r.uint32());
                            break;
                        case 10:
                            m.sponsorBalance = r.int64();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return AssetInfoResponse;
            })();

            grpc.BlockchainApi = (function() {

                function BlockchainApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (BlockchainApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = BlockchainApi;


                Object.defineProperty(BlockchainApi.prototype.getActivationStatus = function getActivationStatus(request, callback) {
                    return this.rpcCall(getActivationStatus, $root.waves.node.grpc.ActivationStatusRequest, $root.waves.node.grpc.ActivationStatusResponse, request, callback);
                }, "name", { value: "GetActivationStatus" });


                Object.defineProperty(BlockchainApi.prototype.getBaseTarget = function getBaseTarget(request, callback) {
                    return this.rpcCall(getBaseTarget, $root.google.protobuf.Empty, $root.waves.node.grpc.BaseTargetResponse, request, callback);
                }, "name", { value: "GetBaseTarget" });


                Object.defineProperty(BlockchainApi.prototype.getCumulativeScore = function getCumulativeScore(request, callback) {
                    return this.rpcCall(getCumulativeScore, $root.google.protobuf.Empty, $root.waves.node.grpc.ScoreResponse, request, callback);
                }, "name", { value: "GetCumulativeScore" });

                return BlockchainApi;
            })();

            grpc.ActivationStatusRequest = (function() {

                function ActivationStatusRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                ActivationStatusRequest.prototype.height = 0;

                ActivationStatusRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.height != null && m.hasOwnProperty("height"))
                        w.uint32(8).int32(m.height);
                    return w;
                };

                ActivationStatusRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.ActivationStatusRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.height = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return ActivationStatusRequest;
            })();

            grpc.ActivationStatusResponse = (function() {

                function ActivationStatusResponse(p) {
                    this.features = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                ActivationStatusResponse.prototype.height = 0;
                ActivationStatusResponse.prototype.votingInterval = 0;
                ActivationStatusResponse.prototype.votingThreshold = 0;
                ActivationStatusResponse.prototype.nextCheck = 0;
                ActivationStatusResponse.prototype.features = $util.emptyArray;

                ActivationStatusResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.height != null && m.hasOwnProperty("height"))
                        w.uint32(8).int32(m.height);
                    if (m.votingInterval != null && m.hasOwnProperty("votingInterval"))
                        w.uint32(16).int32(m.votingInterval);
                    if (m.votingThreshold != null && m.hasOwnProperty("votingThreshold"))
                        w.uint32(24).int32(m.votingThreshold);
                    if (m.nextCheck != null && m.hasOwnProperty("nextCheck"))
                        w.uint32(32).int32(m.nextCheck);
                    if (m.features != null && m.features.length) {
                        for (var i = 0; i < m.features.length; ++i)
                            $root.waves.node.grpc.FeatureActivationStatus.encode(m.features[i], w.uint32(42).fork()).ldelim();
                    }
                    return w;
                };

                ActivationStatusResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.ActivationStatusResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.height = r.int32();
                            break;
                        case 2:
                            m.votingInterval = r.int32();
                            break;
                        case 3:
                            m.votingThreshold = r.int32();
                            break;
                        case 4:
                            m.nextCheck = r.int32();
                            break;
                        case 5:
                            if (!(m.features && m.features.length))
                                m.features = [];
                            m.features.push($root.waves.node.grpc.FeatureActivationStatus.decode(r, r.uint32()));
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return ActivationStatusResponse;
            })();

            grpc.FeatureActivationStatus = (function() {

                function FeatureActivationStatus(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                FeatureActivationStatus.prototype.id = 0;
                FeatureActivationStatus.prototype.description = "";
                FeatureActivationStatus.prototype.blockchainStatus = 0;
                FeatureActivationStatus.prototype.nodeStatus = 0;
                FeatureActivationStatus.prototype.activationHeight = 0;
                FeatureActivationStatus.prototype.supportingBlocks = 0;

                FeatureActivationStatus.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.id != null && m.hasOwnProperty("id"))
                        w.uint32(8).int32(m.id);
                    if (m.description != null && m.hasOwnProperty("description"))
                        w.uint32(18).string(m.description);
                    if (m.blockchainStatus != null && m.hasOwnProperty("blockchainStatus"))
                        w.uint32(24).int32(m.blockchainStatus);
                    if (m.nodeStatus != null && m.hasOwnProperty("nodeStatus"))
                        w.uint32(32).int32(m.nodeStatus);
                    if (m.activationHeight != null && m.hasOwnProperty("activationHeight"))
                        w.uint32(40).int32(m.activationHeight);
                    if (m.supportingBlocks != null && m.hasOwnProperty("supportingBlocks"))
                        w.uint32(48).int32(m.supportingBlocks);
                    return w;
                };

                FeatureActivationStatus.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.FeatureActivationStatus();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.id = r.int32();
                            break;
                        case 2:
                            m.description = r.string();
                            break;
                        case 3:
                            m.blockchainStatus = r.int32();
                            break;
                        case 4:
                            m.nodeStatus = r.int32();
                            break;
                        case 5:
                            m.activationHeight = r.int32();
                            break;
                        case 6:
                            m.supportingBlocks = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                FeatureActivationStatus.BlockchainFeatureStatus = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNDEFINED"] = 0;
                    values[valuesById[1] = "APPROVED"] = 1;
                    values[valuesById[2] = "ACTIVATED"] = 2;
                    return values;
                })();

                FeatureActivationStatus.NodeFeatureStatus = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NOT_IMPLEMENTED"] = 0;
                    values[valuesById[1] = "IMPLEMENTED"] = 1;
                    values[valuesById[2] = "VOTED"] = 2;
                    return values;
                })();

                return FeatureActivationStatus;
            })();

            grpc.BaseTargetResponse = (function() {

                function BaseTargetResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                BaseTargetResponse.prototype.baseTarget = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                BaseTargetResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.baseTarget != null && m.hasOwnProperty("baseTarget"))
                        w.uint32(8).int64(m.baseTarget);
                    return w;
                };

                BaseTargetResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.BaseTargetResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.baseTarget = r.int64();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BaseTargetResponse;
            })();

            grpc.ScoreResponse = (function() {

                function ScoreResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                ScoreResponse.prototype.score = $util.newBuffer([]);

                ScoreResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.score != null && m.hasOwnProperty("score"))
                        w.uint32(10).bytes(m.score);
                    return w;
                };

                ScoreResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.ScoreResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.score = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return ScoreResponse;
            })();

            grpc.BlocksApi = (function() {

                function BlocksApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (BlocksApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = BlocksApi;


                Object.defineProperty(BlocksApi.prototype.getBlock = function getBlock(request, callback) {
                    return this.rpcCall(getBlock, $root.waves.node.grpc.BlockRequest, $root.waves.node.grpc.BlockWithHeight, request, callback);
                }, "name", { value: "GetBlock" });


                Object.defineProperty(BlocksApi.prototype.getBlockRange = function getBlockRange(request, callback) {
                    return this.rpcCall(getBlockRange, $root.waves.node.grpc.BlockRangeRequest, $root.waves.node.grpc.BlockWithHeight, request, callback);
                }, "name", { value: "GetBlockRange" });


                Object.defineProperty(BlocksApi.prototype.getCurrentHeight = function getCurrentHeight(request, callback) {
                    return this.rpcCall(getCurrentHeight, $root.google.protobuf.Empty, $root.google.protobuf.UInt32Value, request, callback);
                }, "name", { value: "GetCurrentHeight" });

                return BlocksApi;
            })();

            grpc.BlockRequest = (function() {

                function BlockRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                BlockRequest.prototype.blockId = $util.newBuffer([]);
                BlockRequest.prototype.height = 0;
                BlockRequest.prototype.includeTransactions = false;

                var $oneOfFields;

                Object.defineProperty(BlockRequest.prototype, "request", {
                    get: $util.oneOfGetter($oneOfFields = ["blockId", "height"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                BlockRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.blockId != null && m.hasOwnProperty("blockId"))
                        w.uint32(10).bytes(m.blockId);
                    if (m.height != null && m.hasOwnProperty("height"))
                        w.uint32(16).int32(m.height);
                    if (m.includeTransactions != null && m.hasOwnProperty("includeTransactions"))
                        w.uint32(800).bool(m.includeTransactions);
                    return w;
                };

                BlockRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.BlockRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.blockId = r.bytes();
                            break;
                        case 2:
                            m.height = r.int32();
                            break;
                        case 100:
                            m.includeTransactions = r.bool();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BlockRequest;
            })();

            grpc.BlockRangeRequest = (function() {

                function BlockRangeRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                BlockRangeRequest.prototype.fromHeight = 0;
                BlockRangeRequest.prototype.toHeight = 0;
                BlockRangeRequest.prototype.generatorPublicKey = $util.newBuffer([]);
                BlockRangeRequest.prototype.generatorAddress = $util.newBuffer([]);
                BlockRangeRequest.prototype.includeTransactions = false;

                var $oneOfFields;

                Object.defineProperty(BlockRangeRequest.prototype, "filter", {
                    get: $util.oneOfGetter($oneOfFields = ["generatorPublicKey", "generatorAddress"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                BlockRangeRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.fromHeight != null && m.hasOwnProperty("fromHeight"))
                        w.uint32(8).uint32(m.fromHeight);
                    if (m.toHeight != null && m.hasOwnProperty("toHeight"))
                        w.uint32(16).uint32(m.toHeight);
                    if (m.generatorPublicKey != null && m.hasOwnProperty("generatorPublicKey"))
                        w.uint32(26).bytes(m.generatorPublicKey);
                    if (m.generatorAddress != null && m.hasOwnProperty("generatorAddress"))
                        w.uint32(34).bytes(m.generatorAddress);
                    if (m.includeTransactions != null && m.hasOwnProperty("includeTransactions"))
                        w.uint32(800).bool(m.includeTransactions);
                    return w;
                };

                BlockRangeRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.BlockRangeRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.fromHeight = r.uint32();
                            break;
                        case 2:
                            m.toHeight = r.uint32();
                            break;
                        case 3:
                            m.generatorPublicKey = r.bytes();
                            break;
                        case 4:
                            m.generatorAddress = r.bytes();
                            break;
                        case 100:
                            m.includeTransactions = r.bool();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BlockRangeRequest;
            })();

            grpc.BlockWithHeight = (function() {

                function BlockWithHeight(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                BlockWithHeight.prototype.block = null;
                BlockWithHeight.prototype.height = 0;

                BlockWithHeight.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.block != null && m.hasOwnProperty("block"))
                        $root.waves.Block.encode(m.block, w.uint32(10).fork()).ldelim();
                    if (m.height != null && m.hasOwnProperty("height"))
                        w.uint32(16).uint32(m.height);
                    return w;
                };

                BlockWithHeight.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.BlockWithHeight();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.block = $root.waves.Block.decode(r, r.uint32());
                            break;
                        case 2:
                            m.height = r.uint32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BlockWithHeight;
            })();

            grpc.TransactionsApi = (function() {

                function TransactionsApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (TransactionsApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TransactionsApi;


                Object.defineProperty(TransactionsApi.prototype.getTransactions = function getTransactions(request, callback) {
                    return this.rpcCall(getTransactions, $root.waves.node.grpc.TransactionsRequest, $root.waves.node.grpc.TransactionResponse, request, callback);
                }, "name", { value: "GetTransactions" });


                Object.defineProperty(TransactionsApi.prototype.getStateChanges = function getStateChanges(request, callback) {
                    return this.rpcCall(getStateChanges, $root.waves.node.grpc.TransactionsRequest, $root.waves.node.grpc.InvokeScriptResultResponse, request, callback);
                }, "name", { value: "GetStateChanges" });


                Object.defineProperty(TransactionsApi.prototype.getStatuses = function getStatuses(request, callback) {
                    return this.rpcCall(getStatuses, $root.waves.node.grpc.TransactionsByIdRequest, $root.waves.node.grpc.TransactionStatus, request, callback);
                }, "name", { value: "GetStatuses" });


                Object.defineProperty(TransactionsApi.prototype.getUnconfirmed = function getUnconfirmed(request, callback) {
                    return this.rpcCall(getUnconfirmed, $root.waves.node.grpc.TransactionsRequest, $root.waves.node.grpc.TransactionResponse, request, callback);
                }, "name", { value: "GetUnconfirmed" });


                Object.defineProperty(TransactionsApi.prototype.sign = function sign(request, callback) {
                    return this.rpcCall(sign, $root.waves.node.grpc.SignRequest, $root.waves.SignedTransaction, request, callback);
                }, "name", { value: "Sign" });


                Object.defineProperty(TransactionsApi.prototype.broadcast = function broadcast(request, callback) {
                    return this.rpcCall(broadcast, $root.waves.SignedTransaction, $root.waves.SignedTransaction, request, callback);
                }, "name", { value: "Broadcast" });

                return TransactionsApi;
            })();

            grpc.ApplicationStatus = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "SUCCEEDED"] = 1;
                values[valuesById[2] = "SCRIPT_EXECUTION_FAILED"] = 2;
                values[valuesById[3] = "SCRIPT_EXECUTION_IN_PROGRESS"] = 3;
                return values;
            })();

            grpc.TransactionStatus = (function() {

                function TransactionStatus(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                TransactionStatus.prototype.id = $util.newBuffer([]);
                TransactionStatus.prototype.status = 0;
                TransactionStatus.prototype.height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                TransactionStatus.prototype.applicationStatus = 0;

                TransactionStatus.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.id != null && m.hasOwnProperty("id"))
                        w.uint32(10).bytes(m.id);
                    if (m.status != null && m.hasOwnProperty("status"))
                        w.uint32(16).int32(m.status);
                    if (m.height != null && m.hasOwnProperty("height"))
                        w.uint32(24).int64(m.height);
                    if (m.applicationStatus != null && m.hasOwnProperty("applicationStatus"))
                        w.uint32(32).int32(m.applicationStatus);
                    return w;
                };

                TransactionStatus.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.TransactionStatus();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.id = r.bytes();
                            break;
                        case 2:
                            m.status = r.int32();
                            break;
                        case 3:
                            m.height = r.int64();
                            break;
                        case 4:
                            m.applicationStatus = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                TransactionStatus.Status = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NOT_EXISTS"] = 0;
                    values[valuesById[1] = "UNCONFIRMED"] = 1;
                    values[valuesById[2] = "CONFIRMED"] = 2;
                    return values;
                })();

                return TransactionStatus;
            })();

            grpc.TransactionResponse = (function() {

                function TransactionResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                TransactionResponse.prototype.id = $util.newBuffer([]);
                TransactionResponse.prototype.height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                TransactionResponse.prototype.transaction = null;
                TransactionResponse.prototype.applicationStatus = 0;
                TransactionResponse.prototype.invokeScriptResult = null;

                TransactionResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.id != null && m.hasOwnProperty("id"))
                        w.uint32(10).bytes(m.id);
                    if (m.height != null && m.hasOwnProperty("height"))
                        w.uint32(16).int64(m.height);
                    if (m.transaction != null && m.hasOwnProperty("transaction"))
                        $root.waves.SignedTransaction.encode(m.transaction, w.uint32(26).fork()).ldelim();
                    if (m.applicationStatus != null && m.hasOwnProperty("applicationStatus"))
                        w.uint32(32).int32(m.applicationStatus);
                    if (m.invokeScriptResult != null && m.hasOwnProperty("invokeScriptResult"))
                        $root.waves.InvokeScriptResult.encode(m.invokeScriptResult, w.uint32(42).fork()).ldelim();
                    return w;
                };

                TransactionResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.TransactionResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.id = r.bytes();
                            break;
                        case 2:
                            m.height = r.int64();
                            break;
                        case 3:
                            m.transaction = $root.waves.SignedTransaction.decode(r, r.uint32());
                            break;
                        case 4:
                            m.applicationStatus = r.int32();
                            break;
                        case 5:
                            m.invokeScriptResult = $root.waves.InvokeScriptResult.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return TransactionResponse;
            })();

            grpc.TransactionsRequest = (function() {

                function TransactionsRequest(p) {
                    this.transactionIds = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                TransactionsRequest.prototype.sender = $util.newBuffer([]);
                TransactionsRequest.prototype.recipient = null;
                TransactionsRequest.prototype.transactionIds = $util.emptyArray;

                TransactionsRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.sender != null && m.hasOwnProperty("sender"))
                        w.uint32(10).bytes(m.sender);
                    if (m.recipient != null && m.hasOwnProperty("recipient"))
                        $root.waves.Recipient.encode(m.recipient, w.uint32(18).fork()).ldelim();
                    if (m.transactionIds != null && m.transactionIds.length) {
                        for (var i = 0; i < m.transactionIds.length; ++i)
                            w.uint32(26).bytes(m.transactionIds[i]);
                    }
                    return w;
                };

                TransactionsRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.TransactionsRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.sender = r.bytes();
                            break;
                        case 2:
                            m.recipient = $root.waves.Recipient.decode(r, r.uint32());
                            break;
                        case 3:
                            if (!(m.transactionIds && m.transactionIds.length))
                                m.transactionIds = [];
                            m.transactionIds.push(r.bytes());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return TransactionsRequest;
            })();

            grpc.TransactionsByIdRequest = (function() {

                function TransactionsByIdRequest(p) {
                    this.transactionIds = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                TransactionsByIdRequest.prototype.transactionIds = $util.emptyArray;

                TransactionsByIdRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.transactionIds != null && m.transactionIds.length) {
                        for (var i = 0; i < m.transactionIds.length; ++i)
                            w.uint32(26).bytes(m.transactionIds[i]);
                    }
                    return w;
                };

                TransactionsByIdRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.TransactionsByIdRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 3:
                            if (!(m.transactionIds && m.transactionIds.length))
                                m.transactionIds = [];
                            m.transactionIds.push(r.bytes());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return TransactionsByIdRequest;
            })();

            grpc.CalculateFeeResponse = (function() {

                function CalculateFeeResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                CalculateFeeResponse.prototype.assetId = $util.newBuffer([]);
                CalculateFeeResponse.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                CalculateFeeResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.assetId != null && m.hasOwnProperty("assetId"))
                        w.uint32(10).bytes(m.assetId);
                    if (m.amount != null && m.hasOwnProperty("amount"))
                        w.uint32(16).uint64(m.amount);
                    return w;
                };

                CalculateFeeResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.CalculateFeeResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.assetId = r.bytes();
                            break;
                        case 2:
                            m.amount = r.uint64();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return CalculateFeeResponse;
            })();

            grpc.SignRequest = (function() {

                function SignRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                SignRequest.prototype.transaction = null;
                SignRequest.prototype.signerPublicKey = $util.newBuffer([]);

                SignRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.transaction != null && m.hasOwnProperty("transaction"))
                        $root.waves.Transaction.encode(m.transaction, w.uint32(10).fork()).ldelim();
                    if (m.signerPublicKey != null && m.hasOwnProperty("signerPublicKey"))
                        w.uint32(18).bytes(m.signerPublicKey);
                    return w;
                };

                SignRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.SignRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.transaction = $root.waves.Transaction.decode(r, r.uint32());
                            break;
                        case 2:
                            m.signerPublicKey = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return SignRequest;
            })();

            grpc.InvokeScriptResultResponse = (function() {

                function InvokeScriptResultResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                InvokeScriptResultResponse.prototype.transaction = null;
                InvokeScriptResultResponse.prototype.result = null;

                InvokeScriptResultResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.transaction != null && m.hasOwnProperty("transaction"))
                        $root.waves.SignedTransaction.encode(m.transaction, w.uint32(10).fork()).ldelim();
                    if (m.result != null && m.hasOwnProperty("result"))
                        $root.waves.InvokeScriptResult.encode(m.result, w.uint32(18).fork()).ldelim();
                    return w;
                };

                InvokeScriptResultResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.node.grpc.InvokeScriptResultResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.transaction = $root.waves.SignedTransaction.decode(r, r.uint32());
                            break;
                        case 2:
                            m.result = $root.waves.InvokeScriptResult.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return InvokeScriptResultResponse;
            })();

            return grpc;
        })();

        return node;
    })();

    waves.AssetPair = (function() {

        function AssetPair(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        AssetPair.prototype.amountAssetId = $util.newBuffer([]);
        AssetPair.prototype.priceAssetId = $util.newBuffer([]);

        AssetPair.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.amountAssetId != null && m.hasOwnProperty("amountAssetId"))
                w.uint32(10).bytes(m.amountAssetId);
            if (m.priceAssetId != null && m.hasOwnProperty("priceAssetId"))
                w.uint32(18).bytes(m.priceAssetId);
            return w;
        };

        AssetPair.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.AssetPair();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.amountAssetId = r.bytes();
                    break;
                case 2:
                    m.priceAssetId = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return AssetPair;
    })();

    waves.Order = (function() {

        function Order(p) {
            this.proofs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        Order.prototype.chainId = 0;
        Order.prototype.senderPublicKey = $util.newBuffer([]);
        Order.prototype.matcherPublicKey = $util.newBuffer([]);
        Order.prototype.assetPair = null;
        Order.prototype.orderSide = 0;
        Order.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        Order.prototype.price = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        Order.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        Order.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        Order.prototype.matcherFee = null;
        Order.prototype.version = 0;
        Order.prototype.proofs = $util.emptyArray;

        Order.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.chainId != null && m.hasOwnProperty("chainId"))
                w.uint32(8).int32(m.chainId);
            if (m.senderPublicKey != null && m.hasOwnProperty("senderPublicKey"))
                w.uint32(18).bytes(m.senderPublicKey);
            if (m.matcherPublicKey != null && m.hasOwnProperty("matcherPublicKey"))
                w.uint32(26).bytes(m.matcherPublicKey);
            if (m.assetPair != null && m.hasOwnProperty("assetPair"))
                $root.waves.AssetPair.encode(m.assetPair, w.uint32(34).fork()).ldelim();
            if (m.orderSide != null && m.hasOwnProperty("orderSide"))
                w.uint32(40).int32(m.orderSide);
            if (m.amount != null && m.hasOwnProperty("amount"))
                w.uint32(48).int64(m.amount);
            if (m.price != null && m.hasOwnProperty("price"))
                w.uint32(56).int64(m.price);
            if (m.timestamp != null && m.hasOwnProperty("timestamp"))
                w.uint32(64).int64(m.timestamp);
            if (m.expiration != null && m.hasOwnProperty("expiration"))
                w.uint32(72).int64(m.expiration);
            if (m.matcherFee != null && m.hasOwnProperty("matcherFee"))
                $root.waves.Amount.encode(m.matcherFee, w.uint32(82).fork()).ldelim();
            if (m.version != null && m.hasOwnProperty("version"))
                w.uint32(88).int32(m.version);
            if (m.proofs != null && m.proofs.length) {
                for (var i = 0; i < m.proofs.length; ++i)
                    w.uint32(98).bytes(m.proofs[i]);
            }
            return w;
        };

        Order.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.Order();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.chainId = r.int32();
                    break;
                case 2:
                    m.senderPublicKey = r.bytes();
                    break;
                case 3:
                    m.matcherPublicKey = r.bytes();
                    break;
                case 4:
                    m.assetPair = $root.waves.AssetPair.decode(r, r.uint32());
                    break;
                case 5:
                    m.orderSide = r.int32();
                    break;
                case 6:
                    m.amount = r.int64();
                    break;
                case 7:
                    m.price = r.int64();
                    break;
                case 8:
                    m.timestamp = r.int64();
                    break;
                case 9:
                    m.expiration = r.int64();
                    break;
                case 10:
                    m.matcherFee = $root.waves.Amount.decode(r, r.uint32());
                    break;
                case 11:
                    m.version = r.int32();
                    break;
                case 12:
                    if (!(m.proofs && m.proofs.length))
                        m.proofs = [];
                    m.proofs.push(r.bytes());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        Order.Side = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "BUY"] = 0;
            values[valuesById[1] = "SELL"] = 1;
            return values;
        })();

        return Order;
    })();

    waves.Recipient = (function() {

        function Recipient(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        Recipient.prototype.publicKeyHash = $util.newBuffer([]);
        Recipient.prototype.alias = "";

        var $oneOfFields;

        Object.defineProperty(Recipient.prototype, "recipient", {
            get: $util.oneOfGetter($oneOfFields = ["publicKeyHash", "alias"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Recipient.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.publicKeyHash != null && m.hasOwnProperty("publicKeyHash"))
                w.uint32(10).bytes(m.publicKeyHash);
            if (m.alias != null && m.hasOwnProperty("alias"))
                w.uint32(18).string(m.alias);
            return w;
        };

        Recipient.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.Recipient();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.publicKeyHash = r.bytes();
                    break;
                case 2:
                    m.alias = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Recipient;
    })();

    waves.SignedTransaction = (function() {

        function SignedTransaction(p) {
            this.proofs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SignedTransaction.prototype.transaction = null;
        SignedTransaction.prototype.proofs = $util.emptyArray;

        SignedTransaction.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transaction != null && m.hasOwnProperty("transaction"))
                $root.waves.Transaction.encode(m.transaction, w.uint32(10).fork()).ldelim();
            if (m.proofs != null && m.proofs.length) {
                for (var i = 0; i < m.proofs.length; ++i)
                    w.uint32(18).bytes(m.proofs[i]);
            }
            return w;
        };

        SignedTransaction.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.SignedTransaction();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.transaction = $root.waves.Transaction.decode(r, r.uint32());
                    break;
                case 2:
                    if (!(m.proofs && m.proofs.length))
                        m.proofs = [];
                    m.proofs.push(r.bytes());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SignedTransaction;
    })();

    waves.Transaction = (function() {

        function Transaction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        Transaction.prototype.chainId = 0;
        Transaction.prototype.senderPublicKey = $util.newBuffer([]);
        Transaction.prototype.fee = null;
        Transaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        Transaction.prototype.version = 0;
        Transaction.prototype.genesis = null;
        Transaction.prototype.payment = null;
        Transaction.prototype.issue = null;
        Transaction.prototype.transfer = null;
        Transaction.prototype.reissue = null;
        Transaction.prototype.burn = null;
        Transaction.prototype.exchange = null;
        Transaction.prototype.lease = null;
        Transaction.prototype.leaseCancel = null;
        Transaction.prototype.createAlias = null;
        Transaction.prototype.massTransfer = null;
        Transaction.prototype.dataTransaction = null;
        Transaction.prototype.setScript = null;
        Transaction.prototype.sponsorFee = null;
        Transaction.prototype.setAssetScript = null;
        Transaction.prototype.invokeScript = null;
        Transaction.prototype.updateAssetInfo = null;
        Transaction.prototype.continuation = null;

        var $oneOfFields;

        Object.defineProperty(Transaction.prototype, "data", {
            get: $util.oneOfGetter($oneOfFields = ["genesis", "payment", "issue", "transfer", "reissue", "burn", "exchange", "lease", "leaseCancel", "createAlias", "massTransfer", "dataTransaction", "setScript", "sponsorFee", "setAssetScript", "invokeScript", "updateAssetInfo", "continuation"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Transaction.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.chainId != null && m.hasOwnProperty("chainId"))
                w.uint32(8).int32(m.chainId);
            if (m.senderPublicKey != null && m.hasOwnProperty("senderPublicKey"))
                w.uint32(18).bytes(m.senderPublicKey);
            if (m.fee != null && m.hasOwnProperty("fee"))
                $root.waves.Amount.encode(m.fee, w.uint32(26).fork()).ldelim();
            if (m.timestamp != null && m.hasOwnProperty("timestamp"))
                w.uint32(32).int64(m.timestamp);
            if (m.version != null && m.hasOwnProperty("version"))
                w.uint32(40).int32(m.version);
            if (m.genesis != null && m.hasOwnProperty("genesis"))
                $root.waves.GenesisTransactionData.encode(m.genesis, w.uint32(810).fork()).ldelim();
            if (m.payment != null && m.hasOwnProperty("payment"))
                $root.waves.PaymentTransactionData.encode(m.payment, w.uint32(818).fork()).ldelim();
            if (m.issue != null && m.hasOwnProperty("issue"))
                $root.waves.IssueTransactionData.encode(m.issue, w.uint32(826).fork()).ldelim();
            if (m.transfer != null && m.hasOwnProperty("transfer"))
                $root.waves.TransferTransactionData.encode(m.transfer, w.uint32(834).fork()).ldelim();
            if (m.reissue != null && m.hasOwnProperty("reissue"))
                $root.waves.ReissueTransactionData.encode(m.reissue, w.uint32(842).fork()).ldelim();
            if (m.burn != null && m.hasOwnProperty("burn"))
                $root.waves.BurnTransactionData.encode(m.burn, w.uint32(850).fork()).ldelim();
            if (m.exchange != null && m.hasOwnProperty("exchange"))
                $root.waves.ExchangeTransactionData.encode(m.exchange, w.uint32(858).fork()).ldelim();
            if (m.lease != null && m.hasOwnProperty("lease"))
                $root.waves.LeaseTransactionData.encode(m.lease, w.uint32(866).fork()).ldelim();
            if (m.leaseCancel != null && m.hasOwnProperty("leaseCancel"))
                $root.waves.LeaseCancelTransactionData.encode(m.leaseCancel, w.uint32(874).fork()).ldelim();
            if (m.createAlias != null && m.hasOwnProperty("createAlias"))
                $root.waves.CreateAliasTransactionData.encode(m.createAlias, w.uint32(882).fork()).ldelim();
            if (m.massTransfer != null && m.hasOwnProperty("massTransfer"))
                $root.waves.MassTransferTransactionData.encode(m.massTransfer, w.uint32(890).fork()).ldelim();
            if (m.dataTransaction != null && m.hasOwnProperty("dataTransaction"))
                $root.waves.DataTransactionData.encode(m.dataTransaction, w.uint32(898).fork()).ldelim();
            if (m.setScript != null && m.hasOwnProperty("setScript"))
                $root.waves.SetScriptTransactionData.encode(m.setScript, w.uint32(906).fork()).ldelim();
            if (m.sponsorFee != null && m.hasOwnProperty("sponsorFee"))
                $root.waves.SponsorFeeTransactionData.encode(m.sponsorFee, w.uint32(914).fork()).ldelim();
            if (m.setAssetScript != null && m.hasOwnProperty("setAssetScript"))
                $root.waves.SetAssetScriptTransactionData.encode(m.setAssetScript, w.uint32(922).fork()).ldelim();
            if (m.invokeScript != null && m.hasOwnProperty("invokeScript"))
                $root.waves.InvokeScriptTransactionData.encode(m.invokeScript, w.uint32(930).fork()).ldelim();
            if (m.updateAssetInfo != null && m.hasOwnProperty("updateAssetInfo"))
                $root.waves.UpdateAssetInfoTransactionData.encode(m.updateAssetInfo, w.uint32(938).fork()).ldelim();
            if (m.continuation != null && m.hasOwnProperty("continuation"))
                $root.waves.ContinuationTransactionData.encode(m.continuation, w.uint32(946).fork()).ldelim();
            return w;
        };

        Transaction.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.Transaction();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.chainId = r.int32();
                    break;
                case 2:
                    m.senderPublicKey = r.bytes();
                    break;
                case 3:
                    m.fee = $root.waves.Amount.decode(r, r.uint32());
                    break;
                case 4:
                    m.timestamp = r.int64();
                    break;
                case 5:
                    m.version = r.int32();
                    break;
                case 101:
                    m.genesis = $root.waves.GenesisTransactionData.decode(r, r.uint32());
                    break;
                case 102:
                    m.payment = $root.waves.PaymentTransactionData.decode(r, r.uint32());
                    break;
                case 103:
                    m.issue = $root.waves.IssueTransactionData.decode(r, r.uint32());
                    break;
                case 104:
                    m.transfer = $root.waves.TransferTransactionData.decode(r, r.uint32());
                    break;
                case 105:
                    m.reissue = $root.waves.ReissueTransactionData.decode(r, r.uint32());
                    break;
                case 106:
                    m.burn = $root.waves.BurnTransactionData.decode(r, r.uint32());
                    break;
                case 107:
                    m.exchange = $root.waves.ExchangeTransactionData.decode(r, r.uint32());
                    break;
                case 108:
                    m.lease = $root.waves.LeaseTransactionData.decode(r, r.uint32());
                    break;
                case 109:
                    m.leaseCancel = $root.waves.LeaseCancelTransactionData.decode(r, r.uint32());
                    break;
                case 110:
                    m.createAlias = $root.waves.CreateAliasTransactionData.decode(r, r.uint32());
                    break;
                case 111:
                    m.massTransfer = $root.waves.MassTransferTransactionData.decode(r, r.uint32());
                    break;
                case 112:
                    m.dataTransaction = $root.waves.DataTransactionData.decode(r, r.uint32());
                    break;
                case 113:
                    m.setScript = $root.waves.SetScriptTransactionData.decode(r, r.uint32());
                    break;
                case 114:
                    m.sponsorFee = $root.waves.SponsorFeeTransactionData.decode(r, r.uint32());
                    break;
                case 115:
                    m.setAssetScript = $root.waves.SetAssetScriptTransactionData.decode(r, r.uint32());
                    break;
                case 116:
                    m.invokeScript = $root.waves.InvokeScriptTransactionData.decode(r, r.uint32());
                    break;
                case 117:
                    m.updateAssetInfo = $root.waves.UpdateAssetInfoTransactionData.decode(r, r.uint32());
                    break;
                case 118:
                    m.continuation = $root.waves.ContinuationTransactionData.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Transaction;
    })();

    waves.GenesisTransactionData = (function() {

        function GenesisTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        GenesisTransactionData.prototype.recipientAddress = $util.newBuffer([]);
        GenesisTransactionData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        GenesisTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.recipientAddress != null && m.hasOwnProperty("recipientAddress"))
                w.uint32(10).bytes(m.recipientAddress);
            if (m.amount != null && m.hasOwnProperty("amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        GenesisTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.GenesisTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.recipientAddress = r.bytes();
                    break;
                case 2:
                    m.amount = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GenesisTransactionData;
    })();

    waves.PaymentTransactionData = (function() {

        function PaymentTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        PaymentTransactionData.prototype.recipientAddress = $util.newBuffer([]);
        PaymentTransactionData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        PaymentTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.recipientAddress != null && m.hasOwnProperty("recipientAddress"))
                w.uint32(10).bytes(m.recipientAddress);
            if (m.amount != null && m.hasOwnProperty("amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        PaymentTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.PaymentTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.recipientAddress = r.bytes();
                    break;
                case 2:
                    m.amount = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return PaymentTransactionData;
    })();

    waves.TransferTransactionData = (function() {

        function TransferTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        TransferTransactionData.prototype.recipient = null;
        TransferTransactionData.prototype.amount = null;
        TransferTransactionData.prototype.attachment = $util.newBuffer([]);

        TransferTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.recipient != null && m.hasOwnProperty("recipient"))
                $root.waves.Recipient.encode(m.recipient, w.uint32(10).fork()).ldelim();
            if (m.amount != null && m.hasOwnProperty("amount"))
                $root.waves.Amount.encode(m.amount, w.uint32(18).fork()).ldelim();
            if (m.attachment != null && m.hasOwnProperty("attachment"))
                w.uint32(26).bytes(m.attachment);
            return w;
        };

        TransferTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.TransferTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.recipient = $root.waves.Recipient.decode(r, r.uint32());
                    break;
                case 2:
                    m.amount = $root.waves.Amount.decode(r, r.uint32());
                    break;
                case 3:
                    m.attachment = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransferTransactionData;
    })();

    waves.CreateAliasTransactionData = (function() {

        function CreateAliasTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        CreateAliasTransactionData.prototype.alias = "";

        CreateAliasTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.alias != null && m.hasOwnProperty("alias"))
                w.uint32(10).string(m.alias);
            return w;
        };

        CreateAliasTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.CreateAliasTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.alias = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CreateAliasTransactionData;
    })();

    waves.DataTransactionData = (function() {

        function DataTransactionData(p) {
            this.data = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        DataTransactionData.prototype.data = $util.emptyArray;

        DataTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.data != null && m.data.length) {
                for (var i = 0; i < m.data.length; ++i)
                    $root.waves.DataTransactionData.DataEntry.encode(m.data[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        DataTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.DataTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.data && m.data.length))
                        m.data = [];
                    m.data.push($root.waves.DataTransactionData.DataEntry.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        DataTransactionData.DataEntry = (function() {

            function DataEntry(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            DataEntry.prototype.key = "";
            DataEntry.prototype.intValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            DataEntry.prototype.boolValue = false;
            DataEntry.prototype.binaryValue = $util.newBuffer([]);
            DataEntry.prototype.stringValue = "";

            var $oneOfFields;

            Object.defineProperty(DataEntry.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["intValue", "boolValue", "binaryValue", "stringValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            DataEntry.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.key != null && m.hasOwnProperty("key"))
                    w.uint32(10).string(m.key);
                if (m.intValue != null && m.hasOwnProperty("intValue"))
                    w.uint32(80).int64(m.intValue);
                if (m.boolValue != null && m.hasOwnProperty("boolValue"))
                    w.uint32(88).bool(m.boolValue);
                if (m.binaryValue != null && m.hasOwnProperty("binaryValue"))
                    w.uint32(98).bytes(m.binaryValue);
                if (m.stringValue != null && m.hasOwnProperty("stringValue"))
                    w.uint32(106).string(m.stringValue);
                return w;
            };

            DataEntry.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.DataTransactionData.DataEntry();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.key = r.string();
                        break;
                    case 10:
                        m.intValue = r.int64();
                        break;
                    case 11:
                        m.boolValue = r.bool();
                        break;
                    case 12:
                        m.binaryValue = r.bytes();
                        break;
                    case 13:
                        m.stringValue = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return DataEntry;
        })();

        return DataTransactionData;
    })();

    waves.MassTransferTransactionData = (function() {

        function MassTransferTransactionData(p) {
            this.transfers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        MassTransferTransactionData.prototype.assetId = $util.newBuffer([]);
        MassTransferTransactionData.prototype.transfers = $util.emptyArray;
        MassTransferTransactionData.prototype.attachment = $util.newBuffer([]);

        MassTransferTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetId != null && m.hasOwnProperty("assetId"))
                w.uint32(10).bytes(m.assetId);
            if (m.transfers != null && m.transfers.length) {
                for (var i = 0; i < m.transfers.length; ++i)
                    $root.waves.MassTransferTransactionData.Transfer.encode(m.transfers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.attachment != null && m.hasOwnProperty("attachment"))
                w.uint32(26).bytes(m.attachment);
            return w;
        };

        MassTransferTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.MassTransferTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetId = r.bytes();
                    break;
                case 2:
                    if (!(m.transfers && m.transfers.length))
                        m.transfers = [];
                    m.transfers.push($root.waves.MassTransferTransactionData.Transfer.decode(r, r.uint32()));
                    break;
                case 3:
                    m.attachment = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        MassTransferTransactionData.Transfer = (function() {

            function Transfer(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Transfer.prototype.recipient = null;
            Transfer.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            Transfer.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.recipient != null && m.hasOwnProperty("recipient"))
                    $root.waves.Recipient.encode(m.recipient, w.uint32(10).fork()).ldelim();
                if (m.amount != null && m.hasOwnProperty("amount"))
                    w.uint32(16).int64(m.amount);
                return w;
            };

            Transfer.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.MassTransferTransactionData.Transfer();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.recipient = $root.waves.Recipient.decode(r, r.uint32());
                        break;
                    case 2:
                        m.amount = r.int64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Transfer;
        })();

        return MassTransferTransactionData;
    })();

    waves.LeaseTransactionData = (function() {

        function LeaseTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        LeaseTransactionData.prototype.recipient = null;
        LeaseTransactionData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        LeaseTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.recipient != null && m.hasOwnProperty("recipient"))
                $root.waves.Recipient.encode(m.recipient, w.uint32(10).fork()).ldelim();
            if (m.amount != null && m.hasOwnProperty("amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        LeaseTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.LeaseTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.recipient = $root.waves.Recipient.decode(r, r.uint32());
                    break;
                case 2:
                    m.amount = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return LeaseTransactionData;
    })();

    waves.LeaseCancelTransactionData = (function() {

        function LeaseCancelTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        LeaseCancelTransactionData.prototype.leaseId = $util.newBuffer([]);

        LeaseCancelTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.leaseId != null && m.hasOwnProperty("leaseId"))
                w.uint32(10).bytes(m.leaseId);
            return w;
        };

        LeaseCancelTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.LeaseCancelTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.leaseId = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return LeaseCancelTransactionData;
    })();

    waves.BurnTransactionData = (function() {

        function BurnTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        BurnTransactionData.prototype.assetAmount = null;

        BurnTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetAmount != null && m.hasOwnProperty("assetAmount"))
                $root.waves.Amount.encode(m.assetAmount, w.uint32(10).fork()).ldelim();
            return w;
        };

        BurnTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.BurnTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetAmount = $root.waves.Amount.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return BurnTransactionData;
    })();

    waves.IssueTransactionData = (function() {

        function IssueTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        IssueTransactionData.prototype.name = "";
        IssueTransactionData.prototype.description = "";
        IssueTransactionData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        IssueTransactionData.prototype.decimals = 0;
        IssueTransactionData.prototype.reissuable = false;
        IssueTransactionData.prototype.script = $util.newBuffer([]);

        IssueTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.name != null && m.hasOwnProperty("name"))
                w.uint32(10).string(m.name);
            if (m.description != null && m.hasOwnProperty("description"))
                w.uint32(18).string(m.description);
            if (m.amount != null && m.hasOwnProperty("amount"))
                w.uint32(24).int64(m.amount);
            if (m.decimals != null && m.hasOwnProperty("decimals"))
                w.uint32(32).int32(m.decimals);
            if (m.reissuable != null && m.hasOwnProperty("reissuable"))
                w.uint32(40).bool(m.reissuable);
            if (m.script != null && m.hasOwnProperty("script"))
                w.uint32(50).bytes(m.script);
            return w;
        };

        IssueTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.IssueTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    m.description = r.string();
                    break;
                case 3:
                    m.amount = r.int64();
                    break;
                case 4:
                    m.decimals = r.int32();
                    break;
                case 5:
                    m.reissuable = r.bool();
                    break;
                case 6:
                    m.script = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return IssueTransactionData;
    })();

    waves.ReissueTransactionData = (function() {

        function ReissueTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        ReissueTransactionData.prototype.assetAmount = null;
        ReissueTransactionData.prototype.reissuable = false;

        ReissueTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetAmount != null && m.hasOwnProperty("assetAmount"))
                $root.waves.Amount.encode(m.assetAmount, w.uint32(10).fork()).ldelim();
            if (m.reissuable != null && m.hasOwnProperty("reissuable"))
                w.uint32(16).bool(m.reissuable);
            return w;
        };

        ReissueTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.ReissueTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetAmount = $root.waves.Amount.decode(r, r.uint32());
                    break;
                case 2:
                    m.reissuable = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ReissueTransactionData;
    })();

    waves.SetAssetScriptTransactionData = (function() {

        function SetAssetScriptTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SetAssetScriptTransactionData.prototype.assetId = $util.newBuffer([]);
        SetAssetScriptTransactionData.prototype.script = $util.newBuffer([]);

        SetAssetScriptTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetId != null && m.hasOwnProperty("assetId"))
                w.uint32(10).bytes(m.assetId);
            if (m.script != null && m.hasOwnProperty("script"))
                w.uint32(18).bytes(m.script);
            return w;
        };

        SetAssetScriptTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.SetAssetScriptTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetId = r.bytes();
                    break;
                case 2:
                    m.script = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SetAssetScriptTransactionData;
    })();

    waves.SetScriptTransactionData = (function() {

        function SetScriptTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SetScriptTransactionData.prototype.script = $util.newBuffer([]);

        SetScriptTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.script != null && m.hasOwnProperty("script"))
                w.uint32(10).bytes(m.script);
            return w;
        };

        SetScriptTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.SetScriptTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.script = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SetScriptTransactionData;
    })();

    waves.ExchangeTransactionData = (function() {

        function ExchangeTransactionData(p) {
            this.orders = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        ExchangeTransactionData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        ExchangeTransactionData.prototype.price = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        ExchangeTransactionData.prototype.buyMatcherFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        ExchangeTransactionData.prototype.sellMatcherFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        ExchangeTransactionData.prototype.orders = $util.emptyArray;

        ExchangeTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.amount != null && m.hasOwnProperty("amount"))
                w.uint32(8).int64(m.amount);
            if (m.price != null && m.hasOwnProperty("price"))
                w.uint32(16).int64(m.price);
            if (m.buyMatcherFee != null && m.hasOwnProperty("buyMatcherFee"))
                w.uint32(24).int64(m.buyMatcherFee);
            if (m.sellMatcherFee != null && m.hasOwnProperty("sellMatcherFee"))
                w.uint32(32).int64(m.sellMatcherFee);
            if (m.orders != null && m.orders.length) {
                for (var i = 0; i < m.orders.length; ++i)
                    $root.waves.Order.encode(m.orders[i], w.uint32(42).fork()).ldelim();
            }
            return w;
        };

        ExchangeTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.ExchangeTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.amount = r.int64();
                    break;
                case 2:
                    m.price = r.int64();
                    break;
                case 3:
                    m.buyMatcherFee = r.int64();
                    break;
                case 4:
                    m.sellMatcherFee = r.int64();
                    break;
                case 5:
                    if (!(m.orders && m.orders.length))
                        m.orders = [];
                    m.orders.push($root.waves.Order.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ExchangeTransactionData;
    })();

    waves.SponsorFeeTransactionData = (function() {

        function SponsorFeeTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SponsorFeeTransactionData.prototype.minFee = null;

        SponsorFeeTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.minFee != null && m.hasOwnProperty("minFee"))
                $root.waves.Amount.encode(m.minFee, w.uint32(10).fork()).ldelim();
            return w;
        };

        SponsorFeeTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.SponsorFeeTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.minFee = $root.waves.Amount.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SponsorFeeTransactionData;
    })();

    waves.InvokeScriptTransactionData = (function() {

        function InvokeScriptTransactionData(p) {
            this.payments = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        InvokeScriptTransactionData.prototype.dApp = null;
        InvokeScriptTransactionData.prototype.functionCall = $util.newBuffer([]);
        InvokeScriptTransactionData.prototype.payments = $util.emptyArray;
        InvokeScriptTransactionData.prototype.extraFeePerStep = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        InvokeScriptTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.dApp != null && m.hasOwnProperty("dApp"))
                $root.waves.Recipient.encode(m.dApp, w.uint32(10).fork()).ldelim();
            if (m.functionCall != null && m.hasOwnProperty("functionCall"))
                w.uint32(18).bytes(m.functionCall);
            if (m.payments != null && m.payments.length) {
                for (var i = 0; i < m.payments.length; ++i)
                    $root.waves.Amount.encode(m.payments[i], w.uint32(26).fork()).ldelim();
            }
            if (m.extraFeePerStep != null && m.hasOwnProperty("extraFeePerStep"))
                w.uint32(32).int64(m.extraFeePerStep);
            return w;
        };

        InvokeScriptTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.InvokeScriptTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.dApp = $root.waves.Recipient.decode(r, r.uint32());
                    break;
                case 2:
                    m.functionCall = r.bytes();
                    break;
                case 3:
                    if (!(m.payments && m.payments.length))
                        m.payments = [];
                    m.payments.push($root.waves.Amount.decode(r, r.uint32()));
                    break;
                case 4:
                    m.extraFeePerStep = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return InvokeScriptTransactionData;
    })();

    waves.UpdateAssetInfoTransactionData = (function() {

        function UpdateAssetInfoTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        UpdateAssetInfoTransactionData.prototype.assetId = $util.newBuffer([]);
        UpdateAssetInfoTransactionData.prototype.name = "";
        UpdateAssetInfoTransactionData.prototype.description = "";

        UpdateAssetInfoTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetId != null && m.hasOwnProperty("assetId"))
                w.uint32(10).bytes(m.assetId);
            if (m.name != null && m.hasOwnProperty("name"))
                w.uint32(18).string(m.name);
            if (m.description != null && m.hasOwnProperty("description"))
                w.uint32(26).string(m.description);
            return w;
        };

        UpdateAssetInfoTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.UpdateAssetInfoTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetId = r.bytes();
                    break;
                case 2:
                    m.name = r.string();
                    break;
                case 3:
                    m.description = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return UpdateAssetInfoTransactionData;
    })();

    waves.ContinuationTransactionData = (function() {

        function ContinuationTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        ContinuationTransactionData.prototype.invokeScriptTransactionId = $util.newBuffer([]);
        ContinuationTransactionData.prototype.nonce = 0;

        ContinuationTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.invokeScriptTransactionId != null && m.hasOwnProperty("invokeScriptTransactionId"))
                w.uint32(10).bytes(m.invokeScriptTransactionId);
            if (m.nonce != null && m.hasOwnProperty("nonce"))
                w.uint32(16).int32(m.nonce);
            return w;
        };

        ContinuationTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.waves.ContinuationTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.invokeScriptTransactionId = r.bytes();
                    break;
                case 2:
                    m.nonce = r.int32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContinuationTransactionData;
    })();

    return waves;
})();

$root.google = (function() {

    var google = {};

    google.protobuf = (function() {

        var protobuf = {};

        protobuf.DoubleValue = (function() {

            function DoubleValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            DoubleValue.prototype.value = 0;

            DoubleValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && m.hasOwnProperty("value"))
                    w.uint32(9).double(m.value);
                return w;
            };

            DoubleValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.DoubleValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.double();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return DoubleValue;
        })();

        protobuf.FloatValue = (function() {

            function FloatValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            FloatValue.prototype.value = 0;

            FloatValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && m.hasOwnProperty("value"))
                    w.uint32(13).float(m.value);
                return w;
            };

            FloatValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FloatValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.float();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return FloatValue;
        })();

        protobuf.Int64Value = (function() {

            function Int64Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            Int64Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && m.hasOwnProperty("value"))
                    w.uint32(8).int64(m.value);
                return w;
            };

            Int64Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.Int64Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.int64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Int64Value;
        })();

        protobuf.UInt64Value = (function() {

            function UInt64Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            UInt64Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && m.hasOwnProperty("value"))
                    w.uint32(8).uint64(m.value);
                return w;
            };

            UInt64Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UInt64Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.uint64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return UInt64Value;
        })();

        protobuf.Int32Value = (function() {

            function Int32Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Int32Value.prototype.value = 0;

            Int32Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && m.hasOwnProperty("value"))
                    w.uint32(8).int32(m.value);
                return w;
            };

            Int32Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.Int32Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.int32();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Int32Value;
        })();

        protobuf.UInt32Value = (function() {

            function UInt32Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            UInt32Value.prototype.value = 0;

            UInt32Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && m.hasOwnProperty("value"))
                    w.uint32(8).uint32(m.value);
                return w;
            };

            UInt32Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UInt32Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.uint32();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return UInt32Value;
        })();

        protobuf.BoolValue = (function() {

            function BoolValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            BoolValue.prototype.value = false;

            BoolValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && m.hasOwnProperty("value"))
                    w.uint32(8).bool(m.value);
                return w;
            };

            BoolValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.BoolValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.bool();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return BoolValue;
        })();

        protobuf.StringValue = (function() {

            function StringValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            StringValue.prototype.value = "";

            StringValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && m.hasOwnProperty("value"))
                    w.uint32(10).string(m.value);
                return w;
            };

            StringValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.StringValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return StringValue;
        })();

        protobuf.BytesValue = (function() {

            function BytesValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            BytesValue.prototype.value = $util.newBuffer([]);

            BytesValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && m.hasOwnProperty("value"))
                    w.uint32(10).bytes(m.value);
                return w;
            };

            BytesValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.BytesValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.bytes();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return BytesValue;
        })();

        protobuf.Empty = (function() {

            function Empty(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Empty.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                return w;
            };

            Empty.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.Empty();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Empty;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
