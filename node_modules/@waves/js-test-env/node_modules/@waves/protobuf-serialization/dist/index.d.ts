import * as $protobuf from "protobufjs";
export namespace waves {

    interface IAmount {
        assetId?: (Uint8Array|null);
        amount?: (Long|null);
    }

    class Amount implements IAmount {
        constructor(p?: waves.IAmount);
        public assetId: Uint8Array;
        public amount: Long;
        public static encode(m: waves.IAmount, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.Amount;
    }

    interface IBlock {
        header?: (waves.Block.IHeader|null);
        signature?: (Uint8Array|null);
        transactions?: (waves.ISignedTransaction[]|null);
    }

    class Block implements IBlock {
        constructor(p?: waves.IBlock);
        public header?: (waves.Block.IHeader|null);
        public signature: Uint8Array;
        public transactions: waves.ISignedTransaction[];
        public static encode(m: waves.IBlock, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.Block;
    }

    namespace Block {

        interface IHeader {
            chainId?: (number|null);
            reference?: (Uint8Array|null);
            baseTarget?: (Long|null);
            generationSignature?: (Uint8Array|null);
            featureVotes?: (number[]|null);
            timestamp?: (Long|null);
            version?: (number|null);
            generator?: (Uint8Array|null);
            rewardVote?: (Long|null);
            transactionsRoot?: (Uint8Array|null);
        }

        class Header implements IHeader {
            constructor(p?: waves.Block.IHeader);
            public chainId: number;
            public reference: Uint8Array;
            public baseTarget: Long;
            public generationSignature: Uint8Array;
            public featureVotes: number[];
            public timestamp: Long;
            public version: number;
            public generator: Uint8Array;
            public rewardVote: Long;
            public transactionsRoot: Uint8Array;
            public static encode(m: waves.Block.IHeader, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.Block.Header;
        }
    }

    interface IMicroBlock {
        version?: (number|null);
        reference?: (Uint8Array|null);
        updatedBlockSignature?: (Uint8Array|null);
        senderPublicKey?: (Uint8Array|null);
        transactions?: (waves.ISignedTransaction[]|null);
    }

    class MicroBlock implements IMicroBlock {
        constructor(p?: waves.IMicroBlock);
        public version: number;
        public reference: Uint8Array;
        public updatedBlockSignature: Uint8Array;
        public senderPublicKey: Uint8Array;
        public transactions: waves.ISignedTransaction[];
        public static encode(m: waves.IMicroBlock, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.MicroBlock;
    }

    interface ISignedMicroBlock {
        microBlock?: (waves.IMicroBlock|null);
        signature?: (Uint8Array|null);
        totalBlockId?: (Uint8Array|null);
    }

    class SignedMicroBlock implements ISignedMicroBlock {
        constructor(p?: waves.ISignedMicroBlock);
        public microBlock?: (waves.IMicroBlock|null);
        public signature: Uint8Array;
        public totalBlockId: Uint8Array;
        public static encode(m: waves.ISignedMicroBlock, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.SignedMicroBlock;
    }

    namespace events {

        interface IBlockchainUpdated {
            id?: (Uint8Array|null);
            height?: (number|null);
            append?: (waves.events.BlockchainUpdated.IAppend|null);
            rollback?: (waves.events.BlockchainUpdated.IRollback|null);
        }

        class BlockchainUpdated implements IBlockchainUpdated {
            constructor(p?: waves.events.IBlockchainUpdated);
            public id: Uint8Array;
            public height: number;
            public append?: (waves.events.BlockchainUpdated.IAppend|null);
            public rollback?: (waves.events.BlockchainUpdated.IRollback|null);
            public update?: ("append"|"rollback");
            public static encode(m: waves.events.IBlockchainUpdated, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.BlockchainUpdated;
        }

        namespace BlockchainUpdated {

            interface IAppend {
                block?: (waves.events.BlockchainUpdated.Append.IBlockAppend|null);
                microBlock?: (waves.events.BlockchainUpdated.Append.IMicroBlockAppend|null);
                transactionIds?: (Uint8Array[]|null);
                stateUpdate?: (waves.events.IStateUpdate|null);
                transactionStateUpdates?: (waves.events.IStateUpdate[]|null);
            }

            class Append implements IAppend {
                constructor(p?: waves.events.BlockchainUpdated.IAppend);
                public block?: (waves.events.BlockchainUpdated.Append.IBlockAppend|null);
                public microBlock?: (waves.events.BlockchainUpdated.Append.IMicroBlockAppend|null);
                public transactionIds: Uint8Array[];
                public stateUpdate?: (waves.events.IStateUpdate|null);
                public transactionStateUpdates: waves.events.IStateUpdate[];
                public body?: ("block"|"microBlock");
                public static encode(m: waves.events.BlockchainUpdated.IAppend, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.BlockchainUpdated.Append;
            }

            namespace Append {

                interface IBlockAppend {
                    block?: (waves.IBlock|null);
                    updatedWavesAmount?: (Long|null);
                }

                class BlockAppend implements IBlockAppend {
                    constructor(p?: waves.events.BlockchainUpdated.Append.IBlockAppend);
                    public block?: (waves.IBlock|null);
                    public updatedWavesAmount: Long;
                    public static encode(m: waves.events.BlockchainUpdated.Append.IBlockAppend, w?: $protobuf.Writer): $protobuf.Writer;
                    public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.BlockchainUpdated.Append.BlockAppend;
                }

                interface IMicroBlockAppend {
                    microBlock?: (waves.ISignedMicroBlock|null);
                    updatedTransactionsRoot?: (Uint8Array|null);
                }

                class MicroBlockAppend implements IMicroBlockAppend {
                    constructor(p?: waves.events.BlockchainUpdated.Append.IMicroBlockAppend);
                    public microBlock?: (waves.ISignedMicroBlock|null);
                    public updatedTransactionsRoot: Uint8Array;
                    public static encode(m: waves.events.BlockchainUpdated.Append.IMicroBlockAppend, w?: $protobuf.Writer): $protobuf.Writer;
                    public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.BlockchainUpdated.Append.MicroBlockAppend;
                }
            }

            interface IRollback {
                type?: (waves.events.BlockchainUpdated.Rollback.RollbackType|null);
            }

            class Rollback implements IRollback {
                constructor(p?: waves.events.BlockchainUpdated.IRollback);
                public type: waves.events.BlockchainUpdated.Rollback.RollbackType;
                public static encode(m: waves.events.BlockchainUpdated.IRollback, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.BlockchainUpdated.Rollback;
            }

            namespace Rollback {

                enum RollbackType {
                    BLOCK = 0,
                    MICROBLOCK = 1
                }
            }
        }

        interface IStateUpdate {
            balances?: (waves.events.StateUpdate.IBalanceUpdate[]|null);
            leases?: (waves.events.StateUpdate.ILeasingUpdate[]|null);
            dataEntries?: (waves.events.StateUpdate.IDataEntryUpdate[]|null);
            assets?: (waves.events.StateUpdate.IAssetStateUpdate[]|null);
        }

        class StateUpdate implements IStateUpdate {
            constructor(p?: waves.events.IStateUpdate);
            public balances: waves.events.StateUpdate.IBalanceUpdate[];
            public leases: waves.events.StateUpdate.ILeasingUpdate[];
            public dataEntries: waves.events.StateUpdate.IDataEntryUpdate[];
            public assets: waves.events.StateUpdate.IAssetStateUpdate[];
            public static encode(m: waves.events.IStateUpdate, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.StateUpdate;
        }

        namespace StateUpdate {

            interface IBalanceUpdate {
                address?: (Uint8Array|null);
                amount?: (waves.IAmount|null);
            }

            class BalanceUpdate implements IBalanceUpdate {
                constructor(p?: waves.events.StateUpdate.IBalanceUpdate);
                public address: Uint8Array;
                public amount?: (waves.IAmount|null);
                public static encode(m: waves.events.StateUpdate.IBalanceUpdate, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.StateUpdate.BalanceUpdate;
            }

            interface ILeasingUpdate {
                address?: (Uint8Array|null);
                "in"?: (Long|null);
                out?: (Long|null);
            }

            class LeasingUpdate implements ILeasingUpdate {
                constructor(p?: waves.events.StateUpdate.ILeasingUpdate);
                public address: Uint8Array;
                public in: Long;
                public out: Long;
                public static encode(m: waves.events.StateUpdate.ILeasingUpdate, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.StateUpdate.LeasingUpdate;
            }

            interface IDataEntryUpdate {
                address?: (Uint8Array|null);
                dataEntry?: (waves.DataTransactionData.IDataEntry|null);
            }

            class DataEntryUpdate implements IDataEntryUpdate {
                constructor(p?: waves.events.StateUpdate.IDataEntryUpdate);
                public address: Uint8Array;
                public dataEntry?: (waves.DataTransactionData.IDataEntry|null);
                public static encode(m: waves.events.StateUpdate.IDataEntryUpdate, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.StateUpdate.DataEntryUpdate;
            }

            interface IAssetStateUpdate {
                assetId?: (Uint8Array|null);
                decimals?: (number|null);
                name?: (string|null);
                description?: (string|null);
                reissuable?: (boolean|null);
                volume?: (Long|null);
                scriptInfo?: (waves.events.StateUpdate.AssetStateUpdate.IAssetScriptInfo|null);
                sponsorship?: (Long|null);
                nft?: (boolean|null);
                assetExistedBefore?: (boolean|null);
                safeVolume?: (Uint8Array|null);
            }

            class AssetStateUpdate implements IAssetStateUpdate {
                constructor(p?: waves.events.StateUpdate.IAssetStateUpdate);
                public assetId: Uint8Array;
                public decimals: number;
                public name: string;
                public description: string;
                public reissuable: boolean;
                public volume: Long;
                public scriptInfo?: (waves.events.StateUpdate.AssetStateUpdate.IAssetScriptInfo|null);
                public sponsorship: Long;
                public nft: boolean;
                public assetExistedBefore: boolean;
                public safeVolume: Uint8Array;
                public static encode(m: waves.events.StateUpdate.IAssetStateUpdate, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.StateUpdate.AssetStateUpdate;
            }

            namespace AssetStateUpdate {

                interface IAssetScriptInfo {
                    script?: (Uint8Array|null);
                    complexity?: (Long|null);
                }

                class AssetScriptInfo implements IAssetScriptInfo {
                    constructor(p?: waves.events.StateUpdate.AssetStateUpdate.IAssetScriptInfo);
                    public script: Uint8Array;
                    public complexity: Long;
                    public static encode(m: waves.events.StateUpdate.AssetStateUpdate.IAssetScriptInfo, w?: $protobuf.Writer): $protobuf.Writer;
                    public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.StateUpdate.AssetStateUpdate.AssetScriptInfo;
                }
            }
        }

        namespace grpc {

            class BlockchainUpdatesApi extends $protobuf.rpc.Service {
                constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);
                public getBlockUpdate(request: waves.events.grpc.IGetBlockUpdateRequest, callback: waves.events.grpc.BlockchainUpdatesApi.GetBlockUpdateCallback): void;
                public getBlockUpdate(request: waves.events.grpc.IGetBlockUpdateRequest): Promise<waves.events.grpc.GetBlockUpdateResponse>;
                public getBlockUpdatesRange(request: waves.events.grpc.IGetBlockUpdatesRangeRequest, callback: waves.events.grpc.BlockchainUpdatesApi.GetBlockUpdatesRangeCallback): void;
                public getBlockUpdatesRange(request: waves.events.grpc.IGetBlockUpdatesRangeRequest): Promise<waves.events.grpc.GetBlockUpdatesRangeResponse>;
                public subscribe(request: waves.events.grpc.ISubscribeRequest, callback: waves.events.grpc.BlockchainUpdatesApi.SubscribeCallback): void;
                public subscribe(request: waves.events.grpc.ISubscribeRequest): Promise<waves.events.grpc.SubscribeEvent>;
            }

            namespace BlockchainUpdatesApi {

                type GetBlockUpdateCallback = (error: (Error|null), response?: waves.events.grpc.GetBlockUpdateResponse) => void;

                type GetBlockUpdatesRangeCallback = (error: (Error|null), response?: waves.events.grpc.GetBlockUpdatesRangeResponse) => void;

                type SubscribeCallback = (error: (Error|null), response?: waves.events.grpc.SubscribeEvent) => void;
            }

            interface IGetBlockUpdateRequest {
                height?: (number|null);
            }

            class GetBlockUpdateRequest implements IGetBlockUpdateRequest {
                constructor(p?: waves.events.grpc.IGetBlockUpdateRequest);
                public height: number;
                public static encode(m: waves.events.grpc.IGetBlockUpdateRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.grpc.GetBlockUpdateRequest;
            }

            interface IGetBlockUpdateResponse {
                update?: (waves.events.IBlockchainUpdated|null);
            }

            class GetBlockUpdateResponse implements IGetBlockUpdateResponse {
                constructor(p?: waves.events.grpc.IGetBlockUpdateResponse);
                public update?: (waves.events.IBlockchainUpdated|null);
                public static encode(m: waves.events.grpc.IGetBlockUpdateResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.grpc.GetBlockUpdateResponse;
            }

            interface IGetBlockUpdatesRangeRequest {
                fromHeight?: (number|null);
                toHeight?: (number|null);
            }

            class GetBlockUpdatesRangeRequest implements IGetBlockUpdatesRangeRequest {
                constructor(p?: waves.events.grpc.IGetBlockUpdatesRangeRequest);
                public fromHeight: number;
                public toHeight: number;
                public static encode(m: waves.events.grpc.IGetBlockUpdatesRangeRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.grpc.GetBlockUpdatesRangeRequest;
            }

            interface IGetBlockUpdatesRangeResponse {
                updates?: (waves.events.IBlockchainUpdated[]|null);
            }

            class GetBlockUpdatesRangeResponse implements IGetBlockUpdatesRangeResponse {
                constructor(p?: waves.events.grpc.IGetBlockUpdatesRangeResponse);
                public updates: waves.events.IBlockchainUpdated[];
                public static encode(m: waves.events.grpc.IGetBlockUpdatesRangeResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.grpc.GetBlockUpdatesRangeResponse;
            }

            interface ISubscribeRequest {
                fromHeight?: (number|null);
                toHeight?: (number|null);
            }

            class SubscribeRequest implements ISubscribeRequest {
                constructor(p?: waves.events.grpc.ISubscribeRequest);
                public fromHeight: number;
                public toHeight: number;
                public static encode(m: waves.events.grpc.ISubscribeRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.grpc.SubscribeRequest;
            }

            interface ISubscribeEvent {
                update?: (waves.events.IBlockchainUpdated|null);
            }

            class SubscribeEvent implements ISubscribeEvent {
                constructor(p?: waves.events.grpc.ISubscribeEvent);
                public update?: (waves.events.IBlockchainUpdated|null);
                public static encode(m: waves.events.grpc.ISubscribeEvent, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.events.grpc.SubscribeEvent;
            }
        }
    }

    interface IInvokeScriptResult {
        data?: (waves.DataTransactionData.IDataEntry[]|null);
        transfers?: (waves.InvokeScriptResult.IPayment[]|null);
        issues?: (waves.InvokeScriptResult.IIssue[]|null);
        reissues?: (waves.InvokeScriptResult.IReissue[]|null);
        burns?: (waves.InvokeScriptResult.IBurn[]|null);
        errorMessage?: (waves.InvokeScriptResult.IErrorMessage|null);
        sponsorFees?: (waves.InvokeScriptResult.ISponsorFee[]|null);
    }

    class InvokeScriptResult implements IInvokeScriptResult {
        constructor(p?: waves.IInvokeScriptResult);
        public data: waves.DataTransactionData.IDataEntry[];
        public transfers: waves.InvokeScriptResult.IPayment[];
        public issues: waves.InvokeScriptResult.IIssue[];
        public reissues: waves.InvokeScriptResult.IReissue[];
        public burns: waves.InvokeScriptResult.IBurn[];
        public errorMessage?: (waves.InvokeScriptResult.IErrorMessage|null);
        public sponsorFees: waves.InvokeScriptResult.ISponsorFee[];
        public static encode(m: waves.IInvokeScriptResult, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.InvokeScriptResult;
    }

    namespace InvokeScriptResult {

        interface IPayment {
            address?: (Uint8Array|null);
            amount?: (waves.IAmount|null);
        }

        class Payment implements IPayment {
            constructor(p?: waves.InvokeScriptResult.IPayment);
            public address: Uint8Array;
            public amount?: (waves.IAmount|null);
            public static encode(m: waves.InvokeScriptResult.IPayment, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.InvokeScriptResult.Payment;
        }

        interface IIssue {
            assetId?: (Uint8Array|null);
            name?: (string|null);
            description?: (string|null);
            amount?: (Long|null);
            decimals?: (number|null);
            reissuable?: (boolean|null);
            script?: (Uint8Array|null);
            nonce?: (Long|null);
        }

        class Issue implements IIssue {
            constructor(p?: waves.InvokeScriptResult.IIssue);
            public assetId: Uint8Array;
            public name: string;
            public description: string;
            public amount: Long;
            public decimals: number;
            public reissuable: boolean;
            public script: Uint8Array;
            public nonce: Long;
            public static encode(m: waves.InvokeScriptResult.IIssue, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.InvokeScriptResult.Issue;
        }

        interface IReissue {
            assetId?: (Uint8Array|null);
            amount?: (Long|null);
            isReissuable?: (boolean|null);
        }

        class Reissue implements IReissue {
            constructor(p?: waves.InvokeScriptResult.IReissue);
            public assetId: Uint8Array;
            public amount: Long;
            public isReissuable: boolean;
            public static encode(m: waves.InvokeScriptResult.IReissue, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.InvokeScriptResult.Reissue;
        }

        interface IBurn {
            assetId?: (Uint8Array|null);
            amount?: (Long|null);
        }

        class Burn implements IBurn {
            constructor(p?: waves.InvokeScriptResult.IBurn);
            public assetId: Uint8Array;
            public amount: Long;
            public static encode(m: waves.InvokeScriptResult.IBurn, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.InvokeScriptResult.Burn;
        }

        interface ISponsorFee {
            minFee?: (waves.IAmount|null);
        }

        class SponsorFee implements ISponsorFee {
            constructor(p?: waves.InvokeScriptResult.ISponsorFee);
            public minFee?: (waves.IAmount|null);
            public static encode(m: waves.InvokeScriptResult.ISponsorFee, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.InvokeScriptResult.SponsorFee;
        }

        interface IErrorMessage {
            code?: (number|null);
            text?: (string|null);
        }

        class ErrorMessage implements IErrorMessage {
            constructor(p?: waves.InvokeScriptResult.IErrorMessage);
            public code: number;
            public text: string;
            public static encode(m: waves.InvokeScriptResult.IErrorMessage, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.InvokeScriptResult.ErrorMessage;
        }
    }

    namespace node {

        namespace grpc {

            class AccountsApi extends $protobuf.rpc.Service {
                constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);
                public getBalances(request: waves.node.grpc.IBalancesRequest, callback: waves.node.grpc.AccountsApi.GetBalancesCallback): void;
                public getBalances(request: waves.node.grpc.IBalancesRequest): Promise<waves.node.grpc.BalanceResponse>;
                public getScript(request: waves.node.grpc.IAccountRequest, callback: waves.node.grpc.AccountsApi.GetScriptCallback): void;
                public getScript(request: waves.node.grpc.IAccountRequest): Promise<waves.node.grpc.ScriptData>;
                public getActiveLeases(request: waves.node.grpc.IAccountRequest, callback: waves.node.grpc.AccountsApi.GetActiveLeasesCallback): void;
                public getActiveLeases(request: waves.node.grpc.IAccountRequest): Promise<waves.node.grpc.TransactionResponse>;
                public getDataEntries(request: waves.node.grpc.IDataRequest, callback: waves.node.grpc.AccountsApi.GetDataEntriesCallback): void;
                public getDataEntries(request: waves.node.grpc.IDataRequest): Promise<waves.node.grpc.DataEntryResponse>;
                public resolveAlias(request: google.protobuf.IStringValue, callback: waves.node.grpc.AccountsApi.ResolveAliasCallback): void;
                public resolveAlias(request: google.protobuf.IStringValue): Promise<google.protobuf.BytesValue>;
            }

            namespace AccountsApi {

                type GetBalancesCallback = (error: (Error|null), response?: waves.node.grpc.BalanceResponse) => void;

                type GetScriptCallback = (error: (Error|null), response?: waves.node.grpc.ScriptData) => void;

                type GetActiveLeasesCallback = (error: (Error|null), response?: waves.node.grpc.TransactionResponse) => void;

                type GetDataEntriesCallback = (error: (Error|null), response?: waves.node.grpc.DataEntryResponse) => void;

                type ResolveAliasCallback = (error: (Error|null), response?: google.protobuf.BytesValue) => void;
            }

            interface IAccountRequest {
                address?: (Uint8Array|null);
            }

            class AccountRequest implements IAccountRequest {
                constructor(p?: waves.node.grpc.IAccountRequest);
                public address: Uint8Array;
                public static encode(m: waves.node.grpc.IAccountRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.AccountRequest;
            }

            interface IDataRequest {
                address?: (Uint8Array|null);
                key?: (string|null);
            }

            class DataRequest implements IDataRequest {
                constructor(p?: waves.node.grpc.IDataRequest);
                public address: Uint8Array;
                public key: string;
                public static encode(m: waves.node.grpc.IDataRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.DataRequest;
            }

            interface IBalancesRequest {
                address?: (Uint8Array|null);
                assets?: (Uint8Array[]|null);
            }

            class BalancesRequest implements IBalancesRequest {
                constructor(p?: waves.node.grpc.IBalancesRequest);
                public address: Uint8Array;
                public assets: Uint8Array[];
                public static encode(m: waves.node.grpc.IBalancesRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.BalancesRequest;
            }

            interface IBalanceResponse {
                waves?: (waves.node.grpc.BalanceResponse.IWavesBalances|null);
                asset?: (waves.IAmount|null);
            }

            class BalanceResponse implements IBalanceResponse {
                constructor(p?: waves.node.grpc.IBalanceResponse);
                public waves?: (waves.node.grpc.BalanceResponse.IWavesBalances|null);
                public asset?: (waves.IAmount|null);
                public balance?: ("waves"|"asset");
                public static encode(m: waves.node.grpc.IBalanceResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.BalanceResponse;
            }

            namespace BalanceResponse {

                interface IWavesBalances {
                    regular?: (Long|null);
                    generating?: (Long|null);
                    available?: (Long|null);
                    effective?: (Long|null);
                    leaseIn?: (Long|null);
                    leaseOut?: (Long|null);
                }

                class WavesBalances implements IWavesBalances {
                    constructor(p?: waves.node.grpc.BalanceResponse.IWavesBalances);
                    public regular: Long;
                    public generating: Long;
                    public available: Long;
                    public effective: Long;
                    public leaseIn: Long;
                    public leaseOut: Long;
                    public static encode(m: waves.node.grpc.BalanceResponse.IWavesBalances, w?: $protobuf.Writer): $protobuf.Writer;
                    public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.BalanceResponse.WavesBalances;
                }
            }

            interface IDataEntryResponse {
                address?: (Uint8Array|null);
                entry?: (waves.DataTransactionData.IDataEntry|null);
            }

            class DataEntryResponse implements IDataEntryResponse {
                constructor(p?: waves.node.grpc.IDataEntryResponse);
                public address: Uint8Array;
                public entry?: (waves.DataTransactionData.IDataEntry|null);
                public static encode(m: waves.node.grpc.IDataEntryResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.DataEntryResponse;
            }

            interface IScriptData {
                scriptBytes?: (Uint8Array|null);
                scriptText?: (string|null);
                complexity?: (Long|null);
            }

            class ScriptData implements IScriptData {
                constructor(p?: waves.node.grpc.IScriptData);
                public scriptBytes: Uint8Array;
                public scriptText: string;
                public complexity: Long;
                public static encode(m: waves.node.grpc.IScriptData, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.ScriptData;
            }

            class AssetsApi extends $protobuf.rpc.Service {
                constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);
                public getInfo(request: waves.node.grpc.IAssetRequest, callback: waves.node.grpc.AssetsApi.GetInfoCallback): void;
                public getInfo(request: waves.node.grpc.IAssetRequest): Promise<waves.node.grpc.AssetInfoResponse>;
                public getNFTList(request: waves.node.grpc.INFTRequest, callback: waves.node.grpc.AssetsApi.GetNFTListCallback): void;
                public getNFTList(request: waves.node.grpc.INFTRequest): Promise<waves.node.grpc.NFTResponse>;
            }

            namespace AssetsApi {

                type GetInfoCallback = (error: (Error|null), response?: waves.node.grpc.AssetInfoResponse) => void;

                type GetNFTListCallback = (error: (Error|null), response?: waves.node.grpc.NFTResponse) => void;
            }

            interface IAssetRequest {
                assetId?: (Uint8Array|null);
            }

            class AssetRequest implements IAssetRequest {
                constructor(p?: waves.node.grpc.IAssetRequest);
                public assetId: Uint8Array;
                public static encode(m: waves.node.grpc.IAssetRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.AssetRequest;
            }

            interface INFTRequest {
                address?: (Uint8Array|null);
                limit?: (number|null);
                afterAssetId?: (Uint8Array|null);
            }

            class NFTRequest implements INFTRequest {
                constructor(p?: waves.node.grpc.INFTRequest);
                public address: Uint8Array;
                public limit: number;
                public afterAssetId: Uint8Array;
                public static encode(m: waves.node.grpc.INFTRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.NFTRequest;
            }

            interface INFTResponse {
                assetId?: (Uint8Array|null);
                assetInfo?: (waves.node.grpc.IAssetInfoResponse|null);
            }

            class NFTResponse implements INFTResponse {
                constructor(p?: waves.node.grpc.INFTResponse);
                public assetId: Uint8Array;
                public assetInfo?: (waves.node.grpc.IAssetInfoResponse|null);
                public static encode(m: waves.node.grpc.INFTResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.NFTResponse;
            }

            interface IAssetInfoResponse {
                issuer?: (Uint8Array|null);
                name?: (string|null);
                description?: (string|null);
                decimals?: (number|null);
                reissuable?: (boolean|null);
                totalVolume?: (Long|null);
                script?: (waves.node.grpc.IScriptData|null);
                sponsorship?: (Long|null);
                issueTransaction?: (waves.ISignedTransaction|null);
                sponsorBalance?: (Long|null);
            }

            class AssetInfoResponse implements IAssetInfoResponse {
                constructor(p?: waves.node.grpc.IAssetInfoResponse);
                public issuer: Uint8Array;
                public name: string;
                public description: string;
                public decimals: number;
                public reissuable: boolean;
                public totalVolume: Long;
                public script?: (waves.node.grpc.IScriptData|null);
                public sponsorship: Long;
                public issueTransaction?: (waves.ISignedTransaction|null);
                public sponsorBalance: Long;
                public static encode(m: waves.node.grpc.IAssetInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.AssetInfoResponse;
            }

            class BlockchainApi extends $protobuf.rpc.Service {
                constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);
                public getActivationStatus(request: waves.node.grpc.IActivationStatusRequest, callback: waves.node.grpc.BlockchainApi.GetActivationStatusCallback): void;
                public getActivationStatus(request: waves.node.grpc.IActivationStatusRequest): Promise<waves.node.grpc.ActivationStatusResponse>;
                public getBaseTarget(request: google.protobuf.IEmpty, callback: waves.node.grpc.BlockchainApi.GetBaseTargetCallback): void;
                public getBaseTarget(request: google.protobuf.IEmpty): Promise<waves.node.grpc.BaseTargetResponse>;
                public getCumulativeScore(request: google.protobuf.IEmpty, callback: waves.node.grpc.BlockchainApi.GetCumulativeScoreCallback): void;
                public getCumulativeScore(request: google.protobuf.IEmpty): Promise<waves.node.grpc.ScoreResponse>;
            }

            namespace BlockchainApi {

                type GetActivationStatusCallback = (error: (Error|null), response?: waves.node.grpc.ActivationStatusResponse) => void;

                type GetBaseTargetCallback = (error: (Error|null), response?: waves.node.grpc.BaseTargetResponse) => void;

                type GetCumulativeScoreCallback = (error: (Error|null), response?: waves.node.grpc.ScoreResponse) => void;
            }

            interface IActivationStatusRequest {
                height?: (number|null);
            }

            class ActivationStatusRequest implements IActivationStatusRequest {
                constructor(p?: waves.node.grpc.IActivationStatusRequest);
                public height: number;
                public static encode(m: waves.node.grpc.IActivationStatusRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.ActivationStatusRequest;
            }

            interface IActivationStatusResponse {
                height?: (number|null);
                votingInterval?: (number|null);
                votingThreshold?: (number|null);
                nextCheck?: (number|null);
                features?: (waves.node.grpc.IFeatureActivationStatus[]|null);
            }

            class ActivationStatusResponse implements IActivationStatusResponse {
                constructor(p?: waves.node.grpc.IActivationStatusResponse);
                public height: number;
                public votingInterval: number;
                public votingThreshold: number;
                public nextCheck: number;
                public features: waves.node.grpc.IFeatureActivationStatus[];
                public static encode(m: waves.node.grpc.IActivationStatusResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.ActivationStatusResponse;
            }

            interface IFeatureActivationStatus {
                id?: (number|null);
                description?: (string|null);
                blockchainStatus?: (waves.node.grpc.FeatureActivationStatus.BlockchainFeatureStatus|null);
                nodeStatus?: (waves.node.grpc.FeatureActivationStatus.NodeFeatureStatus|null);
                activationHeight?: (number|null);
                supportingBlocks?: (number|null);
            }

            class FeatureActivationStatus implements IFeatureActivationStatus {
                constructor(p?: waves.node.grpc.IFeatureActivationStatus);
                public id: number;
                public description: string;
                public blockchainStatus: waves.node.grpc.FeatureActivationStatus.BlockchainFeatureStatus;
                public nodeStatus: waves.node.grpc.FeatureActivationStatus.NodeFeatureStatus;
                public activationHeight: number;
                public supportingBlocks: number;
                public static encode(m: waves.node.grpc.IFeatureActivationStatus, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.FeatureActivationStatus;
            }

            namespace FeatureActivationStatus {

                enum BlockchainFeatureStatus {
                    UNDEFINED = 0,
                    APPROVED = 1,
                    ACTIVATED = 2
                }

                enum NodeFeatureStatus {
                    NOT_IMPLEMENTED = 0,
                    IMPLEMENTED = 1,
                    VOTED = 2
                }
            }

            interface IBaseTargetResponse {
                baseTarget?: (Long|null);
            }

            class BaseTargetResponse implements IBaseTargetResponse {
                constructor(p?: waves.node.grpc.IBaseTargetResponse);
                public baseTarget: Long;
                public static encode(m: waves.node.grpc.IBaseTargetResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.BaseTargetResponse;
            }

            interface IScoreResponse {
                score?: (Uint8Array|null);
            }

            class ScoreResponse implements IScoreResponse {
                constructor(p?: waves.node.grpc.IScoreResponse);
                public score: Uint8Array;
                public static encode(m: waves.node.grpc.IScoreResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.ScoreResponse;
            }

            class BlocksApi extends $protobuf.rpc.Service {
                constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);
                public getBlock(request: waves.node.grpc.IBlockRequest, callback: waves.node.grpc.BlocksApi.GetBlockCallback): void;
                public getBlock(request: waves.node.grpc.IBlockRequest): Promise<waves.node.grpc.BlockWithHeight>;
                public getBlockRange(request: waves.node.grpc.IBlockRangeRequest, callback: waves.node.grpc.BlocksApi.GetBlockRangeCallback): void;
                public getBlockRange(request: waves.node.grpc.IBlockRangeRequest): Promise<waves.node.grpc.BlockWithHeight>;
                public getCurrentHeight(request: google.protobuf.IEmpty, callback: waves.node.grpc.BlocksApi.GetCurrentHeightCallback): void;
                public getCurrentHeight(request: google.protobuf.IEmpty): Promise<google.protobuf.UInt32Value>;
            }

            namespace BlocksApi {

                type GetBlockCallback = (error: (Error|null), response?: waves.node.grpc.BlockWithHeight) => void;

                type GetBlockRangeCallback = (error: (Error|null), response?: waves.node.grpc.BlockWithHeight) => void;

                type GetCurrentHeightCallback = (error: (Error|null), response?: google.protobuf.UInt32Value) => void;
            }

            interface IBlockRequest {
                blockId?: (Uint8Array|null);
                height?: (number|null);
                includeTransactions?: (boolean|null);
            }

            class BlockRequest implements IBlockRequest {
                constructor(p?: waves.node.grpc.IBlockRequest);
                public blockId: Uint8Array;
                public height: number;
                public includeTransactions: boolean;
                public request?: ("blockId"|"height");
                public static encode(m: waves.node.grpc.IBlockRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.BlockRequest;
            }

            interface IBlockRangeRequest {
                fromHeight?: (number|null);
                toHeight?: (number|null);
                generatorPublicKey?: (Uint8Array|null);
                generatorAddress?: (Uint8Array|null);
                includeTransactions?: (boolean|null);
            }

            class BlockRangeRequest implements IBlockRangeRequest {
                constructor(p?: waves.node.grpc.IBlockRangeRequest);
                public fromHeight: number;
                public toHeight: number;
                public generatorPublicKey: Uint8Array;
                public generatorAddress: Uint8Array;
                public includeTransactions: boolean;
                public filter?: ("generatorPublicKey"|"generatorAddress");
                public static encode(m: waves.node.grpc.IBlockRangeRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.BlockRangeRequest;
            }

            interface IBlockWithHeight {
                block?: (waves.IBlock|null);
                height?: (number|null);
            }

            class BlockWithHeight implements IBlockWithHeight {
                constructor(p?: waves.node.grpc.IBlockWithHeight);
                public block?: (waves.IBlock|null);
                public height: number;
                public static encode(m: waves.node.grpc.IBlockWithHeight, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.BlockWithHeight;
            }

            class TransactionsApi extends $protobuf.rpc.Service {
                constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);
                public getTransactions(request: waves.node.grpc.ITransactionsRequest, callback: waves.node.grpc.TransactionsApi.GetTransactionsCallback): void;
                public getTransactions(request: waves.node.grpc.ITransactionsRequest): Promise<waves.node.grpc.TransactionResponse>;
                public getStateChanges(request: waves.node.grpc.ITransactionsRequest, callback: waves.node.grpc.TransactionsApi.GetStateChangesCallback): void;
                public getStateChanges(request: waves.node.grpc.ITransactionsRequest): Promise<waves.node.grpc.InvokeScriptResultResponse>;
                public getStatuses(request: waves.node.grpc.ITransactionsByIdRequest, callback: waves.node.grpc.TransactionsApi.GetStatusesCallback): void;
                public getStatuses(request: waves.node.grpc.ITransactionsByIdRequest): Promise<waves.node.grpc.TransactionStatus>;
                public getUnconfirmed(request: waves.node.grpc.ITransactionsRequest, callback: waves.node.grpc.TransactionsApi.GetUnconfirmedCallback): void;
                public getUnconfirmed(request: waves.node.grpc.ITransactionsRequest): Promise<waves.node.grpc.TransactionResponse>;
                public sign(request: waves.node.grpc.ISignRequest, callback: waves.node.grpc.TransactionsApi.SignCallback): void;
                public sign(request: waves.node.grpc.ISignRequest): Promise<waves.SignedTransaction>;
                public broadcast(request: waves.ISignedTransaction, callback: waves.node.grpc.TransactionsApi.BroadcastCallback): void;
                public broadcast(request: waves.ISignedTransaction): Promise<waves.SignedTransaction>;
            }

            namespace TransactionsApi {

                type GetTransactionsCallback = (error: (Error|null), response?: waves.node.grpc.TransactionResponse) => void;

                type GetStateChangesCallback = (error: (Error|null), response?: waves.node.grpc.InvokeScriptResultResponse) => void;

                type GetStatusesCallback = (error: (Error|null), response?: waves.node.grpc.TransactionStatus) => void;

                type GetUnconfirmedCallback = (error: (Error|null), response?: waves.node.grpc.TransactionResponse) => void;

                type SignCallback = (error: (Error|null), response?: waves.SignedTransaction) => void;

                type BroadcastCallback = (error: (Error|null), response?: waves.SignedTransaction) => void;
            }

            enum ApplicationStatus {
                UNKNOWN = 0,
                SUCCEEDED = 1,
                SCRIPT_EXECUTION_FAILED = 2,
                SCRIPT_EXECUTION_IN_PROGRESS = 3
            }

            interface ITransactionStatus {
                id?: (Uint8Array|null);
                status?: (waves.node.grpc.TransactionStatus.Status|null);
                height?: (Long|null);
                applicationStatus?: (waves.node.grpc.ApplicationStatus|null);
            }

            class TransactionStatus implements ITransactionStatus {
                constructor(p?: waves.node.grpc.ITransactionStatus);
                public id: Uint8Array;
                public status: waves.node.grpc.TransactionStatus.Status;
                public height: Long;
                public applicationStatus: waves.node.grpc.ApplicationStatus;
                public static encode(m: waves.node.grpc.ITransactionStatus, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.TransactionStatus;
            }

            namespace TransactionStatus {

                enum Status {
                    NOT_EXISTS = 0,
                    UNCONFIRMED = 1,
                    CONFIRMED = 2
                }
            }

            interface ITransactionResponse {
                id?: (Uint8Array|null);
                height?: (Long|null);
                transaction?: (waves.ISignedTransaction|null);
                applicationStatus?: (waves.node.grpc.ApplicationStatus|null);
                invokeScriptResult?: (waves.IInvokeScriptResult|null);
            }

            class TransactionResponse implements ITransactionResponse {
                constructor(p?: waves.node.grpc.ITransactionResponse);
                public id: Uint8Array;
                public height: Long;
                public transaction?: (waves.ISignedTransaction|null);
                public applicationStatus: waves.node.grpc.ApplicationStatus;
                public invokeScriptResult?: (waves.IInvokeScriptResult|null);
                public static encode(m: waves.node.grpc.ITransactionResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.TransactionResponse;
            }

            interface ITransactionsRequest {
                sender?: (Uint8Array|null);
                recipient?: (waves.IRecipient|null);
                transactionIds?: (Uint8Array[]|null);
            }

            class TransactionsRequest implements ITransactionsRequest {
                constructor(p?: waves.node.grpc.ITransactionsRequest);
                public sender: Uint8Array;
                public recipient?: (waves.IRecipient|null);
                public transactionIds: Uint8Array[];
                public static encode(m: waves.node.grpc.ITransactionsRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.TransactionsRequest;
            }

            interface ITransactionsByIdRequest {
                transactionIds?: (Uint8Array[]|null);
            }

            class TransactionsByIdRequest implements ITransactionsByIdRequest {
                constructor(p?: waves.node.grpc.ITransactionsByIdRequest);
                public transactionIds: Uint8Array[];
                public static encode(m: waves.node.grpc.ITransactionsByIdRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.TransactionsByIdRequest;
            }

            interface ICalculateFeeResponse {
                assetId?: (Uint8Array|null);
                amount?: (Long|null);
            }

            class CalculateFeeResponse implements ICalculateFeeResponse {
                constructor(p?: waves.node.grpc.ICalculateFeeResponse);
                public assetId: Uint8Array;
                public amount: Long;
                public static encode(m: waves.node.grpc.ICalculateFeeResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.CalculateFeeResponse;
            }

            interface ISignRequest {
                transaction?: (waves.ITransaction|null);
                signerPublicKey?: (Uint8Array|null);
            }

            class SignRequest implements ISignRequest {
                constructor(p?: waves.node.grpc.ISignRequest);
                public transaction?: (waves.ITransaction|null);
                public signerPublicKey: Uint8Array;
                public static encode(m: waves.node.grpc.ISignRequest, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.SignRequest;
            }

            interface IInvokeScriptResultResponse {
                transaction?: (waves.ISignedTransaction|null);
                result?: (waves.IInvokeScriptResult|null);
            }

            class InvokeScriptResultResponse implements IInvokeScriptResultResponse {
                constructor(p?: waves.node.grpc.IInvokeScriptResultResponse);
                public transaction?: (waves.ISignedTransaction|null);
                public result?: (waves.IInvokeScriptResult|null);
                public static encode(m: waves.node.grpc.IInvokeScriptResultResponse, w?: $protobuf.Writer): $protobuf.Writer;
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.node.grpc.InvokeScriptResultResponse;
            }
        }
    }

    interface IAssetPair {
        amountAssetId?: (Uint8Array|null);
        priceAssetId?: (Uint8Array|null);
    }

    class AssetPair implements IAssetPair {
        constructor(p?: waves.IAssetPair);
        public amountAssetId: Uint8Array;
        public priceAssetId: Uint8Array;
        public static encode(m: waves.IAssetPair, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.AssetPair;
    }

    interface IOrder {
        chainId?: (number|null);
        senderPublicKey?: (Uint8Array|null);
        matcherPublicKey?: (Uint8Array|null);
        assetPair?: (waves.IAssetPair|null);
        orderSide?: (waves.Order.Side|null);
        amount?: (Long|null);
        price?: (Long|null);
        timestamp?: (Long|null);
        expiration?: (Long|null);
        matcherFee?: (waves.IAmount|null);
        version?: (number|null);
        proofs?: (Uint8Array[]|null);
    }

    class Order implements IOrder {
        constructor(p?: waves.IOrder);
        public chainId: number;
        public senderPublicKey: Uint8Array;
        public matcherPublicKey: Uint8Array;
        public assetPair?: (waves.IAssetPair|null);
        public orderSide: waves.Order.Side;
        public amount: Long;
        public price: Long;
        public timestamp: Long;
        public expiration: Long;
        public matcherFee?: (waves.IAmount|null);
        public version: number;
        public proofs: Uint8Array[];
        public static encode(m: waves.IOrder, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.Order;
    }

    namespace Order {

        enum Side {
            BUY = 0,
            SELL = 1
        }
    }

    interface IRecipient {
        publicKeyHash?: (Uint8Array|null);
        alias?: (string|null);
    }

    class Recipient implements IRecipient {
        constructor(p?: waves.IRecipient);
        public publicKeyHash: Uint8Array;
        public alias: string;
        public recipient?: ("publicKeyHash"|"alias");
        public static encode(m: waves.IRecipient, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.Recipient;
    }

    interface ISignedTransaction {
        transaction?: (waves.ITransaction|null);
        proofs?: (Uint8Array[]|null);
    }

    class SignedTransaction implements ISignedTransaction {
        constructor(p?: waves.ISignedTransaction);
        public transaction?: (waves.ITransaction|null);
        public proofs: Uint8Array[];
        public static encode(m: waves.ISignedTransaction, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.SignedTransaction;
    }

    interface ITransaction {
        chainId?: (number|null);
        senderPublicKey?: (Uint8Array|null);
        fee?: (waves.IAmount|null);
        timestamp?: (Long|null);
        version?: (number|null);
        genesis?: (waves.IGenesisTransactionData|null);
        payment?: (waves.IPaymentTransactionData|null);
        issue?: (waves.IIssueTransactionData|null);
        transfer?: (waves.ITransferTransactionData|null);
        reissue?: (waves.IReissueTransactionData|null);
        burn?: (waves.IBurnTransactionData|null);
        exchange?: (waves.IExchangeTransactionData|null);
        lease?: (waves.ILeaseTransactionData|null);
        leaseCancel?: (waves.ILeaseCancelTransactionData|null);
        createAlias?: (waves.ICreateAliasTransactionData|null);
        massTransfer?: (waves.IMassTransferTransactionData|null);
        dataTransaction?: (waves.IDataTransactionData|null);
        setScript?: (waves.ISetScriptTransactionData|null);
        sponsorFee?: (waves.ISponsorFeeTransactionData|null);
        setAssetScript?: (waves.ISetAssetScriptTransactionData|null);
        invokeScript?: (waves.IInvokeScriptTransactionData|null);
        updateAssetInfo?: (waves.IUpdateAssetInfoTransactionData|null);
        continuation?: (waves.IContinuationTransactionData|null);
    }

    class Transaction implements ITransaction {
        constructor(p?: waves.ITransaction);
        public chainId: number;
        public senderPublicKey: Uint8Array;
        public fee?: (waves.IAmount|null);
        public timestamp: Long;
        public version: number;
        public genesis?: (waves.IGenesisTransactionData|null);
        public payment?: (waves.IPaymentTransactionData|null);
        public issue?: (waves.IIssueTransactionData|null);
        public transfer?: (waves.ITransferTransactionData|null);
        public reissue?: (waves.IReissueTransactionData|null);
        public burn?: (waves.IBurnTransactionData|null);
        public exchange?: (waves.IExchangeTransactionData|null);
        public lease?: (waves.ILeaseTransactionData|null);
        public leaseCancel?: (waves.ILeaseCancelTransactionData|null);
        public createAlias?: (waves.ICreateAliasTransactionData|null);
        public massTransfer?: (waves.IMassTransferTransactionData|null);
        public dataTransaction?: (waves.IDataTransactionData|null);
        public setScript?: (waves.ISetScriptTransactionData|null);
        public sponsorFee?: (waves.ISponsorFeeTransactionData|null);
        public setAssetScript?: (waves.ISetAssetScriptTransactionData|null);
        public invokeScript?: (waves.IInvokeScriptTransactionData|null);
        public updateAssetInfo?: (waves.IUpdateAssetInfoTransactionData|null);
        public continuation?: (waves.IContinuationTransactionData|null);
        public data?: ("genesis"|"payment"|"issue"|"transfer"|"reissue"|"burn"|"exchange"|"lease"|"leaseCancel"|"createAlias"|"massTransfer"|"dataTransaction"|"setScript"|"sponsorFee"|"setAssetScript"|"invokeScript"|"updateAssetInfo"|"continuation");
        public static encode(m: waves.ITransaction, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.Transaction;
    }

    interface IGenesisTransactionData {
        recipientAddress?: (Uint8Array|null);
        amount?: (Long|null);
    }

    class GenesisTransactionData implements IGenesisTransactionData {
        constructor(p?: waves.IGenesisTransactionData);
        public recipientAddress: Uint8Array;
        public amount: Long;
        public static encode(m: waves.IGenesisTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.GenesisTransactionData;
    }

    interface IPaymentTransactionData {
        recipientAddress?: (Uint8Array|null);
        amount?: (Long|null);
    }

    class PaymentTransactionData implements IPaymentTransactionData {
        constructor(p?: waves.IPaymentTransactionData);
        public recipientAddress: Uint8Array;
        public amount: Long;
        public static encode(m: waves.IPaymentTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.PaymentTransactionData;
    }

    interface ITransferTransactionData {
        recipient?: (waves.IRecipient|null);
        amount?: (waves.IAmount|null);
        attachment?: (Uint8Array|null);
    }

    class TransferTransactionData implements ITransferTransactionData {
        constructor(p?: waves.ITransferTransactionData);
        public recipient?: (waves.IRecipient|null);
        public amount?: (waves.IAmount|null);
        public attachment: Uint8Array;
        public static encode(m: waves.ITransferTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.TransferTransactionData;
    }

    interface ICreateAliasTransactionData {
        alias?: (string|null);
    }

    class CreateAliasTransactionData implements ICreateAliasTransactionData {
        constructor(p?: waves.ICreateAliasTransactionData);
        public alias: string;
        public static encode(m: waves.ICreateAliasTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.CreateAliasTransactionData;
    }

    interface IDataTransactionData {
        data?: (waves.DataTransactionData.IDataEntry[]|null);
    }

    class DataTransactionData implements IDataTransactionData {
        constructor(p?: waves.IDataTransactionData);
        public data: waves.DataTransactionData.IDataEntry[];
        public static encode(m: waves.IDataTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.DataTransactionData;
    }

    namespace DataTransactionData {

        interface IDataEntry {
            key?: (string|null);
            intValue?: (Long|null);
            boolValue?: (boolean|null);
            binaryValue?: (Uint8Array|null);
            stringValue?: (string|null);
        }

        class DataEntry implements IDataEntry {
            constructor(p?: waves.DataTransactionData.IDataEntry);
            public key: string;
            public intValue: Long;
            public boolValue: boolean;
            public binaryValue: Uint8Array;
            public stringValue: string;
            public value?: ("intValue"|"boolValue"|"binaryValue"|"stringValue");
            public static encode(m: waves.DataTransactionData.IDataEntry, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.DataTransactionData.DataEntry;
        }
    }

    interface IMassTransferTransactionData {
        assetId?: (Uint8Array|null);
        transfers?: (waves.MassTransferTransactionData.ITransfer[]|null);
        attachment?: (Uint8Array|null);
    }

    class MassTransferTransactionData implements IMassTransferTransactionData {
        constructor(p?: waves.IMassTransferTransactionData);
        public assetId: Uint8Array;
        public transfers: waves.MassTransferTransactionData.ITransfer[];
        public attachment: Uint8Array;
        public static encode(m: waves.IMassTransferTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.MassTransferTransactionData;
    }

    namespace MassTransferTransactionData {

        interface ITransfer {
            recipient?: (waves.IRecipient|null);
            amount?: (Long|null);
        }

        class Transfer implements ITransfer {
            constructor(p?: waves.MassTransferTransactionData.ITransfer);
            public recipient?: (waves.IRecipient|null);
            public amount: Long;
            public static encode(m: waves.MassTransferTransactionData.ITransfer, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.MassTransferTransactionData.Transfer;
        }
    }

    interface ILeaseTransactionData {
        recipient?: (waves.IRecipient|null);
        amount?: (Long|null);
    }

    class LeaseTransactionData implements ILeaseTransactionData {
        constructor(p?: waves.ILeaseTransactionData);
        public recipient?: (waves.IRecipient|null);
        public amount: Long;
        public static encode(m: waves.ILeaseTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.LeaseTransactionData;
    }

    interface ILeaseCancelTransactionData {
        leaseId?: (Uint8Array|null);
    }

    class LeaseCancelTransactionData implements ILeaseCancelTransactionData {
        constructor(p?: waves.ILeaseCancelTransactionData);
        public leaseId: Uint8Array;
        public static encode(m: waves.ILeaseCancelTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.LeaseCancelTransactionData;
    }

    interface IBurnTransactionData {
        assetAmount?: (waves.IAmount|null);
    }

    class BurnTransactionData implements IBurnTransactionData {
        constructor(p?: waves.IBurnTransactionData);
        public assetAmount?: (waves.IAmount|null);
        public static encode(m: waves.IBurnTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.BurnTransactionData;
    }

    interface IIssueTransactionData {
        name?: (string|null);
        description?: (string|null);
        amount?: (Long|null);
        decimals?: (number|null);
        reissuable?: (boolean|null);
        script?: (Uint8Array|null);
    }

    class IssueTransactionData implements IIssueTransactionData {
        constructor(p?: waves.IIssueTransactionData);
        public name: string;
        public description: string;
        public amount: Long;
        public decimals: number;
        public reissuable: boolean;
        public script: Uint8Array;
        public static encode(m: waves.IIssueTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.IssueTransactionData;
    }

    interface IReissueTransactionData {
        assetAmount?: (waves.IAmount|null);
        reissuable?: (boolean|null);
    }

    class ReissueTransactionData implements IReissueTransactionData {
        constructor(p?: waves.IReissueTransactionData);
        public assetAmount?: (waves.IAmount|null);
        public reissuable: boolean;
        public static encode(m: waves.IReissueTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.ReissueTransactionData;
    }

    interface ISetAssetScriptTransactionData {
        assetId?: (Uint8Array|null);
        script?: (Uint8Array|null);
    }

    class SetAssetScriptTransactionData implements ISetAssetScriptTransactionData {
        constructor(p?: waves.ISetAssetScriptTransactionData);
        public assetId: Uint8Array;
        public script: Uint8Array;
        public static encode(m: waves.ISetAssetScriptTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.SetAssetScriptTransactionData;
    }

    interface ISetScriptTransactionData {
        script?: (Uint8Array|null);
    }

    class SetScriptTransactionData implements ISetScriptTransactionData {
        constructor(p?: waves.ISetScriptTransactionData);
        public script: Uint8Array;
        public static encode(m: waves.ISetScriptTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.SetScriptTransactionData;
    }

    interface IExchangeTransactionData {
        amount?: (Long|null);
        price?: (Long|null);
        buyMatcherFee?: (Long|null);
        sellMatcherFee?: (Long|null);
        orders?: (waves.IOrder[]|null);
    }

    class ExchangeTransactionData implements IExchangeTransactionData {
        constructor(p?: waves.IExchangeTransactionData);
        public amount: Long;
        public price: Long;
        public buyMatcherFee: Long;
        public sellMatcherFee: Long;
        public orders: waves.IOrder[];
        public static encode(m: waves.IExchangeTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.ExchangeTransactionData;
    }

    interface ISponsorFeeTransactionData {
        minFee?: (waves.IAmount|null);
    }

    class SponsorFeeTransactionData implements ISponsorFeeTransactionData {
        constructor(p?: waves.ISponsorFeeTransactionData);
        public minFee?: (waves.IAmount|null);
        public static encode(m: waves.ISponsorFeeTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.SponsorFeeTransactionData;
    }

    interface IInvokeScriptTransactionData {
        dApp?: (waves.IRecipient|null);
        functionCall?: (Uint8Array|null);
        payments?: (waves.IAmount[]|null);
        extraFeePerStep?: (Long|null);
    }

    class InvokeScriptTransactionData implements IInvokeScriptTransactionData {
        constructor(p?: waves.IInvokeScriptTransactionData);
        public dApp?: (waves.IRecipient|null);
        public functionCall: Uint8Array;
        public payments: waves.IAmount[];
        public extraFeePerStep: Long;
        public static encode(m: waves.IInvokeScriptTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.InvokeScriptTransactionData;
    }

    interface IUpdateAssetInfoTransactionData {
        assetId?: (Uint8Array|null);
        name?: (string|null);
        description?: (string|null);
    }

    class UpdateAssetInfoTransactionData implements IUpdateAssetInfoTransactionData {
        constructor(p?: waves.IUpdateAssetInfoTransactionData);
        public assetId: Uint8Array;
        public name: string;
        public description: string;
        public static encode(m: waves.IUpdateAssetInfoTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.UpdateAssetInfoTransactionData;
    }

    interface IContinuationTransactionData {
        invokeScriptTransactionId?: (Uint8Array|null);
        nonce?: (number|null);
    }

    class ContinuationTransactionData implements IContinuationTransactionData {
        constructor(p?: waves.IContinuationTransactionData);
        public invokeScriptTransactionId: Uint8Array;
        public nonce: number;
        public static encode(m: waves.IContinuationTransactionData, w?: $protobuf.Writer): $protobuf.Writer;
        public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): waves.ContinuationTransactionData;
    }
}

export namespace google {

    namespace protobuf {

        interface IDoubleValue {
            value?: (number|null);
        }

        class DoubleValue implements IDoubleValue {
            constructor(p?: google.protobuf.IDoubleValue);
            public value: number;
            public static encode(m: google.protobuf.IDoubleValue, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.DoubleValue;
        }

        interface IFloatValue {
            value?: (number|null);
        }

        class FloatValue implements IFloatValue {
            constructor(p?: google.protobuf.IFloatValue);
            public value: number;
            public static encode(m: google.protobuf.IFloatValue, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.FloatValue;
        }

        interface IInt64Value {
            value?: (Long|null);
        }

        class Int64Value implements IInt64Value {
            constructor(p?: google.protobuf.IInt64Value);
            public value: Long;
            public static encode(m: google.protobuf.IInt64Value, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.Int64Value;
        }

        interface IUInt64Value {
            value?: (Long|null);
        }

        class UInt64Value implements IUInt64Value {
            constructor(p?: google.protobuf.IUInt64Value);
            public value: Long;
            public static encode(m: google.protobuf.IUInt64Value, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.UInt64Value;
        }

        interface IInt32Value {
            value?: (number|null);
        }

        class Int32Value implements IInt32Value {
            constructor(p?: google.protobuf.IInt32Value);
            public value: number;
            public static encode(m: google.protobuf.IInt32Value, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.Int32Value;
        }

        interface IUInt32Value {
            value?: (number|null);
        }

        class UInt32Value implements IUInt32Value {
            constructor(p?: google.protobuf.IUInt32Value);
            public value: number;
            public static encode(m: google.protobuf.IUInt32Value, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.UInt32Value;
        }

        interface IBoolValue {
            value?: (boolean|null);
        }

        class BoolValue implements IBoolValue {
            constructor(p?: google.protobuf.IBoolValue);
            public value: boolean;
            public static encode(m: google.protobuf.IBoolValue, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.BoolValue;
        }

        interface IStringValue {
            value?: (string|null);
        }

        class StringValue implements IStringValue {
            constructor(p?: google.protobuf.IStringValue);
            public value: string;
            public static encode(m: google.protobuf.IStringValue, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.StringValue;
        }

        interface IBytesValue {
            value?: (Uint8Array|null);
        }

        class BytesValue implements IBytesValue {
            constructor(p?: google.protobuf.IBytesValue);
            public value: Uint8Array;
            public static encode(m: google.protobuf.IBytesValue, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.BytesValue;
        }

        interface IEmpty {
        }

        class Empty implements IEmpty {
            constructor(p?: google.protobuf.IEmpty);
            public static encode(m: google.protobuf.IEmpty, w?: $protobuf.Writer): $protobuf.Writer;
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.Empty;
        }
    }
}
