"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dataEntryToProto = exports.txToProto = exports.protoBytesToOrder = exports.orderToProtoBytes = exports.protoBytesToTx = exports.txToProtoBytes = void 0;
const wavesProto = __importStar(require("@waves/protobuf-serialization"));
const ts_lib_crypto_1 = require("@waves/ts-lib-crypto");
const marshall_1 = require("@waves/marshall");
const transactions_1 = require("./transactions");
const generic_1 = require("./generic");
const long_1 = __importDefault(require("long"));
const invokeScriptCallSchema = Object.assign(Object.assign({}, marshall_1.schemas.txFields.functionCall[1]), { withLength: {
        toBytes: marshall_1.serializePrimitives.SHORT,
        fromBytes: marshall_1.parsePrimitives.P_SHORT,
    } });
const recipientFromProto = (recipient, chainId) => {
    if (recipient.alias) {
        return `alias:${String.fromCharCode(chainId)}:${recipient.alias}`;
    }
    const rawAddress = ts_lib_crypto_1.concat([1], [chainId], recipient.publicKeyHash);
    const checkSum = ts_lib_crypto_1.keccak(ts_lib_crypto_1.blake2b(rawAddress)).slice(0, 4);
    return ts_lib_crypto_1.base58Encode(ts_lib_crypto_1.concat(rawAddress, checkSum));
};
function txToProtoBytes(obj) {
    return new Uint8Array(wavesProto.waves.Transaction.encode(exports.txToProto(obj)).finish());
}
exports.txToProtoBytes = txToProtoBytes;
function protoBytesToTx(bytes) {
    const t = wavesProto.waves.Transaction.decode(bytes);
    let res = {
        version: t.version,
        type: typeByName[t.data],
        senderPublicKey: ts_lib_crypto_1.base58Encode(t.senderPublicKey),
        timestamp: t.timestamp.toNumber(),
        fee: t.fee.amount.toNumber(),
    };
    if (t.fee.hasOwnProperty('assetId')) {
        res.feeAssetId = ts_lib_crypto_1.base58Encode(t.fee.assetId);
    }
    if (t.hasOwnProperty('chainId')) {
        res.chainId = t.chainId;
    }
    switch (t.data) {
        case 'issue':
            res.name = t.issue.name;
            res.description = t.issue.description;
            res.quantity = t.issue.amount.toString();
            res.decimals = t.issue.decimals;
            res.reissuable = t.issue.reissuable;
            if (t.issue.hasOwnProperty('script')) {
                res.script = t.issue.script && generic_1.base64Prefix(ts_lib_crypto_1.base64Encode(t.issue.script));
            }
            break;
        case 'transfer':
            res.amount = t.transfer.amount.amount.toString();
            res.recipient = recipientFromProto(t.transfer.recipient, t.chainId);
            if (t.transfer.hasOwnProperty('attachment')) {
                res.attachment = t.transfer.attachment == null ? null : ts_lib_crypto_1.base58Encode(t.transfer.attachment);
            }
            if (t.transfer.hasOwnProperty('assetId')) {
                res.assetId = t.transfer.amount.assetId == null ? null : ts_lib_crypto_1.base58Encode(t.transfer.amount.assetId);
            }
            break;
        case 'reissue':
            res.quantity = t.reissue.assetAmount.amount.toString();
            res.assetId = t.reissue.assetAmount.assetId == null ? null : ts_lib_crypto_1.base58Encode(t.reissue.assetAmount.assetId);
            res.reissuable = t.reissue.reissuable;
            break;
        case 'burn':
            res.quantity = t.burn.assetAmount.amount.toString();
            res.assetId = ts_lib_crypto_1.base58Encode(t.burn.assetAmount.assetId);
            break;
        case 'exchange':
            res.amount = t.exchange.amount.toString();
            res.price = t.exchange.price.toString();
            res.buyMatcherFee = t.exchange.buyMatcherFee.toString();
            res.sellMatcherFee = t.exchange.sellMatcherFee.toString();
            res.order1 = orderFromProto(t.exchange.orders[0]);
            res.order2 = orderFromProto(t.exchange.orders[1]);
            break;
        case 'lease':
            res.recipient = recipientFromProto(t.lease.recipient, t.chainId);
            res.amount = t.lease.amount.toString();
            break;
        case 'leaseCancel':
            res.leaseId = ts_lib_crypto_1.base58Encode(t.leaseCancel.leaseId);
            break;
        case 'createAlias':
            res.alias = t.createAlias.alias;
            break;
        case 'massTransfer':
            if (t.massTransfer.hasOwnProperty('assetId')) {
                res.assetId = t.massTransfer.assetId == null ? null : ts_lib_crypto_1.base58Encode(t.massTransfer.assetId);
            }
            if (t.massTransfer.hasOwnProperty('attachment')) {
                res.attachment = t.massTransfer.attachment == null ? null : ts_lib_crypto_1.base58Encode(t.massTransfer.attachment);
            }
            res.transfers = t.massTransfer.transfers.map(({ amount, recipient }) => ({
                amount: amount.toString(),
                recipient: recipientFromProto(recipient, t.chainId),
            }));
            break;
        case 'dataTransaction':
            res.data = t.dataTransaction.data.map(de => {
                if (de.hasOwnProperty('binaryValue'))
                    return {
                        key: de.key,
                        type: 'binary',
                        value: generic_1.base64Prefix(ts_lib_crypto_1.base64Encode(de.binaryValue)),
                    };
                if (de.hasOwnProperty('boolValue'))
                    return { key: de.key, type: 'boolean', value: de.boolValue };
                if (de.hasOwnProperty('intValue'))
                    return { key: de.key, type: 'integer', value: de.intValue.toString() };
                if (de.hasOwnProperty('stringValue'))
                    return { key: de.key, type: 'string', value: de.stringValue };
                return { key: de.key };
            });
            break;
        case 'setScript':
            res.script = t.setScript.script == null ? null : generic_1.base64Prefix(ts_lib_crypto_1.base64Encode(t.setScript.script));
            break;
        case 'sponsorFee':
            res.minSponsoredAssetFee = t.sponsorFee.minFee.amount.toString();
            res.assetId = ts_lib_crypto_1.base58Encode(t.sponsorFee.minFee.assetId);
            break;
        case 'setAssetScript':
            res.assetId = ts_lib_crypto_1.base58Encode(t.setAssetScript.assetId);
            res.script = generic_1.base64Prefix(ts_lib_crypto_1.base64Encode(t.setAssetScript.script));
            break;
        case 'invokeScript':
            res.dApp = recipientFromProto(t.invokeScript.dApp, t.chainId);
            if (t.invokeScript.functionCall != null) {
                res.call = marshall_1.binary.parserFromSchema(invokeScriptCallSchema)(t.invokeScript.functionCall).value; //todo: export function call from marshall and use it directly
            }
            res.payment = t.invokeScript.payments.map(p => ({
                amount: p.amount.toString(),
                assetId: p.assetId == null ? null : ts_lib_crypto_1.base58Encode(p.assetId),
            }));
            break;
        case 'updateAssetInfo':
            res.assetId = ts_lib_crypto_1.base58Encode(t.updateAssetInfo.assetId);
            res.name = t.updateAssetInfo.name;
            res.description = t.updateAssetInfo.description;
            break;
        default:
            throw new Error(`Unsupported tx type ${t.data}`);
    }
    return res;
}
exports.protoBytesToTx = protoBytesToTx;
function orderToProtoBytes(obj) {
    return wavesProto.waves.Order.encode(orderToProto(obj)).finish();
}
exports.orderToProtoBytes = orderToProtoBytes;
function protoBytesToOrder(bytes) {
    const o = wavesProto.waves.Order.decode(bytes);
    return orderFromProto(o);
}
exports.protoBytesToOrder = protoBytesToOrder;
const getCommonFields = (_a) => {
    var { senderPublicKey, fee, timestamp, type, version } = _a, rest = __rest(_a, ["senderPublicKey", "fee", "timestamp", "type", "version"]);
    const typename = nameByType[type];
    let chainId = rest.chainId;
    if (chainId == null) {
        const r = rest;
        let recipient = r.recipient || r.dApp || (r.transfers && r.transfers[0] && r.transfers[0].recipient);
        if (recipient) {
            chainId = generic_1.chainIdFromRecipient(recipient);
        }
    }
    return {
        version,
        type,
        chainId,
        senderPublicKey: ts_lib_crypto_1.base58Decode(senderPublicKey),
        timestamp: long_1.default.fromValue(timestamp),
        fee: amountToProto(fee, rest.feeAssetId),
        data: typename,
    };
};
const getIssueData = (t) => ({
    name: t.name,
    description: t.description === '' ? null : t.description,
    amount: long_1.default.fromValue(t.quantity),
    decimals: t.decimals === 0 ? null : t.decimals,
    reissuable: t.reissuable ? true : undefined,
    script: t.script == null ? null : scriptToProto(t.script),
});
const getTransferData = (t) => ({
    recipient: recipientToProto(t.recipient),
    amount: amountToProto(t.amount, t.assetId),
    attachment: t.attachment == null || t.attachment == '' ? undefined : ts_lib_crypto_1.base58Decode(t.attachment),
});
const getReissueData = (t) => ({
    assetAmount: amountToProto(t.quantity, t.assetId),
    reissuable: t.reissuable ? true : undefined,
});
const getBurnData = (t) => ({
    assetAmount: amountToProto(t.amount || t.amount, t.assetId),
});
const getExchangeData = (t) => ({
    amount: long_1.default.fromValue(t.amount),
    price: long_1.default.fromValue(t.price),
    buyMatcherFee: long_1.default.fromValue(t.buyMatcherFee),
    sellMatcherFee: long_1.default.fromValue(t.sellMatcherFee),
    orders: [orderToProto(Object.assign({ chainId: t.chainId }, t.order1)), orderToProto(Object.assign({ chainId: t.chainId }, t.order2))],
});
const getLeaseData = (t) => ({
    recipient: recipientToProto(t.recipient),
    amount: long_1.default.fromValue(t.amount),
});
const getCancelLeaseData = (t) => ({
    leaseId: ts_lib_crypto_1.base58Decode(t.leaseId),
});
const getAliasData = (t) => ({ alias: t.alias });
const getMassTransferData = (t) => ({
    assetId: t.assetId == null ? null : ts_lib_crypto_1.base58Decode(t.assetId),
    attachment: t.attachment == null || t.attachment == '' ? undefined : ts_lib_crypto_1.base58Decode(t.attachment),
    transfers: t.transfers.map(massTransferItemToProto),
});
const getDataTxData = (t) => ({
    data: t.data.map(exports.dataEntryToProto),
});
const getSetScriptData = (t) => ({
    script: t.script == null ? null : scriptToProto(t.script),
});
const getSponsorData = (t) => ({
    minFee: amountToProto(t.minSponsoredAssetFee, t.assetId),
});
const getSetAssetScriptData = (t) => ({
    assetId: ts_lib_crypto_1.base58Decode(t.assetId),
    script: t.script == null ? null : scriptToProto(t.script),
});
const getInvokeData = (t) => ({
    dApp: recipientToProto(t.dApp),
    functionCall: marshall_1.binary.serializerFromSchema(marshall_1.schemas.invokeScriptSchemaV1.schema[5][1])(t.call),
    payments: t.payment == null ? null : t.payment.map(({ amount, assetId }) => amountToProto(amount, assetId)),
});
const getUpdateAssetInfoData = (t) => {
    return {
        assetId: ts_lib_crypto_1.base58Decode(t.assetId),
        name: t.name,
        description: t.description,
    };
};
exports.txToProto = (t) => {
    const common = getCommonFields(t);
    let txData;
    switch (t.type) {
        case transactions_1.TRANSACTION_TYPE.ISSUE:
            txData = getIssueData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.TRANSFER:
            txData = getTransferData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.REISSUE:
            txData = getReissueData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.BURN:
            txData = getBurnData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.LEASE:
            txData = getLeaseData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.CANCEL_LEASE:
            txData = getCancelLeaseData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.ALIAS:
            txData = getAliasData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.MASS_TRANSFER:
            txData = getMassTransferData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.DATA:
            txData = getDataTxData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.SET_SCRIPT:
            txData = getSetScriptData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.SET_ASSET_SCRIPT:
            txData = getSetAssetScriptData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.SPONSORSHIP:
            txData = getSponsorData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.EXCHANGE:
            txData = getExchangeData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.INVOKE_SCRIPT:
            txData = getInvokeData(t);
            break;
        case transactions_1.TRANSACTION_TYPE.UPDATE_ASSET_INFO:
            txData = getUpdateAssetInfoData(t);
            break;
    }
    return Object.assign(Object.assign({}, common), { [common.data]: txData });
};
const orderToProto = (o) => ({
    chainId: o.chainId,
    senderPublicKey: ts_lib_crypto_1.base58Decode(o.senderPublicKey),
    matcherPublicKey: ts_lib_crypto_1.base58Decode(o.matcherPublicKey),
    assetPair: {
        amountAssetId: o.assetPair.amountAsset == null ? null : ts_lib_crypto_1.base58Decode(o.assetPair.amountAsset),
        priceAssetId: o.assetPair.priceAsset == null ? null : ts_lib_crypto_1.base58Decode(o.assetPair.priceAsset),
    },
    orderSide: o.orderType === 'buy' ? undefined : wavesProto.waves.Order.Side.SELL,
    amount: long_1.default.fromValue(o.amount),
    price: long_1.default.fromValue(o.price),
    timestamp: long_1.default.fromValue(o.timestamp),
    expiration: long_1.default.fromValue(o.expiration),
    matcherFee: amountToProto(o.matcherFee, null),
    version: o.version,
    proofs: o.proofs.map(ts_lib_crypto_1.base58Decode),
});
const orderFromProto = (po) => ({
    version: po.version,
    senderPublicKey: ts_lib_crypto_1.base58Encode(po.senderPublicKey),
    matcherPublicKey: ts_lib_crypto_1.base58Encode(po.matcherPublicKey),
    assetPair: {
        amountAsset: po.assetPair.amountAssetId == null ? null : ts_lib_crypto_1.base58Encode(po.assetPair.amountAssetId),
        priceAsset: po.assetPair.priceAssetId == null ? null : ts_lib_crypto_1.base58Encode(po.assetPair.priceAssetId),
    },
    // @ts-ignore
    chainId: po.chainId,
    orderType: po.orderSide === wavesProto.waves.Order.Side.BUY ? 'buy' : 'sell',
    amount: po.amount.toString(),
    price: po.price.toString(),
    timestamp: po.timestamp.toNumber(),
    expiration: po.expiration.toNumber(),
    matcherFee: po.matcherFee.amount.toNumber(),
    matcherFeeAssetId: po.matcherFee.assetId == null ? null : ts_lib_crypto_1.base58Encode(po.matcherFee.assetId),
});
const recipientToProto = (r) => ({
    alias: r.startsWith('alias') ? r.slice(8) : undefined,
    publicKeyHash: !r.startsWith('alias') ? ts_lib_crypto_1.base58Decode(r).slice(2, -4) : undefined,
});
const amountToProto = (a, assetId) => ({
    amount: long_1.default.fromValue(a),
    assetId: assetId == null ? null : ts_lib_crypto_1.base58Decode(assetId),
});
const massTransferItemToProto = (mti) => ({
    recipient: recipientToProto(mti.recipient),
    amount: long_1.default.fromValue(mti.amount),
});
exports.dataEntryToProto = (de) => ({
    key: de.key,
    intValue: de.type === 'integer' ? long_1.default.fromValue(de.value) : undefined,
    boolValue: de.type === 'boolean' ? de.value : undefined,
    binaryValue: de.type === 'binary' ? ts_lib_crypto_1.base64Decode((de.value.startsWith('base64:') ? de.value.slice(7) : de.value)) : undefined,
    stringValue: de.type === 'string' ? de.value : undefined,
});
const scriptToProto = (s) => {
    return ts_lib_crypto_1.base64Decode(s.startsWith('base64:') ? s.slice(7) : s);
};
const nameByType = {
    1: 'genesis',
    2: 'payment',
    3: 'issue',
    4: 'transfer',
    5: 'reissue',
    6: 'burn',
    7: 'exchange',
    8: 'lease',
    9: 'leaseCancel',
    10: 'createAlias',
    11: 'massTransfer',
    12: 'dataTransaction',
    13: 'setScript',
    14: 'sponsorFee',
    15: 'setAssetScript',
    16: 'invokeScript',
    17: 'updateAssetInfo',
};
const typeByName = {
    'genesis': 1,
    'payment': 2,
    'issue': 3,
    'transfer': 4,
    'reissue': 5,
    'burn': 6,
    'exchange': 7,
    'lease': 8,
    'leaseCancel': 9,
    'createAlias': 10,
    'massTransfer': 11,
    'dataTransaction': 12,
    'setScript': 13,
    'sponsorFee': 14,
    'setAssetScript': 15,
    'invokeScript': 16,
    'updateAssetInfo': 17,
};
//# sourceMappingURL=proto-serialize.js.map