"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LspService = void 0;
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const ride_js_1 = require("@waves/ride-js");
const utils = require("./utils");
const context_1 = require("./context");
const noRangeError = (msg) => ({
    range: vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(0, 0), vscode_languageserver_types_1.Position.create(0, 0)),
    severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
    message: msg
});
class LspService {
    constructor(fileContentProvider) {
        this.fileContentProvider = fileContentProvider;
    }
    ;
    validateTextDocument(document) {
        let diagnostics = [];
        const info = ride_js_1.scriptInfo(document.getText());
        if ('error' in info) {
            context_1.suggestions.updateSuggestions();
            diagnostics.push(noRangeError(info.error));
            return diagnostics;
        }
        const { stdLibVersion, scriptType, imports } = info;
        context_1.suggestions.updateSuggestions(stdLibVersion, scriptType === 2);
        let libraries = {};
        for (let uri of imports) {
            try {
                libraries[uri] = this.fileContentProvider.getContent(uri, document.uri);
            }
            catch (e) {
                diagnostics.push(noRangeError(`Failed to resolve file "${uri}"`));
            }
        }
        let resultOrError = ride_js_1.compile(document.getText(), 3, false, false, libraries);
        if ('error' in resultOrError) {
            const errorText = resultOrError.error;
            const errRangesRegxp = /\d+-\d+/gm;
            const errorRanges = errRangesRegxp.exec(errorText) || [];
            if (errorRanges.length > 0) {
                const errors = errorRanges.map(offsets => {
                    const [start, end] = offsets.split('-').map(offset => document.positionAt(parseInt(offset)));
                    const range = vscode_languageserver_types_1.Range.create(start, end);
                    return {
                        range,
                        severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                        message: errorText
                    };
                });
                diagnostics.push(...errors);
            }
            else {
                const parsingErrRegexp = /:(\d+):(\d+) ...".*"\)$/gm;
                const parsingErrorRanges = parsingErrRegexp.exec(errorText) || [];
                if (!isNaN(+parsingErrorRanges[1]) && !isNaN(+parsingErrorRanges[2])) {
                    diagnostics.push({
                        range: vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(+parsingErrorRanges[1] - 1, +parsingErrorRanges[2] - 1), vscode_languageserver_types_1.Position.create(+parsingErrorRanges[1] - 1, +parsingErrorRanges[2] - 1)),
                        severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                        message: `Parsing error: ${errorText}`
                    });
                }
                else {
                    diagnostics.push({
                        range: vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(0, 0), vscode_languageserver_types_1.Position.create(0, 0)),
                        severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                        message: errorText
                    });
                }
            }
        }
        return diagnostics;
    }
    completion(document, position) {
        const offset = document.offsetAt(position);
        const text = document.getText();
        const character = text.substring(offset - 1, offset);
        const line = document.getText({ start: { line: position.line, character: 0 }, end: position });
        const p = { row: position.line, col: position.character + 1 };
        utils.ctx.updateContext(text);
        let result = [];
        try {
            let wordBeforeDot = line.match(/([a-zA-z0-9_]+)\.[a-zA-z0-9_]*\b$/); // get text before dot (ex: [tx].test)
            let firstWordMatch = (/([a-zA-z0-9_]+)\.[a-zA-z0-9_.]*$/gm).exec(line) || [];
            switch (true) {
                case (character === '.' || wordBeforeDot !== null): //auto completion after clicking on a dot
                    let inputWord = (wordBeforeDot === null) //get word before dot or last word in line
                        ? (utils.getLastArrayElement(line.match(/\b(\w*)\b\./g))).slice(0, -1)
                        : wordBeforeDot[1];
                    //TODO Make fashionable humanly
                    if (firstWordMatch.length >= 2 && utils.ctx.getVariable(firstWordMatch[1])) {
                        result = [
                            ...utils.getCompletionResult(firstWordMatch[0].split('.')),
                            ...utils.checkPostfixFunction(inputWord).map(({ name }) => ({ label: name }))
                        ];
                    }
                    break;
                //auto completion after clicking on a colon or pipe
                case (line.match(/([a-zA-z0-9_]+)[ \t]*[|:][ \t]*[a-zA-z0-9_]*$/) !== null):
                    result = utils.getColonOrPipeCompletionResult(text, p);
                    break;
                case (['@'].indexOf(character) !== -1):
                    result = [
                        { label: 'Callable', kind: vscode_languageserver_types_1.CompletionItemKind.Interface },
                        { label: 'Verifier', kind: vscode_languageserver_types_1.CompletionItemKind.Interface }
                    ];
                    break;
                default:
                    result = utils.getCompletionDefaultResult(p);
                    break;
            }
        }
        catch (e) {
            // console.error(e);
        }
        return {
            isIncomplete: false,
            items: result
        };
    }
    hover(document, position) {
        //todo add hover to func args
        const match = (/[a-zA-z0-9_]+\.[a-zA-z0-9_.]*$/gm)
            .exec(document.getText({ start: { line: position.line, character: 0 }, end: position }));
        const line = document.getText().split('\n')[position.line];
        const word = utils.getWordByPos(line, position.character);
        utils.ctx.updateContext(document.getText());
        const p = { row: position.line, col: position.character + 1 };
        return { contents: utils.getHoverResult(word, (match ? match[0] : '').split('.')) };
    }
    definition(document, position) {
        const text = document.getText(), line = text.split('\n')[position.line], word = utils.getWordByPos(line, position.character), { uri } = document, func = utils.getDataByRegexp(text, /func[ \t]*(.*)\([ \t]*(.*)[ \t]*\)[ \t]*=[ \t]*/g)
            .find(({ name }) => name === word);
        let pos;
        if (func && func.namePos && func.row)
            pos = { line: func.row, character: func.namePos };
        else
            pos = utils.getVarDefinition(word, position);
        return pos
            ? vscode_languageserver_types_1.Location.create(uri, { start: pos, end: Object.assign(Object.assign({}, pos), { character: pos.character + word.length }) })
            : null;
    }
    signatureHelp(document, position) {
        const offset = document.offsetAt(position);
        const character = document.getText().substring(offset - 1, offset);
        const textBefore = document.getText({ start: { line: 0, character: 0 }, end: position });
        const line = document.getText({ start: { line: position.line, character: 0 }, end: position });
        const isPostfix = /[a-zA-z0-9_]+\.\b([a-zA-z0-9_]+)\b[ \t]*\(/.test(line);
        const lastFunction = utils.getLastArrayElement(textBefore.match(/\b([a-zA-z0-9_]*)\b[ \t]*\(/g));
        const functionArguments = utils.getLastArrayElement(textBefore.split(lastFunction || ''));
        let fail = false;
        if (character === ')' || functionArguments.split(')').length > 1)
            fail = true;
        return {
            activeParameter: fail ? null : functionArguments.split(',').length - 1,
            activeSignature: fail ? null : 0,
            //get result by last function call
            signatures: fail ? [] : utils.getSignatureHelpResult(lastFunction.slice(0, -1), isPostfix),
        };
    }
    completionResolve(item) {
        return item;
    }
}
exports.LspService = LspService;
LspService.TextDocument = vscode_languageserver_types_1.TextDocument;
//# sourceMappingURL=LspService.js.map