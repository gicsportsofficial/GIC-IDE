"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unique = exports.getDataByRegexp = exports.intersection = exports.getTypeDoc = exports.getLastArrayElement = exports.getWordByPos = exports.getHoverResult = exports.getSignatureHelpResult = exports.checkPostfixFunction = exports.getColonOrPipeCompletionResult = exports.getCompletionResult = exports.getCompletionDefaultResult = exports.getVarDefinition = exports.ctx = void 0;
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const suggestions_1 = require("./suggestions");
const context_1 = require("./context");
exports.ctx = new context_1.Context();
const { types, functions, globalVariables, globalSuggestions } = context_1.suggestions;
const jsonSuggestions = require("./suggestions/suggestions.json");
//======================DEFINITION=========================
function getVarDefinition(word, { line: row, character: col }) {
    const variable = exports.ctx.getVariablesByPos({ row, col }).reverse().find(({ name: varName }) => varName === word);
    return variable && variable.pos ? { line: variable.pos.row, character: variable.pos.col } : undefined;
}
exports.getVarDefinition = getVarDefinition;
//======================COMPLETION=========================
exports.getCompletionDefaultResult = (p) => {
    return [
        ...globalSuggestions,
        ...types.filter(item => suggestions_1.isStruct(item.type))
            .map(({ name }) => ({ kind: vscode_languageserver_types_1.CompletionItemKind.Class, label: name })),
        ...exports.ctx.getVariablesByPos(p)
            .map(item => ({ label: item.name, kind: vscode_languageserver_types_1.CompletionItemKind.Variable, detail: item.doc })),
    ];
};
exports.getCompletionResult = (inputWords) => getLadderCompletion(exports.ctx, inputWords).map((item) => convertToCompletion(item));
function getLadderCompletion(ctx, inputWords) {
    let declVariable = ctx.getVariable(inputWords[0]);
    if (declVariable == null || !declVariable.type)
        return [];
    let out = intersection(suggestions_1.isUnion(declVariable.type) ? declVariable.type : [declVariable.type]);
    for (let i = 1; i < inputWords.length - 1; i++) {
        let actualType = out.find(item => item.name === inputWords[i] && !suggestions_1.isPrimitive(item.type) && !suggestions_1.isList(item.type));
        if (!actualType)
            return [];
        if (suggestions_1.isStruct(actualType.type))
            out = actualType.type.fields;
        if (suggestions_1.isUnion(actualType.type))
            out = intersection(actualType.type);
    }
    return out;
}
exports.getColonOrPipeCompletionResult = (text, p) => {
    let out = types.map((type) => convertToCompletion(type));
    const context = exports.ctx.getContextByPos(p);
    const matchRegexp = /\bmatch[ \t(]+\b(.+)\b[ \t)]*[{=]*/gm;
    let matchRes = matchRegexp.exec(text.split('\n')[context.start.row]);
    if (matchRes != null && matchRes[1]) {
        const variable = exports.ctx.getVariablesByPos(p).find(({ name }) => name === matchRes[1].toString());
        if (variable && variable.type && suggestions_1.isUnion(variable.type)) {
            out = variable.type.map(({ typeName }) => ({ label: typeName, kind: vscode_languageserver_types_1.CompletionItemKind.Class }));
        }
    }
    return out;
};
exports.checkPostfixFunction = (inputWord) => {
    let variable = exports.ctx.getVariable(inputWord);
    const out = functions.filter(({ args }) => {
        if (!args[0] || !variable || !variable.type)
            return false;
        let type = variable.type;
        if (suggestions_1.isPrimitive(type) && suggestions_1.isPrimitive(args[0].type) && type === args[0].type)
            return true;
        if (suggestions_1.isStruct(type) && suggestions_1.isStruct(args[0].type)) {
            if (type.typeName === args[0].type.typeName) {
                return true;
            }
        }
        if (suggestions_1.isStruct(type) && suggestions_1.isUnion(args[0].type)) {
            let currentType = args[0].type[0];
            if (suggestions_1.isStruct(currentType) && type.typeName === currentType.typeName) {
                return true;
            }
        }
        if (args[0].type === 'PARAMETERIZEDUNION(List(TYPEPARAM(84), Unit))' && suggestions_1.isUnion(type)) {
            return type.some(item => suggestions_1.isStruct(item) && item.typeName === 'Unit');
        }
        return false;
    });
    return out;
};
//======================SignatureHelp======================
function getSignatureHelpResult(word, isShift) {
    const getLabel = (name, args, resultType) => `${name}(${args.map(({ name, type }) => `${name}: ${getFunctionArgumentString(type)}`).join(', ')}): ${getFunctionArgumentString(resultType)}`;
    const getParameters = (args) => args.map(({ name, type }) => ({
        label: `${name}: ${getFunctionArgumentString(type)}`
    }));
    return [
        ...getFunctionsByName(word).map(func => (Object.assign(Object.assign({}, func), { args: func.args.filter((_, i) => !(isShift && i === 0)) }))).map(({ name, args, doc, resultType }) => ({ label: getLabel(name, args, resultType), documentation: doc, parameters: getParameters(args) })),
        ...types.filter((item) => item.name === word && suggestions_1.isStruct(item.type))
            .map(({ name, type }) => ({ label: getLabel(name, type.fields, type), parameters: getParameters(type.fields) }))
    ];
}
exports.getSignatureHelpResult = getSignatureHelpResult;
//======================Hover==============================
function getHoverResult(word, inputWords) {
    const getHoverFunctionDoc = (func) => `**${func.name}** (${func.args.length > 0 ?
        `\n${func.args.map(({ name, type, doc }) => `\n * ${`${name}: ${getFunctionArgumentString(type)} - ${doc}`} \n`)}\n` :
        ' '}) : ${getFunctionArgumentString(func.resultType)} \n>_${func.doc}_`;
    return exports.unique(getLadderCompletion(exports.ctx, inputWords)
        .filter(({ name }) => name === word).map(item => `**${item.name}**: ` + exports.getTypeDoc(item))
        .concat(exports.ctx.variables.filter(({ name }) => name === word)
        .map(({ type }) => type ? exports.getTypeDoc({ name: '', type: type }, true) : 'Unknown'))
        .concat(globalVariables.filter(({ name }) => name === word).map(({ doc }) => doc))
        .concat(getFunctionsByName(word).map((func) => getHoverFunctionDoc(func)))
        .concat(types.filter(({ name }) => name === word).map(item => exports.getTypeDoc(item)))
        .concat(jsonSuggestions.snippets.filter(({ label, detail }) => label === word && detail)
        .map(({ detail }) => detail || '')));
}
exports.getHoverResult = getHoverResult;
//======================exported functions=================
function getWordByPos(string, character) {
    let sep = ['"', '\'', '*', '(', ')', '{', '}', '[', ']', '!', '<', '>', '|', '\\', '/', '.', ',', ':', ';', '&', ' ', '=', '\t'];
    let start = 0, end = string.length;
    for (let i = character; i <= string.length; i++) {
        if (~sep.indexOf(string[i])) {
            end = i;
            break;
        }
    }
    for (let i = character; i >= 0; i--) {
        if (~sep.indexOf(string[i])) {
            start = ++i;
            break;
        }
    }
    return string.substring(start, end);
}
exports.getWordByPos = getWordByPos;
exports.getLastArrayElement = (arr) => arr !== null ? [...arr].pop() || '' : '';
//======================HELPERS============================
const getFunctionArgumentString = (type) => {
    if (suggestions_1.isPrimitive(type)) {
        return type;
    }
    else if (suggestions_1.isList(type)) {
        return suggestions_1.listToString(type);
    }
    else if (suggestions_1.isStruct(type)) {
        return type.typeName;
    }
    else if (suggestions_1.isUnion(type)) {
        return suggestions_1.unionToString(type);
    }
    else {
        return 'Unknown';
    }
};
exports.getTypeDoc = (item, isRec) => {
    const type = item.type;
    let typeDoc = 'Unknown';
    switch (true) {
        case suggestions_1.isPrimitive(type):
            typeDoc = type;
            break;
        case suggestions_1.isStruct(type):
            typeDoc = isRec ? type.typeName :
                `**${type.typeName}**(\n- ` + type.fields
                    .map((v) => `${v.name}: ${exports.getTypeDoc(v, true)}`).join('\n- ') + '\n\n)';
            break;
        case suggestions_1.isUnion(type):
            typeDoc = type.map(field => suggestions_1.isStruct(field) ? field.typeName : field).join('|');
            break;
        case suggestions_1.isList(type):
            typeDoc = suggestions_1.listToString(type);
            break;
    }
    return typeDoc;
};
const getFunctionsByName = (funcName) => functions.filter(({ name }) => name === funcName);
const convertToCompletion = (field) => {
    let detail = '';
    if (suggestions_1.isPrimitive(field.type)) {
        detail = field.type;
    }
    else if (suggestions_1.isList(field.type)) {
        detail = suggestions_1.listToString(field.type);
    }
    else if (suggestions_1.isStruct(field.type)) {
        detail = field.type.typeName;
    }
    else if (suggestions_1.isUnion(field.type)) {
        detail = suggestions_1.unionToString(field.type);
    }
    return {
        label: field.name,
        detail,
        kind: vscode_languageserver_types_1.CompletionItemKind.Field
    };
};
function intersection(types) {
    const items = [...types];
    let structs = [];
    if (types === [] || items.length === 0) {
        return [];
    }
    let next;
    while (items.length > 0) {
        next = items.pop();
        if (suggestions_1.isStruct(next)) {
            structs.push(next);
        }
        else if (suggestions_1.isUnion(next)) {
            items.push(...next);
        }
        else {
            return [];
        }
    }
    const firstArg = structs[0];
    let out = firstArg.fields;
    for (let i = 1; i < structs.length; i++)
        out = intersect(out, structs[i].fields);
    return out;
}
exports.intersection = intersection;
function intersect(a, b) {
    let list = [], out = [];
    a.forEach((val) => list.push(val.name));
    b.forEach(val => (~list.indexOf(val.name)) ? out.push(val) : false);
    return out;
}
function getDataByRegexp(text, re) {
    const declarations = [];
    const split = text.split('\n');
    let myMatch;
    split.forEach((row, i) => {
        while ((myMatch = re.exec(row)) !== null) {
            declarations.push({
                name: myMatch[1],
                namePos: row.indexOf(myMatch[1]),
                value: myMatch[2],
                valuePos: row.indexOf(myMatch[2]),
                row: i
            });
        }
    });
    return declarations;
}
exports.getDataByRegexp = getDataByRegexp;
exports.unique = (arr) => {
    let obj = {};
    for (let i = 0; i < arr.length; i++) {
        if (!arr[i])
            continue;
        let str = JSON.stringify(arr[i]);
        obj[str] = true;
    }
    return Object.keys(obj).map(type => JSON.parse(type));
};
//# sourceMappingURL=utils.js.map