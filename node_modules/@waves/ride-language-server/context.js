"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = exports.suggestions = void 0;
const suggestions_1 = require("./suggestions");
const utils_1 = require("./utils");
exports.suggestions = new suggestions_1.Suggestions();
const { regexps, types, functions, globalVariables } = exports.suggestions;
class Context {
    constructor() {
        this.context = {
            vars: [],
            start: { row: 0, col: 0 },
            end: { row: 0, col: 0 },
            children: []
        };
        this.variables = [];
        this.text = '';
        this.getVariable = (name) => this.variables.find(({ name: varName }) => varName === name);
        this.getVariablesByPos = (p) => this.getVariablesRec(this.context, p);
        this.getContextByPos = (p) => this.getContextRec(this.context, p);
        this.getContextRec = (c, p) => {
            const newCtx = c.children.find(({ start, end }) => this.comparePos(start, end, p));
            return (newCtx !== undefined) ? this.getContextRec(newCtx, p) : c;
        };
        this.getVariables = (string, row) => [
            ...utils_1.getDataByRegexp(string, suggestions_1.letRegexp),
        ]
            .map(({ name, value, namePos: col }) => this.defineType(name, value, row && col ? { row, col } : undefined));
        this.getChildrenVariables = (string, row) => [
            ...utils_1.getDataByRegexp(string, /@(Verifier|Callable)[ \t]*\((.+)\)/g)
                .map(item => (Object.assign(Object.assign({}, item), { name: item.value, value: item.name }))),
            ...utils_1.getDataByRegexp(string, suggestions_1.caseRegexp),
            ...this.getFuncArgs(string)
        ]
            .map(({ name, value, valuePos: col }) => this.defineType(name, value, row && col ? { row, col } : undefined));
        this.getExtractDoc = (value, type) => {
            let extractData = value.match(/(.+)\.extract/) ||
                value.match(/extract[ \t]*\([ \t]*([a-zA-z0-9_.()"]*)[ \t]*\)/) || [];
            let out = type, match;
            if (extractData.length < 2)
                return out;
            if (extractData[1] && (match = extractData[1].match(regexps.functionsRegExp)) != null) {
                let resultType = functions.find(({ name }) => name === match[1]).resultType;
                if (resultType && suggestions_1.isUnion(resultType)) {
                    out = resultType.filter(type => type.typeName !== 'Unit');
                }
            }
            else {
                out = this.getLadderType(extractData[1].split('.'), true).type;
            }
            return out;
        };
    }
    updateContext(text) {
        if (this.text !== text)
            this.findContextDeclarations(text);
    }
    getVariablesRec(c, p) {
        const out = c.vars;
        const childCtx = c.children.find(({ start, end }) => this.comparePos(start, end, p));
        if (childCtx)
            out.push(...this.getVariablesRec(childCtx, p));
        return out;
    }
    comparePos(start, end, p) {
        if (start.row < p.row && end.row > p.row)
            return true;
        else if (start.row === p.row && start.col <= p.col - 1)
            return true;
        else if (end.row === p.row && end.col >= p.col - 1)
            return true;
        return false;
    }
    defineType(name, value, pos) {
        value = value.replace(/#.*$/, '');
        let out = { name, pos, type: 'Unknown' };
        let match, split;
        const variable = this.getVariable(value);
        if (variable)
            out.type = variable.type;
        else if (Number(value.toString().replace(/_/g, '')).toString() !== 'NaN') {
            out.type = 'Int';
        }
        else if ((match = value.match(/\b(base58|base64|base16)\b[ \t]*'(.*)'/)) != null) {
            out.type = 'ByteVector';
        }
        else if (/.*\b&&|==|!=|>=|>\b.*/.test(value) || /\btrue|false\b/.test(value)) {
            out.type = 'Boolean';
        }
        else if ((match = value.match(/^[ \t]*"(.+)"[ \t]*/)) != null) {
            out.type = 'String';
        }
        else if ((split = value.split('|')).length > 1) {
            out.type = {
                typeName: 'Union',
                fields: utils_1.intersection(types.filter(({ name }) => ~split.indexOf(name)).map(i => i.type))
            };
        }
        else if ((match = value.match(regexps.functionsRegExp)) != null) {
            (match[1] === 'extract')
                ? out.type = this.getExtractDoc(value, 'TYPEPARAM(84)')
                : out.type = functions.find(({ name }) => name === match[1]).resultType;
        }
        else if ((match = value.match(regexps.typesRegExp)) != null) {
            out.type = types.find(type => match != null && type.name === match[0]).type;
        }
        else if ((match = value.match(/^[ \t]*\[(.+)][ \t]*$/)) != null) {
            let uniqueType = utils_1.unique(match[1].split(',')
                .map(type => this.defineType('', type).type));
            out.type = (uniqueType.length === 1) ? { listOf: uniqueType[0] } : { listOf: "any" };
        }
        else if ((split = value.split('.')).length > 1) {
            const type = this.getLadderType(split);
            out.type = type.type;
            if ((match = utils_1.getLastArrayElement(split).match(regexps.functionsRegExp)) != null) {
                let func = functions.find(({ name }) => match != null && name === match[1]);
                if (func)
                    out.type = func.resultType;
            }
        }
        else if (value === 'Callable') {
            let type = types.find(item => item.name === 'Invocation');
            out = { name: name, type: type != null ? type.type : out.type };
        }
        else if (value === 'Verifier') {
            let type = types.find(item => item.name === 'Transaction');
            out = { name: name, type: type != null ? type.type : out.type };
        }
        return out;
    }
    ;
    getLadderType(inputWords, isExtract) {
        const extractUnit = (type) => isExtract && suggestions_1.isUnion(type)
            ? type.filter((item) => !(suggestions_1.isStruct(item) && item.typeName === 'Unit'))
            : type;
        let declVariable = this.getVariable(inputWords[0]);
        if (declVariable == null || !declVariable.type)
            return { name: 'Unknown', type: 'Unknown' };
        if (suggestions_1.isUnion(declVariable.type))
            declVariable.type = {
                typeName: 'Union',
                fields: utils_1.intersection(declVariable.type)
            };
        let out = { name: declVariable.name, type: extractUnit(declVariable.type) };
        for (let i = 1; i < inputWords.length; i++) {
            let actualType;
            if (suggestions_1.isStruct(out.type))
                actualType = out.type.fields.find(type => type.name === inputWords[i]);
            if (actualType && actualType.type)
                out = Object.assign(Object.assign({}, actualType), { type: extractUnit(actualType.type) });
        }
        return out;
    }
    getContextFrame(p, rows, vars) {
        let out = {
            vars: vars || [],
            start: { row: p.row, col: p.col },
            end: { row: rows.length - 1, col: rows[rows.length - 1].length },
            children: []
        };
        let bracket = 1;
        let isStop = false;
        for (let i = p.row; i < rows.length; i++) {
            let childrenVariables = [];
            if (~rows[i].indexOf('{-#') || ~rows[i].indexOf(' #-}'))
                continue;
            if (bracket === 1) {
                const vars = this.getVariables(rows[i], i);
                out.vars.push(...vars);
                childrenVariables = this.getChildrenVariables(rows[i], i);
                this.variables.push(...vars, ...childrenVariables);
            }
            for (let j = ((i === p.row) ? (p.col + 1) : 0); j < rows[i].length; j++) {
                if (rows[i][j] === '}')
                    bracket--;
                if (rows[i][j] === '{') {
                    const child = this.getContextFrame({ row: i, col: j }, rows, childrenVariables);
                    out.children.push(child);
                    i = child.end.row;
                    j = child.end.col;
                }
                if (bracket === 0) {
                    out.end.row = i;
                    out.end.col = j + 1;
                    isStop = true;
                    break;
                }
            }
            if (isStop)
                break;
        }
        return out;
    }
    getFuncArgs(row) {
        const out = [];
        utils_1.getDataByRegexp(row, /func[ \t]*(.*)\([ \t]*(.*)[ \t]*\)[ \t]*=[ \t]*{/g).forEach(({ value, valuePos: pos, row }) => value.split(/[ \t]*,[ \t]*/).forEach(v => {
            const split = v.split(/[ \t]*:[ \t]*/);
            const valuePos = value.indexOf(v) !== -1 && pos ? value.indexOf(v) + pos : undefined;
            if (split[0] && split[1])
                out.push({ name: split[0] || '', value: split[1] || '', valuePos, row });
        }));
        return out;
    }
    findContextDeclarations(text) {
        const rows = text.split('\n');
        this.variables.length = 0;
        this.variables.push(...globalVariables);
        const out = this.getContextFrame({ row: 0, col: 0 }, rows, globalVariables);
        this.context = out;
        return out;
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map