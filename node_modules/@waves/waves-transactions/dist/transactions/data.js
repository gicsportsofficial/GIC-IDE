"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.data = void 0;
/**
 * @module index
 */
const wavesProto = __importStar(require("@waves/protobuf-serialization"));
const marshall_1 = require("@waves/marshall");
const ts_lib_crypto_1 = require("@waves/ts-lib-crypto");
const generic_1 = require("../generic");
const validators_1 = require("../validators");
const proto_serialize_1 = require("../proto-serialize");
const defaultVersions_1 = require("../defaultVersions");
const ts_types_1 = require("@waves/ts-types");
const { BASE58_STRING, BASE64_STRING, BYTE, BYTES, COUNT, LEN, LONG, SHORT, STRING, } = marshall_1.serializePrimitives;
const typeMap = {
    integer: ['integer', 0, LONG],
    number: ['integer', 0, LONG],
    boolean: ['boolean', 1, BYTE],
    string: ['string', 3, LEN(SHORT)(STRING)],
    binary: ['binary', 2, (s) => LEN(SHORT)(BASE64_STRING)(s)],
    _: ['binary', 2, LEN(SHORT)(BYTES)],
};
const mapType = (value, type) => {
    return !!type ? typeMap[type] : typeMap[typeof value] || typeMap['_'];
};
const convertValue = (type, value, opt) => {
    return type === 'binary' && (Uint8Array.prototype.isPrototypeOf(value) || Array.isArray(value))
        ? 'base64:' + Buffer.from(value).toString('base64')
        : value;
};
function data(paramsOrTx, seed) {
    var _a;
    const type = ts_types_1.TRANSACTION_TYPE.DATA;
    const version = paramsOrTx.version || defaultVersions_1.DEFAULT_VERSIONS.DATA;
    const seedsAndIndexes = generic_1.convertToPairs(seed);
    const senderPublicKey = generic_1.getSenderPublicKey(seedsAndIndexes, paramsOrTx);
    if (!Array.isArray(paramsOrTx.data))
        throw new Error('["data should be array"]');
    const _timestamp = paramsOrTx.timestamp || Date.now();
    const dataEntriesWithTypes = ((_a = paramsOrTx.data) !== null && _a !== void 0 ? _a : []).map((x) => {
        if (x.value == null)
            return x;
        if (x.type) {
            return Object.assign(Object.assign({}, x), { value: convertValue(x.type, x.value, 'defined') });
        }
        else {
            const type = mapType(x.value, x.type)[0];
            return {
                type,
                key: x.key,
                // @ts-ignore
                value: convertValue(type, x.value, 'not defined'),
            };
        }
    });
    const schema = (x) => {
        return ts_lib_crypto_1.concat(LEN(SHORT)(STRING)(x.key), [mapType(x.value, x.type)[1]], mapType(x.value, x.type)[2](x.value));
    };
    let computedFee;
    if (version < 2) {
        let bytes = ts_lib_crypto_1.concat(BYTE(ts_types_1.TRANSACTION_TYPE.DATA), BYTE(1), BASE58_STRING(senderPublicKey), COUNT(SHORT)(schema)(dataEntriesWithTypes), LONG(_timestamp));
        computedFee = (Math.floor(1 + (bytes.length - 1) / 1024) * 100000);
    }
    else {
        let protoEntries = dataEntriesWithTypes.map(proto_serialize_1.dataEntryToProto);
        let dataBytes = wavesProto.waves.DataTransactionData.encode({ data: protoEntries }).finish();
        computedFee = (Math.ceil(dataBytes.length / 1024) * 100000);
    }
    const tx = {
        type,
        version,
        senderPublicKey,
        fee: generic_1.fee(paramsOrTx, computedFee),
        feeAssetId: generic_1.normalizeAssetId(paramsOrTx.feeAssetId),
        timestamp: _timestamp,
        proofs: paramsOrTx.proofs || [],
        chainId: generic_1.networkByte(paramsOrTx.chainId, 87),
        id: '',
        data: dataEntriesWithTypes,
    };
    validators_1.validate.data(tx);
    const bytes1 = version > 1 ? proto_serialize_1.txToProtoBytes(tx) : marshall_1.binary.serializeTx(tx);
    seedsAndIndexes.forEach(([s, i]) => generic_1.addProof(tx, ts_lib_crypto_1.signBytes(s, bytes1), i));
    tx.id = ts_lib_crypto_1.base58Encode(ts_lib_crypto_1.blake2b(bytes1));
    return tx;
}
exports.data = data;
//# sourceMappingURL=data.js.map