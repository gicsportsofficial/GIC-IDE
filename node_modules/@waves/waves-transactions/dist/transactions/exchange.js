"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exchange = void 0;
const marshall_1 = require("@waves/marshall");
const ts_lib_crypto_1 = require("@waves/ts-lib-crypto");
const generic_1 = require("../generic");
const validators_1 = require("../validators");
const proto_serialize_1 = require("../proto-serialize");
const defaultVersions_1 = require("../defaultVersions");
const ts_types_1 = require("@waves/ts-types");
/* @echo DOCS */
function exchange(paramsOrTx, seed) {
    const type = ts_types_1.TRANSACTION_TYPE.EXCHANGE;
    const version = paramsOrTx.version || defaultVersions_1.DEFAULT_VERSIONS.EXCHANGE;
    const seedsAndIndexes = generic_1.convertToPairs(seed);
    const senderPublicKey = generic_1.getSenderPublicKey(seedsAndIndexes, paramsOrTx);
    const tx = {
        type,
        version,
        senderPublicKey,
        order1: paramsOrTx.order1,
        order2: paramsOrTx.order2,
        price: paramsOrTx.price,
        amount: paramsOrTx.amount,
        buyMatcherFee: paramsOrTx.buyMatcherFee,
        sellMatcherFee: paramsOrTx.sellMatcherFee,
        fee: generic_1.fee(paramsOrTx, 100000),
        timestamp: paramsOrTx.timestamp || Date.now(),
        proofs: paramsOrTx.proofs || [],
        chainId: generic_1.networkByte(paramsOrTx.chainId, 87),
        id: '',
    };
    validators_1.validate.exchange(tx);
    const bytes = version > 2 ? proto_serialize_1.txToProtoBytes(tx) : marshall_1.binary.serializeTx(tx);
    seedsAndIndexes.forEach(([s, i]) => generic_1.addProof(tx, ts_lib_crypto_1.signBytes(s, bytes), i));
    return Object.assign(Object.assign({}, tx), { id: ts_lib_crypto_1.base58Encode(ts_lib_crypto_1.blake2b(bytes)) });
}
exports.exchange = exchange;
//# sourceMappingURL=exchange.js.map