import { TRANSACTION_STATUSES } from '../../constants';
import { fetchHeight } from '../blocks';
import request from '../../tools/request';
import query from '../../tools/query';
import { deepAssign } from '../../tools/utils';
import stringify from '../../tools/stringify';
/**
 * GET /transactions/unconfirmed/size
 * Number of unconfirmed transactions
 */
export function fetchUnconfirmedSize(base) {
    return request({
        base,
        url: '/transactions/unconfirmed/size'
    });
}
// @TODO: when correct API key is received
/**
 * POST /transactions/sign/{signerAddress}
 * Sign a transaction with a non-default private key
 */
/**
 * POST /transactions/calculateFee
 * Calculate transaction fee
 */
export function fetchCalculateFee(base, tx, options = Object.create(null)) {
    return request({
        base,
        url: '/transactions/calculateFee',
        options: deepAssign(Object.assign({}, options), {
            method: 'POST',
            body: stringify(tx),
            headers: {
                'Content-Type': 'application/json'
            }
        })
    });
}
/**
 * GET /transactions/unconfirmed
 * Unconfirmed transactions
 */
export function fetchUnconfirmed(base, options = Object.create(null)) {
    return request({
        base,
        url: '/transactions/unconfirmed',
        options
    });
}
/**
 * Список транзакций по адресу
 * @param address
 * @param limit      максимальное количество транзакций в результате
 * @param after      искать транзакции после ID указанного в after
 * @param retry      количество попыток на выполнение запроса
 */
export function fetchTransactions(base, address, limit, after, retry, options = Object.create(null)) {
    return request({
        base,
        url: `/transactions/address/${address}/limit/${limit}${query({ after })}`,
        options
    }).then(([list]) => {
        return list;
    });
}
/**
 * GET /transactions/unconfirmed/info/{id}
 * Unconfirmed transaction info
 */
export function fetchUnconfirmedInfo(base, id, options = Object.create(null)) {
    return request({
        base,
        url: `/transactions/unconfirmed/info/${id}`,
        options
    });
}
// @TODO when correct API key is received
/**
 * POST /transactions/sign
 * Sign a transaction
 */
/**
 * GET /transactions/info/{id}
 * Transaction info
 */
export function fetchInfo(base, id, options = Object.create(null)) {
    return request({
        base,
        url: `/transactions/info/${id}`,
        options
    });
}
/**
 * GET /transactions/info/
 * Get transactions by IDs
 */
export function fetchMultipleInfo(base, ids, options = Object.create(null)) {
    return request({
        base,
        url: `/transactions/info${query({ id: ids })}`,
        options
    });
}
export function fetchStatus(base, list) {
    const DEFAULT_STATUS = {
        id: '',
        confirmations: -1,
        height: -1,
        inUTX: false,
        status: TRANSACTION_STATUSES.NOT_FOUND
    };
    const loadAllTxInfo = list.map(id => fetchUnconfirmedInfo(base, id)
        .then(() => (Object.assign(Object.assign({}, DEFAULT_STATUS), { id, status: TRANSACTION_STATUSES.UNCONFIRMED, inUTX: true })))
        .catch(() => fetchInfo(base, id)
        .then(tx => (Object.assign(Object.assign({}, DEFAULT_STATUS), { id, status: TRANSACTION_STATUSES.IN_BLOCKCHAIN, height: tx.height, applicationStatus: tx.applicationStatus }))))
        .catch(() => (Object.assign(Object.assign({}, DEFAULT_STATUS), { id }))));
    return Promise.all([
        fetchHeight(base),
        Promise.all(loadAllTxInfo)
    ]).then(([{ height }, statuses]) => ({
        height,
        statuses: statuses.map(item => (Object.assign(Object.assign({}, item), { confirmations: item.status === TRANSACTION_STATUSES.IN_BLOCKCHAIN ? height - item.height : item.confirmations })))
    }));
}
export function broadcast(base, tx, options = Object.create(null)) {
    return request({
        base, url: '/transactions/broadcast',
        options: deepAssign(Object.assign({}, options), {
            method: 'POST',
            body: stringify(tx),
            headers: {
                'Content-Type': 'application/json'
            }
        })
    });
}
//# sourceMappingURL=index.js.map