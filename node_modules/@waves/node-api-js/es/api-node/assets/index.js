var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import request from '../../tools/request';
import { toArray } from '../../tools/utils';
import query from "../../tools/query";
export function fetchDetails(base, assetId, options = Object.create(null)) {
    const isOnce = !Array.isArray(assetId);
    return Promise.all(toArray(assetId).map(id => request({
        base,
        url: `/assets/details/${id}`,
        options
    })))
        .then(list => isOnce ? list[0] : list);
}
/**
 * POST /assets/details
 * Provides detailed information about the given assets
 */
export function fetchAssetsDetails(base, assetIds, options = Object.create(null)) {
    const body = JSON.stringify({ ids: assetIds });
    const _options = Object.assign(Object.assign({}, options), { body, headers: {
            'content-type': 'application/json'
        }, method: 'POST' });
    return request({ base, url: `/assets/details`, options: _options });
}
export function fetchAssetDistribution(base, assetId, height, limit, options = Object.create(null)) {
    return request({ base, url: `/assets/${assetId}/distribution/${height}/limit/${limit}`, options });
}
/**
 * TODO
 * GET /assets/{assetId}/distribution
 * Asset balance distribution
 */
export function fetchAssetsAddressLimit(base, address, limit, options = Object.create(null)) {
    return request({ base, url: `assets/nft/${address}/limit/${limit}`, options });
}
export function fetchAssetsNft(base, { address, limit, after }, options = Object.create(null)) {
    const url = new URL(`assets/nft/${address}/limit/${limit}`, base);
    if (after) {
        url.searchParams.append('after', after);
    }
    return request({ base, url: `${url.pathname}${url.search}`, options });
}
export function fetchAssetsBalance(base, address, options = Object.create(null)) {
    return __awaiter(this, void 0, void 0, function* () {
        const balancesResponse = yield request({ base, url: `/assets/balance/${address}`, options });
        return balancesResponse;
    });
}
export function fetchBalanceAddressAssetId(base, address, assetId, options = Object.create(null)) {
    return request({ base, url: `/assets/balance/${address}/${assetId}`, options });
}
export function convertEthAssetId(base, assetId) {
    return request({ base, url: `/eth/assets${query({ id: assetId })}` }).then(assets => assets[0].assetId);
}
//# sourceMappingURL=index.js.map