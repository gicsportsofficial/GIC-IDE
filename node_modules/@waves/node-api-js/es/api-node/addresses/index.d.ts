import { TLong } from '../../interface';
import { DataTransactionEntry } from '@waves/ts-types';
export declare function fetchDataKey(base: string, address: string, key: string, options?: RequestInit): Promise<DataTransactionEntry<TLong>>;
export declare function fetchScriptInfoMeta(base: string, address: string): Promise<IScriptInfoMetaResponse>;
export declare function fetchBalanceDetails(base: string, address: string, options?: RequestInit): Promise<IBalanceDetails<TLong>>;
export declare function fetchBalanceConfirmations(base: string, address: string, confirmations: number, options?: RequestInit): Promise<IBalanceConfirmations<TLong>>;
export declare function fetchScriptInfo(base: string, address: string, options?: RequestInit): Promise<IScriptInfo<TLong>>;
export declare function data(base: string, address: string, params?: IDataQueryParams, options?: RequestInit): Promise<Array<DataTransactionEntry<TLong>>>;
export declare function fetchValidate(base: string, address: string): Promise<IValidateResponse>;
export declare function fetchBalance(base: string, address: string, options?: RequestInit): Promise<IBalanceConfirmations<TLong>>;
export declare function fetchMultipleBalance(base: string, addresses: string[], options?: RequestInit): Promise<IBalanceConfirmations<TLong>[]>;
export declare function deleteAddressFromWallet(base: string, address: string, options?: RequestInit): Promise<IBalanceConfirmations<TLong> | IBalanceConfirmations<TLong>[]>;
export declare function fetchEffectiveBalanceConfirmations(base: string, address: string, confirmations: number, options?: RequestInit): Promise<IBalanceConfirmations<TLong>>;
export declare function fetchEffectiveBalance(base: string, address: string, options?: RequestInit): Promise<IBalanceConfirmations<TLong>>;
export declare function fetchSeq(base: string, from: number, to: number): Promise<Array<string>>;
export declare function fetchSeed(base: string, address: string): Promise<string>;
export declare function fetchPublicKey(base: string, publicKey: string): Promise<IPublicKeyResponse>;
export declare function fetchAddresses(base: string): Promise<Array<string>>;
export interface IBalanceConfirmations<LONG> {
    address: string;
    confirmations: number;
    balance: LONG;
}
export interface IScriptInfo<LONG = TLong> {
    address: string;
    complexity: number;
    callableComplexities: Record<string, number>;
    verifierComplexity: number;
    extraFee: LONG;
    script?: string;
    scriptText?: string;
}
export interface IDataQueryParams {
    matches?: string;
    keys?: string | Array<string>;
}
export interface IBalanceDetails<LONG> {
    address: string;
    /**
     * Весь принадлежащий мне баланс, включая исходящий лизинг
     * Available + LeaseOut
     */
    regular: LONG;
    /**
     * Минимальный эффективный баланс за последнюю 1000 блоков
     */
    generating: LONG;
    /**
     * Мой баланс без исходящего лизинга
     * Баланс, который можно тратить
     */
    available: LONG;
    /**
     * Баланс для генерации блоков (включая входящий лизинг и исключая исходящий)
     * Available + LeaseIn - LeaseOut
     */
    effective: LONG;
}
export declare type ICallableFuncArgumentType = 'Int' | 'String' | 'ByteVector' | 'Boolean';
export declare type TCallableFuncArgumentsArray = {
    name: string;
    type: ICallableFuncArgumentType;
}[];
export declare type TCallableFuncArgumentsRecord = Record<string, ICallableFuncArgumentType>;
export declare type TCallableFuncArguments = TCallableFuncArgumentsArray | TCallableFuncArgumentsRecord;
export interface IScriptInfoMeta<TArguments extends TCallableFuncArguments> {
    version: string;
    isArrayArguments?: boolean;
    callableFuncTypes: Record<string, TArguments>;
}
export interface IScriptInfoMetaResponse {
    address: string;
    meta: IScriptInfoMeta<TCallableFuncArguments>;
}
export interface IValidateResponse {
    address: string;
    valid: boolean;
}
export interface IPublicKeyResponse {
    address: string;
}
