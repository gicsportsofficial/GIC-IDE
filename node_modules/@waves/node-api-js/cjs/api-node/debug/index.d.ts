import { TLong } from '../../interface';
import { AssetDecimals, DataTransactionEntry, Transaction, WithId } from '@waves/ts-types';
/**
 * Waves balance history
 * @param base
 * @param address
 */
export declare function fetchBalanceHistory(base: string, address: string, options?: RequestInit): Promise<Array<IBalanceHistory>>;
interface IBalanceHistory {
    height: number;
    balance: TLong;
}
export declare type TPayment = {
    assetId: string | null;
    amount: TLong;
};
export declare type TStateChanges = {
    data: DataTransactionEntry[];
    transfers: {
        address: string;
        amount: TLong;
        asset: string | null;
    }[];
    issues: {
        assetId: string;
        name: string;
        description: string;
        quantity: TLong;
        decimals: AssetDecimals;
        isReissuable: boolean;
        compiledScript: null | string;
        nonce: TLong;
    }[];
    reissues: {
        assetId: string;
        isReissuable: boolean;
        quantity: TLong;
    }[];
    burns: {
        assetId: string;
        quantity: TLong;
    }[];
    sponsorFees: {
        assetId: string;
        minSponsoredAssetFee: TLong;
    }[];
    leases: {
        leaseId: string;
        recipient: string;
        amount: TLong;
    }[];
    leaseCancels: {
        leaseId: string;
    }[];
    invokes: ({
        dApp: string;
        call: {
            function: string;
            args: {
                type: string;
                value: string;
            }[];
        };
        payment: TPayment[];
        stateChanges: TStateChanges;
    })[];
    error?: {
        code: number;
        text: string;
    };
};
export interface IWithStateChanges {
    stateChanges: TStateChanges;
}
/**
 * Get list of transactions with state changes where specified address has been involved
 * @param base
 * @param address
 * @param limit
 * @param after
 */
export declare function fetchStateChangesByAddress(base: string, address: string, limit: number, after?: string, options?: RequestInit): Promise<Array<Transaction<TLong> & WithId & IWithStateChanges>>;
/**
 * Get invokeScript transaction state changes
 * @param base
 * @param txId
 */
export declare function fetchStateChangesByTxId(base: string, txId: string, options?: RequestInit): Promise<Transaction<TLong> & WithId & IWithStateChanges>;
export declare function postPeerToTheBanList(base: string, peer: string): Promise<any>;
export declare function fetchConfigInfo(base: string, apiKey: string): Promise<string>;
export declare function fetchDebugInfo(base: string, apiKey: string): Promise<IDebugInfo>;
export declare function fetchMinerInfo(base: string, apiKey: string): Promise<IMinerInfo<TLong>>;
export declare function fetchPortfolios(base: string, address: string, apiKey: string): Promise<IPortfolio<TLong>>;
export declare function debugPrint(base: string, message: string, apiKey: string): Promise<any>;
/**
 * Removes all blocks after a given height. Max number of blocks back from the current height is set by waves.db.max-rollback-depth, 2000 by default
 * @param base
 * @param height
 * @param returnTransactionsToUtx
 * @param apiKey
 */
export declare function debugRollback(base: string, height: number, returnTransactionsToUtx: boolean, apiKey: string): Promise<any>;
/**
 * Rollback the state to the block with a given ID
 * @param base
 * @param height
 * @param returnTransactionsToUtx
 * @param apiKey
 */
export declare function debugRollbackTo(base: string, id: string, apiKey: string): Promise<any>;
/**
 * Regular address balance at the current height
 * @param base
 * @param apiKey
 */
export declare function debugState(base: string, apiKey: string): Promise<Record<string, number | string>>;
/**
 * Get state hash at height. Available only if node configuration contains waves.db.store-state-hashes = true option
 * @param base
 * @param height
 */
export declare function debugStateHash(base: string, height: number, options?: RequestInit): Promise<IStateHash>;
/**
 * Regular address balance at the height. Max number of blocks back from the current height is set by waves.db.max-rollback-depth, 2000 by default
 * @param base
 * @param height
 * @param apiKey
 */
export declare function debugStateWaves(base: string, height: number, apiKey: string): Promise<Record<string, number | string>>;
/**
 * Validates a transaction and measures time spent in milliseconds. You should use the JSON transaction format with proofs
 * @param base
 * @param transaction
 */
export declare function debugValidate(base: string, transaction: string): Promise<IValidateResponse>;
interface IDebugInfo {
    "stateHeight": number;
    "extensionLoaderState": string;
    "historyReplierCacheSizes": {
        "microBlockOwners": number;
        "nextInvs": number;
        "awaiting": number;
        "successfullyReceived": number;
    };
    "microBlockSynchronizerCacheSizes": {
        "microBlockOwners": number;
        "nextInvs": number;
        "awaiting": number;
        "successfullyReceived": number;
    };
    "scoreObserverStats": {
        "localScore": number;
        "currentBestChannel": string;
        "scoresCacheSize": number;
    };
    "minerState": string;
}
interface IMinerInfo<LONG> {
    "address": string;
    "miningBalance": LONG;
    "timestamp": number;
}
interface IPortfolio<LONG> {
    "balance": number;
    "lease": {
        "in": number;
        "out": number;
    };
    "assets": Record<string, LONG>;
}
interface IStateHash {
    stateHash: string;
    wavesBalanceHash: string;
    assetBalanceHash: string;
    dataEntryHash: string;
    accountScriptHash: string;
    assetScriptHash: string;
    leaseBalanceHash: string;
    leaseStatusHash: string;
    sponsorshipHash: string;
    aliasHash: string;
    blockId: string;
}
interface IValidateResponse {
    valid: boolean;
    validationTime: number;
    "trace": string[];
}
export {};
