"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Signer = void 0;
var tslib_1 = require("tslib");
var constants_1 = require("./constants");
var client_logs_1 = require("@waves/client-logs");
var addresses_1 = require("@waves/node-api-js/cjs/api-node/addresses");
var assets_1 = require("@waves/node-api-js/cjs/api-node/assets");
var wait_1 = tslib_1.__importDefault(require("@waves/node-api-js/cjs/tools/transactions/wait"));
var broadcast_1 = tslib_1.__importDefault(require("@waves/node-api-js/cjs/tools/transactions/broadcast"));
var getNetworkByte_1 = tslib_1.__importDefault(require("@waves/node-api-js/cjs/tools/blocks/getNetworkByte"));
var ts_types_1 = require("@waves/ts-types");
var validation_1 = require("./validation");
var SignerError_1 = require("./SignerError");
var helpers_1 = require("./helpers");
var decorators_1 = require("./decorators");
tslib_1.__exportStar(require("./types"), exports);
var Signer = /** @class */ (function () {
    function Signer(options) {
        var _this_1 = this;
        var _a;
        this._issue = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.ISSUE }));
        }; };
        this._transfer = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.TRANSFER }));
        }; };
        this._reissue = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.REISSUE }));
        }; };
        this._burn = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.BURN }));
        }; };
        this._lease = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.LEASE }));
        }; };
        this._exchange = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.EXCHANGE }));
        }; };
        this._cancelLease = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.CANCEL_LEASE }));
        }; };
        this._alias = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.ALIAS }));
        }; };
        this._massTransfer = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.MASS_TRANSFER }));
        }; };
        this._data = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.DATA }));
        }; };
        this._sponsorship = function (txList) { return function (sponsorship) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, sponsorship), { type: ts_types_1.TRANSACTION_TYPE.SPONSORSHIP }));
        }; };
        this._setScript = function (txList) { return function (setScript) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, setScript), { type: ts_types_1.TRANSACTION_TYPE.SET_SCRIPT }));
        }; };
        this._setAssetScript = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.SET_ASSET_SCRIPT }));
        }; };
        this._invoke = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, tslib_1.__assign(tslib_1.__assign({}, data), { type: ts_types_1.TRANSACTION_TYPE.INVOKE_SCRIPT }));
        }; };
        this._logger = client_logs_1.makeConsole(client_logs_1.makeOptions((_a = options === null || options === void 0 ? void 0 : options.LOG_LEVEL) !== null && _a !== void 0 ? _a : 'production', 'Signer'));
        this._handleError = helpers_1.errorHandlerFactory(this._logger);
        this._options = tslib_1.__assign(tslib_1.__assign({}, constants_1.DEFAULT_OPTIONS), (options || {}));
        var _b = validation_1.validateSignerOptions(this._options), isValid = _b.isValid, invalidOptions = _b.invalidOptions;
        if (!isValid) {
            var error = this._handleError(SignerError_1.ERRORS.SIGNER_OPTIONS, [
                invalidOptions,
            ]);
            throw error;
        }
        var makeNetworkByteError = function (e) {
            var error = _this_1._handleError(SignerError_1.ERRORS.NETWORK_BYTE, [
                {
                    error: e.message,
                    node: _this_1._options.NODE_URL,
                },
            ]);
            _this_1._logger.error(error);
            return error;
        };
        try {
            this._networkBytePromise = getNetworkByte_1.default(this._options.NODE_URL)
                .catch(function (e) { return Promise.reject(makeNetworkByteError(e)); });
        }
        catch (e) {
            throw makeNetworkByteError(e);
        }
        this._logger.info('Signer instance has been successfully created. Options: ', options);
    }
    Object.defineProperty(Signer.prototype, "_connectPromise", {
        get: function () {
            return this.__connectPromise || Promise.reject('Has no provider!');
        },
        set: function (promise) {
            this.__connectPromise = promise;
        },
        enumerable: false,
        configurable: true
    });
    Signer.prototype.on = function (event, handler) {
        this.currentProvider.on(event, handler);
        this._logger.info("Handler for \"" + event + "\" has been added.");
        return this;
    };
    Signer.prototype.once = function (event, handler) {
        this.currentProvider.once(event, handler);
        this._logger.info("One-Time handler for \"" + event + "\" has been added.");
        return this;
    };
    Signer.prototype.off = function (event, handler) {
        this.currentProvider.off(event, handler);
        this._logger.info("Handler for \"" + event + "\" has been removed.");
        return this;
    };
    Signer.prototype.broadcast = function (toBroadcast, options) {
        // @ts-ignore
        return broadcast_1.default(this._options.NODE_URL, toBroadcast, options); // TODO поправить тип в broadcast
    };
    /**
     * Запросить байт сети
     */
    Signer.prototype.getNetworkByte = function () {
        return this._networkBytePromise;
    };
    /**
     * Устанавливаем провайдер отвечающий за подпись
     * @param provider
     *
     * ```ts
     * import Signer from '@waves/signer';
     * import Provider from '@waves/seed-provider';
     *
     * const waves = new Signer();
     * waves.setProvider(new Provider('SEED'));
     * ```
     */
    Signer.prototype.setProvider = function (provider) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var providerValidation, error;
            var _this_1 = this;
            return tslib_1.__generator(this, function (_a) {
                providerValidation = validation_1.validateProviderInterface(provider);
                if (!providerValidation.isValid) {
                    error = this._handleError(SignerError_1.ERRORS.PROVIDER_INTERFACE, [providerValidation.invalidProperties]);
                    throw error;
                }
                this.currentProvider = provider;
                this._logger.info('Provider has been set.');
                this._connectPromise =
                    this._networkBytePromise
                        .then(function (byte) {
                        return provider.connect({
                            NETWORK_BYTE: byte,
                            NODE_URL: _this_1._options.NODE_URL,
                        })
                            .then(function () {
                            _this_1._logger.info('Provider has conneced to node.');
                            return provider;
                        })
                            .catch(function (e) {
                            var error = _this_1._handleError(SignerError_1.ERRORS.PROVIDER_CONNECT, [{
                                    error: e.message,
                                    node: _this_1._options.NODE_URL,
                                }]);
                            _this_1._logger.error(error);
                            return Promise.reject(error);
                        });
                    });
                return [2 /*return*/];
            });
        });
    };
    /**
     * Получаем список балансов пользователя (необходимо выполнить login перед использованием)
     * Basic usage example:
     *
     * ```ts
     * await waves.getBalance(); // Возвращает балансы пользователя
     * ```
     */
    Signer.prototype.getBalance = function () {
        var _this_1 = this;
        return Promise.all([
            addresses_1.fetchBalanceDetails(this._options.NODE_URL, this._userData.address).then(function (data) { return ({
                assetId: 'WAVES',
                assetName: 'Waves',
                decimals: 8,
                amount: String(data.available),
                isMyAsset: false,
                tokens: Number(data.available) * Math.pow(10, 8),
                sponsorship: null,
                isSmart: false,
            }); }),
            assets_1.fetchAssetsBalance(this._options.NODE_URL, this._userData.address).then(function (data) {
                return data.balances.map(function (item) { return ({
                    assetId: item.assetId,
                    assetName: item.issueTransaction.name,
                    decimals: item.issueTransaction.decimals,
                    amount: String(item.balance),
                    isMyAsset: item.issueTransaction.sender ===
                        _this_1._userData.address,
                    tokens: item.balance *
                        Math.pow(10, item.issueTransaction.decimals),
                    isSmart: !!item.issueTransaction.script,
                    sponsorship: item.sponsorBalance != null &&
                        item.sponsorBalance > Math.pow(10, 8) &&
                        (item.minSponsoredAssetFee || 0) < item.balance
                        ? item.minSponsoredAssetFee
                        : null,
                }); });
            }),
        ]).then(function (_a) {
            var waves = _a[0], assets = _a[1];
            return tslib_1.__spreadArrays([waves], assets);
        });
    };
    /**
     * Получаем информацию о пользователе
     *
     * ```ts
     * await waves.login(); // Авторизуемся. Возвращает адрес и публичный ключ
     * ```
     */
    Signer.prototype.login = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, err_1, error;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        _a = this;
                        return [4 /*yield*/, this.currentProvider.login()];
                    case 1:
                        _a._userData = _b.sent();
                        this._logger.info('Logged in.');
                        return [2 /*return*/, this._userData];
                    case 2:
                        err_1 = _b.sent();
                        if (err_1 === 'Error: User rejection!') {
                            throw err_1;
                        }
                        error = this._handleError(SignerError_1.ERRORS.PROVIDER_INTERNAL, err_1.message);
                        throw error;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Вылогиниваемся из юзера
     */
    Signer.prototype.logout = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, message, error;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.currentProvider.logout()];
                    case 1:
                        _b.sent();
                        this._userData = undefined;
                        this._logger.info('Logged out.');
                        return [3 /*break*/, 3];
                    case 2:
                        _a = _b.sent();
                        message = _a.message;
                        error = this._handleError(SignerError_1.ERRORS.PROVIDER_INTERNAL, message);
                        throw error;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Подписываем сообщение пользователя (провайдер может устанавливать префикс)
     * @param message
     */
    Signer.prototype.signMessage = function (message) {
        return this._connectPromise.then(function (provider) {
            return provider.signMessage(message);
        });
    };
    /**
     * Подписываем типизированные данные
     * @param data
     */
    Signer.prototype.signTypedData = function (data) {
        return this._connectPromise.then(function (provider) {
            return provider.signTypedData(data);
        });
    };
    /**
     * Получаем список балансов в кторых можно платить комиссию
     */
    Signer.prototype.getSponsoredBalances = function () {
        return this.getBalance().then(function (balance) {
            return balance.filter(function (item) { return !!item.sponsorship; });
        });
    };
    Signer.prototype.batch = function (tsx) {
        var _this_1 = this;
        var sign = function () {
            return _this_1._sign(tsx).then(function (result) { return result; });
        };
        return {
            sign: sign,
            broadcast: function (opt) {
                return sign().then(function (transactions) {
                    return _this_1.broadcast(transactions, opt);
                });
            },
        };
    };
    Signer.prototype.issue = function (data) {
        return this._issue([])(data);
    };
    Signer.prototype.transfer = function (data) {
        return this._transfer([])(data);
    };
    Signer.prototype.reissue = function (data) {
        return this._reissue([])(data);
    };
    Signer.prototype.burn = function (data) {
        return this._burn([])(data);
    };
    Signer.prototype.lease = function (data) {
        return this._lease([])(data);
    };
    Signer.prototype.exchange = function (data) {
        return this._exchange([])(data);
    };
    Signer.prototype.cancelLease = function (data) {
        return this._cancelLease([])(data);
    };
    Signer.prototype.alias = function (data) {
        return this._alias([])(data);
    };
    Signer.prototype.massTransfer = function (data) {
        return this._massTransfer([])(data);
    };
    Signer.prototype.data = function (data) {
        return this._data([])(data);
    };
    Signer.prototype.sponsorship = function (data) {
        return this._sponsorship([])(data);
    };
    Signer.prototype.setScript = function (data) {
        return this._setScript([])(data);
    };
    Signer.prototype.setAssetScript = function (data) {
        return this._setAssetScript([])(data);
    };
    Signer.prototype.invoke = function (data) {
        return this._invoke([])(data);
    };
    Signer.prototype.waitTxConfirm = function (tx, confirmations) {
        return wait_1.default(this._options.NODE_URL, tx, { confirmations: confirmations }); // TODO Fix types
    };
    Signer.prototype._createPipelineAPI = function (prevCallTxList, signerTx) {
        var _this_1 = this;
        var _this = this;
        var txs = prevCallTxList.length
            ? tslib_1.__spreadArrays(prevCallTxList, [signerTx]) : [signerTx];
        var chainArgs = Array.isArray(txs) ? txs : [txs];
        return tslib_1.__assign(tslib_1.__assign({}, {
            issue: this._issue(chainArgs),
            transfer: this._transfer(chainArgs),
            reissue: this._reissue(chainArgs),
            burn: this._burn(chainArgs),
            lease: this._lease(chainArgs),
            exchange: this._exchange(chainArgs),
            cancelLease: this._cancelLease(chainArgs),
            alias: this._alias(chainArgs),
            massTransfer: this._massTransfer(chainArgs),
            data: this._data(chainArgs),
            sponsorship: this._sponsorship(chainArgs),
            setScript: this._setScript(chainArgs),
            setAssetScript: this._setAssetScript(chainArgs),
            invoke: this._invoke(chainArgs),
        }), { sign: function () { return _this_1._sign(txs); }, broadcast: function (options) {
                return this.sign()
                    // @ts-ignore
                    .then(function (txs) { return _this.broadcast(txs, options); });
            } });
    };
    Signer.prototype._validate = function (toSign) {
        var signerTxs = Array.isArray(toSign) ? toSign : [toSign];
        var validateTx = function (tx) { return validation_1.argsValidators[tx.type](tx); };
        var knownTxPredicate = function (type) {
            return Object.keys(validation_1.argsValidators).includes(String(type));
        };
        var unknownTxs = signerTxs.filter(function (_a) {
            var type = _a.type;
            return !knownTxPredicate(type);
        });
        var knownTxs = signerTxs.filter(function (_a) {
            var type = _a.type;
            return knownTxPredicate(type);
        });
        var invalidTxs = knownTxs
            .map(validateTx)
            .filter(function (_a) {
            var isValid = _a.isValid;
            return !isValid;
        });
        if (invalidTxs.length === 0 && unknownTxs.length === 0) {
            return { isValid: true, errors: [] };
        }
        else {
            return {
                isValid: false,
                errors: tslib_1.__spreadArrays(invalidTxs.map(function (_a) {
                    var transaction = _a.transaction, scope = _a.method, invalidFields = _a.invalidFields;
                    return "Validation error for " + scope + " transaction: " + JSON.stringify(transaction) + ". Invalid arguments: " + (invalidFields === null || invalidFields === void 0 ? void 0 : invalidFields.join(', '));
                }), unknownTxs.map(function (tx) {
                    return "Validation error for transaction " + JSON.stringify(tx) + ". Unknown transaction type: " + tx.type;
                })),
            };
        }
    };
    Signer.prototype._sign = function (toSign) {
        var validation = this._validate(toSign);
        if (validation.isValid) {
            return this._connectPromise.then(function (provider) { return provider.sign(toSign); });
        }
        else {
            var error = this._handleError(SignerError_1.ERRORS.API_ARGUMENTS, [validation.errors]);
            throw error;
        }
    };
    tslib_1.__decorate([
        decorators_1.ensureProvider
    ], Signer.prototype, "on", null);
    tslib_1.__decorate([
        decorators_1.ensureProvider
    ], Signer.prototype, "once", null);
    tslib_1.__decorate([
        decorators_1.ensureProvider
    ], Signer.prototype, "off", null);
    tslib_1.__decorate([
        decorators_1.ensureProvider,
        decorators_1.checkAuth
    ], Signer.prototype, "getBalance", null);
    tslib_1.__decorate([
        decorators_1.ensureProvider
    ], Signer.prototype, "login", null);
    tslib_1.__decorate([
        decorators_1.ensureProvider
    ], Signer.prototype, "logout", null);
    tslib_1.__decorate([
        decorators_1.catchProviderError
    ], Signer.prototype, "_sign", null);
    return Signer;
}());
exports.Signer = Signer;
// eslint-disable-next-line import/no-default-export
exports.default = Signer;
