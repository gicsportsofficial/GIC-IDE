import { TypedData, UserData, Provider, Balance, IssueArgs, TransferArgs, ReissueArgs, BurnArgs, LeaseArgs, CancelLeaseArgs, AliasArgs, MassTransferArgs, DataArgs, SetScriptArgs, SponsorshipArgs, ExchangeArgs, SetAssetScriptArgs, InvokeArgs, SignerTx, SignerIssueTx, SignerTransferTx, SignerReissueTx, SignerBurnTx, SignerLeaseTx, SignerExchangeTx, SignerCancelLeaseTx, SignerAliasTx, SignerMassTransferTx, SignerDataTx, SignerSponsorshipTx, SignerInvokeTx, SignerSetAssetScriptTx, SignerSetScriptTx, BroadcastOptions, SignerOptions, SignedTx, BroadcastedTx, AuthEvents, Handler } from './types';
import { ChainApi1stCall } from './types/api';
import { Transaction } from '@waves/ts-types';
export * from './types';
export declare class Signer {
    currentProvider: Provider | undefined;
    private _userData;
    private __connectPromise;
    private readonly _options;
    private readonly _networkBytePromise;
    private readonly _logger;
    private readonly _handleError;
    private get _connectPromise();
    private set _connectPromise(value);
    constructor(options?: Partial<SignerOptions>);
    on<EVENT extends keyof AuthEvents>(event: EVENT, handler: Handler<AuthEvents[EVENT]>): Signer;
    once<EVENT extends keyof AuthEvents>(event: EVENT, handler: Handler<AuthEvents[EVENT]>): Signer;
    off<EVENT extends keyof AuthEvents>(event: EVENT, handler: Handler<AuthEvents[EVENT]>): Signer;
    broadcast<T extends SignerTx>(toBroadcast: SignedTx<T>, options?: BroadcastOptions): Promise<BroadcastedTx<SignedTx<T>>>;
    broadcast<T extends SignerTx>(toBroadcast: Array<SignedTx<T>>, options?: BroadcastOptions): Promise<BroadcastedTx<SignedTx<T>[]>>;
    /**
     * Запросить байт сети
     */
    getNetworkByte(): Promise<number>;
    /**
     * Устанавливаем провайдер отвечающий за подпись
     * @param provider
     *
     * ```ts
     * import Signer from '@waves/signer';
     * import Provider from '@waves/seed-provider';
     *
     * const waves = new Signer();
     * waves.setProvider(new Provider('SEED'));
     * ```
     */
    setProvider(provider: Provider): Promise<void>;
    /**
     * Получаем список балансов пользователя (необходимо выполнить login перед использованием)
     * Basic usage example:
     *
     * ```ts
     * await waves.getBalance(); // Возвращает балансы пользователя
     * ```
     */
    getBalance(): Promise<Array<Balance>>;
    /**
     * Получаем информацию о пользователе
     *
     * ```ts
     * await waves.login(); // Авторизуемся. Возвращает адрес и публичный ключ
     * ```
     */
    login(): Promise<UserData>;
    /**
     * Вылогиниваемся из юзера
     */
    logout(): Promise<void>;
    /**
     * Подписываем сообщение пользователя (провайдер может устанавливать префикс)
     * @param message
     */
    signMessage(message: string | number): Promise<string>;
    /**
     * Подписываем типизированные данные
     * @param data
     */
    signTypedData(data: Array<TypedData>): Promise<string>;
    /**
     * Получаем список балансов в кторых можно платить комиссию
     */
    getSponsoredBalances(): Promise<Balance[]>;
    batch(tsx: SignerTx[]): {
        sign: () => Promise<SignedTx<SignerTx>[]>;
        broadcast: (opt?: BroadcastOptions | undefined) => Promise<BroadcastedTx<SignedTx<SignerTx>>[]>;
    };
    issue(data: IssueArgs): ChainApi1stCall<SignerIssueTx>;
    private readonly _issue;
    transfer(data: TransferArgs): ChainApi1stCall<SignerTransferTx>;
    private readonly _transfer;
    reissue(data: ReissueArgs): ChainApi1stCall<SignerReissueTx>;
    private readonly _reissue;
    burn(data: BurnArgs): ChainApi1stCall<SignerBurnTx>;
    private readonly _burn;
    lease(data: LeaseArgs): ChainApi1stCall<SignerLeaseTx>;
    private readonly _lease;
    exchange(data: ExchangeArgs): ChainApi1stCall<SignerExchangeTx>;
    private readonly _exchange;
    cancelLease(data: CancelLeaseArgs): ChainApi1stCall<SignerCancelLeaseTx>;
    private readonly _cancelLease;
    alias(data: AliasArgs): ChainApi1stCall<SignerAliasTx>;
    private readonly _alias;
    massTransfer(data: MassTransferArgs): ChainApi1stCall<SignerMassTransferTx>;
    private readonly _massTransfer;
    data(data: DataArgs): ChainApi1stCall<SignerDataTx>;
    private readonly _data;
    sponsorship(data: SponsorshipArgs): ChainApi1stCall<SignerSponsorshipTx>;
    private readonly _sponsorship;
    setScript(data: SetScriptArgs): ChainApi1stCall<SignerSetScriptTx>;
    private readonly _setScript;
    setAssetScript(data: SetAssetScriptArgs): ChainApi1stCall<SignerSetAssetScriptTx>;
    private readonly _setAssetScript;
    invoke(data: InvokeArgs): ChainApi1stCall<SignerInvokeTx>;
    private readonly _invoke;
    /**
     * Ожидаем подтверждения транзакции
     * @param tx             транзакция
     * @param confirmations  количество подтверждений которое ожидаем
     */
    waitTxConfirm<T extends Transaction>(tx: T, confirmations: number): Promise<T>;
    waitTxConfirm<T extends Transaction>(tx: T[], confirmations: number): Promise<T[]>;
    private _createPipelineAPI;
    private _validate;
    private _sign;
}
export default Signer;
