export function isObject(obj) {
    if (typeof obj === "object" && obj !== null) {
        if (typeof Object.getPrototypeOf === "function") {
            const prototype = Object.getPrototypeOf(obj);
            return prototype === Object.prototype || prototype === null;
        }
        return Object.prototype.toString.call(obj) === "[object Object]";
    }
    return false;
}
export function toArray(data) {
    return Array.isArray(data) ? data : [data];
}
export function head(data) {
    return data[0];
}
export function wait(time) {
    return new Promise(resolve => {
        setTimeout(resolve, time);
    });
}
export function prop(key) {
    return data => data[key];
}
export const keys = (obj) => Object.keys(obj);
export const entries = (obj) => keys(obj).map(name => [name, obj[name]]);
export const values = (obj) => keys(obj).map(key => obj[key]);
export const assign = (target, merge) => {
    return entries(merge).reduce((acc, [key, value]) => {
        target[key] = value;
        return target;
    }, target);
};
export const deepAssign = (...objects) => objects.reduce((target, merge) => {
    keys(merge).forEach((key) => {
        if (Array.isArray(target[key]) && Array.isArray(merge[key])) {
            target[key] = Array.from(new Set(target[key].concat(merge[key])));
        }
        else if (isObject(target[key]) && isObject(merge[key])) {
            target[key] = deepAssign(target[key], merge[key]);
        }
        else {
            target[key] = merge[key];
        }
    });
    return target;
}, objects[0] || {});
export function map(process) {
    return list => list.map(process);
}
export function filter(process) {
    return list => list.filter(process);
}
export function indexBy(process, data) {
    return data.reduce((acc, item) => {
        acc[process(item)] = item;
        return acc;
    }, {});
}
export const uniq = (list) => {
    return keys(list.reduce((acc, item) => {
        if (item != null)
            acc[item] = item;
        return acc;
    }, Object.create(null)));
};
export function switchTransactionByType(choices) {
    return tx => choices[tx.type] && typeof choices[tx.type] === 'function' ? choices[tx.type](tx) : undefined;
}
export const pipe = (...args) => {
    return data => args.reduce((acc, item) => item(acc), data);
};
//# sourceMappingURL=utils.js.map