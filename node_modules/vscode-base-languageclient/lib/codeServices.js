/* --------------------------------------------------------------------------------------------
 * Copyright (c) 2017 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
const code = require("vscode");
const types = require("vscode-languageserver-types");
const proto = require("./protocol");
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
function asDocument(document) {
    const uri = document.uri.toString();
    const { languageId, version } = document;
    const content = document.getText();
    return types.TextDocument.create(uri, languageId, version, content);
}
function createWorkspace(c2p) {
    const rootPath = code.workspace.rootPath || null;
    const rootUri = rootPath ? code.Uri.file(rootPath).toString() : null;
    const onDidOpenTextDocumentEmitter = new vscode_jsonrpc_1.Emitter();
    const onDidOpenTextDocument = onDidOpenTextDocumentEmitter.event;
    code.workspace.onDidOpenTextDocument(document => {
        onDidOpenTextDocumentEmitter.fire(asDocument(document));
    });
    const onDidCloseTextDocumentEmitter = new vscode_jsonrpc_1.Emitter();
    const onDidCloseTextDocument = onDidCloseTextDocumentEmitter.event;
    code.workspace.onDidCloseTextDocument(document => {
        onDidCloseTextDocumentEmitter.fire(asDocument(document));
    });
    const onDidChangeTextDocumentEmitter = new vscode_jsonrpc_1.Emitter();
    const onDidChangeTextDocument = onDidChangeTextDocumentEmitter.event;
    code.workspace.onDidChangeTextDocument(event => {
        const params = c2p.asChangeTextDocumentParams(event);
        onDidChangeTextDocumentEmitter.fire(params);
    });
    return {
        /*capabilities: {
            applyEdit: true,
            workspaceEdit: {
                documentChanges: true
            }
        },
        synchronization: {
            didSave: true,
            willSave: true,
            willSaveWaitUntil: true
        },*/
        rootPath,
        rootUri,
        get textDocuments() {
            return code.workspace.textDocuments.map(asDocument);
        },
        onDidOpenTextDocument,
        onDidCloseTextDocument,
        onDidChangeTextDocument,
    };
}
exports.createWorkspace = createWorkspace;
function createLanguages(p2c, c2p) {
    function match(selector, document) {
        const uri = p2c.asUri(document.uri);
        const codeDocument = {
            uri,
            fileName: uri.fsPath,
            languageId: document.languageId
        };
        return code.languages.match(selector, codeDocument) != 0;
    }
    function createDiagnosticCollection(name) {
        const collection = code.languages.createDiagnosticCollection(name);
        return {
            set: (uri, diagnostics) => {
                const codeUri = p2c.asUri(uri);
                const uriDiagnostics = p2c.asDiagnostics(diagnostics);
                collection.set(codeUri, uriDiagnostics);
            },
            dispose: () => collection.dispose()
        };
    }
    function registerCompletionItemProvider(selector, provider, ...triggerCharacters) {
        return code.languages.registerCompletionItemProvider(selector, {
            provideCompletionItems: (codeDocument, codePosition, token) => {
                const params = c2p.asTextDocumentPositionParams(codeDocument, codePosition);
                return provider.provideCompletionItems(params, token).then(result => p2c.asCompletionResult(result));
            },
            resolveCompletionItem: provider.resolveCompletionItem ? (codeItem, token) => {
                const item = c2p.asCompletionItem(codeItem);
                return provider.resolveCompletionItem(item, token).then(result => p2c.asCompletionItem(result));
            } : undefined
        }, ...triggerCharacters);
    }
    function registerHoverProvider(selector, provider) {
        return code.languages.registerHoverProvider(selector, {
            provideHover: (codeDocument, codePosition, token) => {
                const params = c2p.asTextDocumentPositionParams(codeDocument, codePosition);
                return provider.provideHover(params, token).then(result => p2c.asHover(result));
            }
        });
    }
    return {
        completion: {
            completionItem: {
                snippetSupport: true
            }
        },
        match,
        createDiagnosticCollection,
        registerCompletionItemProvider,
        registerHoverProvider,
    };
}
exports.createLanguages = createLanguages;
// Commands
function createCommands() {
    function registerCommand(command, callback, thisArg) {
        return code.commands.registerCommand(command, callback, thisArg);
    }
    return {
        registerCommand
    };
}
exports.createCommands = createCommands;
// Window
function createWindow() {
    function showMessage(type, message, ...actions) {
        let messageFunc;
        switch (type) {
            case proto.MessageType.Error:
                messageFunc = code.window.showErrorMessage;
                break;
            case proto.MessageType.Warning:
                messageFunc = code.window.showWarningMessage;
                break;
            case proto.MessageType.Info:
                messageFunc = code.window.showInformationMessage;
                break;
            default:
                messageFunc = code.window.showInformationMessage;
        }
        return messageFunc(message, ...actions);
    }
    function createOutputChannel(name) {
        return code.window.createOutputChannel(name);
    }
    return {
        showMessage,
        createOutputChannel
    };
}
exports.createWindow = createWindow;
