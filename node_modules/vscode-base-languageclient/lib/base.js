/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
exports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
exports.ResponseError = vscode_jsonrpc_1.ResponseError;
exports.RequestType = vscode_jsonrpc_1.RequestType;
exports.RequestType0 = vscode_jsonrpc_1.RequestType0;
exports.NotificationType = vscode_jsonrpc_1.NotificationType;
exports.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
const protocol_1 = require("./protocol");
exports.InitializeError = protocol_1.InitializeError;
const is = require("./utils/is");
const async_1 = require("./utils/async");
const UUID = require("./utils/uuid");
__export(require("vscode-languageserver-types"));
__export(require("./protocol"));
/**
 * An action to be performed when the connection is producing errors.
 */
var ErrorAction;
(function (ErrorAction) {
    /**
     * Continue running the server.
     */
    ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
    /**
     * Shutdown the server.
     */
    ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));
/**
 * An action to be performed when the connection to a server got closed.
 */
var CloseAction;
(function (CloseAction) {
    /**
     * Don't restart the server. The connection stays closed.
     */
    CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
    /**
     * Restart the server.
     */
    CloseAction[CloseAction["Restart"] = 2] = "Restart";
})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));
class DefaultErrorHandler {
    constructor(name, client) {
        this.name = name;
        this.client = client;
        this.restarts = [];
    }
    error(_error, _message, count) {
        if (count && count <= 3) {
            return ErrorAction.Continue;
        }
        return ErrorAction.Shutdown;
    }
    closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length < 5) {
            return CloseAction.Restart;
        }
        else {
            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1000) {
                if (this.client.window) {
                    this.client.window.showMessage(protocol_1.MessageType.Error, `The ${this.name} server crashed 5 times in the last 3 minutes. The server will not be restarted.`);
                }
                return CloseAction.DoNotRestart;
            }
            else {
                this.restarts.shift();
                return CloseAction.Restart;
            }
        }
    }
}
var RevealOutputChannelOn;
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
var State;
(function (State) {
    State[State["Stopped"] = 1] = "Stopped";
    State[State["Running"] = 2] = "Running";
})(State = exports.State || (exports.State = {}));
var ClientState;
(function (ClientState) {
    ClientState[ClientState["Initial"] = 0] = "Initial";
    ClientState[ClientState["Starting"] = 1] = "Starting";
    ClientState[ClientState["StartFailed"] = 2] = "StartFailed";
    ClientState[ClientState["Running"] = 3] = "Running";
    ClientState[ClientState["Stopping"] = 4] = "Stopping";
    ClientState[ClientState["Stopped"] = 5] = "Stopped";
})(ClientState || (ClientState = {}));
class DocumentNotifiactions {
    constructor(_client, _event, _type, _createParams, _selectorFilter) {
        this._client = _client;
        this._event = _event;
        this._type = _type;
        this._createParams = _createParams;
        this._selectorFilter = _selectorFilter;
        this._selectors = new Map();
    }
    static textDocumentFilter(languages, selectors, textDocument) {
        for (const selector of selectors) {
            if (languages.match(selector, textDocument)) {
                return true;
            }
        }
        return false;
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._event(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(data) {
        if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
            this._client.sendNotification(this._type, this._createParams(data));
            this.notificationSent(data);
        }
    }
    notificationSent(_data) {
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        if (this._listener) {
            this._listener.dispose();
        }
    }
}
class DidOpenTextDocumentFeature extends DocumentNotifiactions {
    constructor(client, _syncedDocuments) {
        super(client, client.workspace.onDidOpenTextDocument, protocol_1.DidOpenTextDocumentNotification.type, (textDocument) => {
            const { uri, languageId, version } = textDocument;
            const text = textDocument.getText();
            return {
                textDocument: {
                    uri, languageId, version, text
                }
            };
        }, (selectors, data) => DocumentNotifiactions.textDocumentFilter(client.languages, selectors, data));
        this._syncedDocuments = _syncedDocuments;
    }
    register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let documentSelector = data.registerOptions.documentSelector;
        this._client.workspace.textDocuments.forEach((textDocument) => {
            let uri = textDocument.uri;
            if (!textDocument || this._syncedDocuments.has(uri)) {
                return;
            }
            if (this._client.languages.match(documentSelector, textDocument)) {
                this._client.sendNotification(this._type, this._createParams(textDocument));
                this._syncedDocuments.set(uri, textDocument);
            }
        });
    }
    notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.set(textDocument.uri, textDocument);
    }
}
class DidCloseTextDocumentFeature extends DocumentNotifiactions {
    constructor(client, _syncedDocuments) {
        super(client, client.workspace.onDidCloseTextDocument, protocol_1.DidCloseTextDocumentNotification.type, (textDocument) => {
            return {
                textDocument: {
                    uri: textDocument.uri
                }
            };
        }, (selectors, data) => DocumentNotifiactions.textDocumentFilter(client.languages, selectors, data));
        this._syncedDocuments = _syncedDocuments;
    }
    notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.delete(textDocument.uri);
    }
    unregister(id) {
        let selector = this._selectors.get(id);
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
            if (this._client.languages.match(selector, textDocument) && !this._selectorFilter(selectors, textDocument)) {
                this._client.sendNotification(this._type, this._createParams(textDocument));
                this._syncedDocuments.delete(textDocument.uri);
            }
        });
    }
}
class DidChangeTextDocumentFeature {
    constructor(_client) {
        this._client = _client;
        this._changeData = new Map();
        this._forcingDelivery = false;
        this._workspace = _client.workspace;
        this._languages = _client.languages;
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
            documentSelector: data.registerOptions.documentSelector,
            syncKind: data.registerOptions.syncKind
        });
    }
    callback(event) {
        for (const changeData of this._changeData.values()) {
            if (this._languages.match(changeData.documentSelector, event.textDocument)) {
                if (changeData.syncKind === protocol_1.TextDocumentSyncKind.Incremental) {
                    this.sendDidChangeTextDocumentNotification(event.textDocument, event.contentChanges);
                }
                else if (changeData.syncKind === protocol_1.TextDocumentSyncKind.Full) {
                    if (this._changeDelayer) {
                        if (this._changeDelayer.uri !== event.textDocument.uri) {
                            // Use this force delivery to track boolean state. Otherwise we might call two times.
                            this.forceDelivery();
                            this._changeDelayer.uri = event.textDocument.uri;
                        }
                        this._changeDelayer.delayer.trigger(() => {
                            this.sendDidChangeTextDocumentNotification(event.textDocument);
                        });
                    }
                    else {
                        this._changeDelayer = {
                            uri: event.textDocument.uri,
                            delayer: new async_1.Delayer(200)
                        };
                        this._changeDelayer.delayer.trigger(() => {
                            this.sendDidChangeTextDocumentNotification(event.textDocument);
                        }, -1);
                    }
                }
            }
        }
    }
    sendDidChangeTextDocumentNotification(textDocument, contentChanges = [{ text: textDocument.getText() }]) {
        this._client.sendNotification(protocol_1.DidChangeTextDocumentNotification.type, {
            textDocument: {
                uri: textDocument.uri,
                version: textDocument.version
            },
            contentChanges
        });
    }
    unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    forceDelivery() {
        if (this._forcingDelivery || !this._changeDelayer) {
            return;
        }
        try {
            this._forcingDelivery = true;
            this._changeDelayer.delayer.forceDelivery();
        }
        finally {
            this._forcingDelivery = false;
        }
    }
}
class WillSaveWaitUntilFeature {
    constructor(_client) {
        this._client = _client;
        this._selectors = new Map();
        this.workspace = _client.workspace;
        this.languages = _client.languages;
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(event) {
        if (DocumentNotifiactions.textDocumentFilter(this.languages, this._selectors.values(), event.textDocument)) {
            event.waitUntil(this._client.sendRequest(protocol_1.WillSaveTextDocumentWaitUntilRequest.type, {
                textDocument: { uri: event.textDocument.uri },
                reason: event.reason
            }));
        }
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
}
class DidSaveTextDocumentFeature extends DocumentNotifiactions {
    constructor(client) {
        super(client, client.workspace.onDidSaveTextDocument, protocol_1.DidSaveTextDocumentNotification.type, (textDocument) => {
            let result = {
                textDocument: {
                    uri: textDocument.uri,
                    version: textDocument.version
                }
            };
            if (this._includeText) {
                result.text = textDocument.getText();
            }
            return result;
        }, (selectors, data) => DocumentNotifiactions.textDocumentFilter(client.languages, selectors, data));
    }
    register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
    }
}
class LanguageFeature {
    constructor(_createProvider) {
        this._createProvider = _createProvider;
        this._providers = new Map();
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let provider = this._createProvider(data.registerOptions);
        if (provider) {
            this._providers.set(data.id, provider);
        }
    }
    unregister(id) {
        let provider = this._providers.get(id);
        if (provider) {
            provider.dispose();
        }
    }
    dispose() {
        this._providers.forEach((value) => {
            value.dispose();
        });
    }
}
class ExecuteCommandFeature {
    constructor(_client, _logger) {
        this._client = _client;
        this._logger = _logger;
        this._commands = new Map();
    }
    register(data) {
        if (data.registerOptions.commands) {
            let disposeables = [];
            for (const command of data.registerOptions.commands) {
                disposeables.push(this._client.commands.registerCommand(command, (...args) => {
                    let params = {
                        command,
                        arguments: args
                    };
                    this._client.sendRequest(protocol_1.ExecuteCommandRequest.type, params).then(undefined, (error) => { this._logger(protocol_1.ExecuteCommandRequest.type, error); });
                }));
            }
            this._commands.set(data.id, disposeables);
        }
    }
    unregister(id) {
        let disposeables = this._commands.get(id);
        if (disposeables) {
            disposeables.forEach(disposable => disposable.dispose());
        }
    }
    dispose() {
        this._commands.forEach((value) => {
            value.forEach(disposable => disposable.dispose());
        });
    }
}
class BaseLanguageClient {
    constructor(options) {
        this._registeredHandlers = new Map();
        this._name = options.name;
        this._id = options.id || options.name.toLowerCase();
        this.languages = options.services.languages;
        this.workspace = options.services.workspace;
        this.commands = options.services.commands;
        this.window = options.services.window;
        this.connectionProvider = options.connectionProvider;
        const clientOptions = options.clientOptions;
        this._clientOptions = __assign({}, clientOptions, { documentSelector: clientOptions.documentSelector || [], synchronize: clientOptions.synchronize || {}, outputChannelName: clientOptions.outputChannelName || this._name, revealOutputChannelOn: clientOptions.revealOutputChannelOn || RevealOutputChannelOn.Error, errorHandler: clientOptions.errorHandler || new DefaultErrorHandler(this._name, this) });
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this.state = ClientState.Initial;
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        this._outputChannel = undefined;
        this._listeners = undefined;
        this._providers = undefined;
        this._diagnostics = undefined;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onReady = new Promise((resolve, reject) => {
            this._onReadyCallbacks = { resolve, reject };
        });
        this._telemetryEmitter = new vscode_jsonrpc_1.Emitter();
        this._stateChangeEmitter = new vscode_jsonrpc_1.Emitter();
        this._tracer = {
            log: (message, data) => {
                this.logTrace(message, data);
            }
        };
    }
    get state() {
        return this._state;
    }
    set state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
        }
    }
    getPublicState() {
        if (this.state === ClientState.Running) {
            return State.Running;
        }
        else {
            return State.Stopped;
        }
    }
    sendRequest(type, ...params) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            return this._resolvedConnection.sendRequest(type, ...params);
        }
        catch (error) {
            this.error(`Sending request ${is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onRequest(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.onRequest(type, handler);
        }
        catch (error) {
            this.error(`Registering request handler ${is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    sendNotification(type, params) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            this._resolvedConnection.sendNotification(type, params);
        }
        catch (error) {
            this.error(`Sending notification ${is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onNotification(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.onNotification(type, handler);
        }
        catch (error) {
            this.error(`Registering notification handler ${is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    get onTelemetry() {
        return this._telemetryEmitter.event;
    }
    get onDidChangeState() {
        return this._stateChangeEmitter.event;
    }
    get outputChannel() {
        if (!this._outputChannel && this.window && this.window.createOutputChannel) {
            this._outputChannel = this.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
    }
    get diagnostics() {
        return this._diagnostics;
    }
    createDefaultErrorHandler() {
        return new DefaultErrorHandler(this._name, this);
    }
    set trace(value) {
        this._trace = value;
        this.onReady().then(() => {
            this.resolveConnection().then((connection) => {
                connection.trace(value, this._tracer);
            });
        }, () => {
        });
    }
    data2String(data) {
        if (data instanceof vscode_jsonrpc_1.ResponseError) {
            const responseError = data;
            return `  Message: ${responseError.message}\n  Code: ${responseError.code} ${responseError.data ? '\n' + responseError.data.toString() : ''}`;
        }
        if (data instanceof Error) {
            if (is.string(data.stack)) {
                return data.stack;
            }
            return data.message;
        }
        if (is.string(data)) {
            return data;
        }
        return data.toString();
    }
    info(message, data) {
        const outputChannel = this.outputChannel;
        if (outputChannel) {
            outputChannel.appendLine(`[Info  - ${(new Date().toLocaleTimeString())}] ${message}`);
            if (data) {
                outputChannel.appendLine(this.data2String(data));
            }
            if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
                outputChannel.show(true);
            }
        }
    }
    warn(message, data) {
        const outputChannel = this.outputChannel;
        if (outputChannel) {
            outputChannel.appendLine(`[Warn  - ${(new Date().toLocaleTimeString())}] ${message}`);
            if (data) {
                outputChannel.appendLine(this.data2String(data));
            }
            if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
                outputChannel.show(true);
            }
        }
    }
    error(message, data) {
        const outputChannel = this.outputChannel;
        if (outputChannel) {
            outputChannel.appendLine(`[Error - ${(new Date().toLocaleTimeString())}] ${message}`);
            if (data) {
                outputChannel.appendLine(this.data2String(data));
            }
            if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
                outputChannel.show(true);
            }
        }
    }
    logTrace(message, data) {
        const outputChannel = this.outputChannel;
        if (outputChannel) {
            outputChannel.appendLine(`[Trace - ${(new Date().toLocaleTimeString())}] ${message}`);
            if (data) {
                outputChannel.appendLine(this.data2String(data));
            }
            outputChannel.show(true);
        }
    }
    needsStart() {
        return this.state === ClientState.Initial || this.state === ClientState.Stopping || this.state === ClientState.Stopped;
    }
    needsStop() {
        return this.state === ClientState.Starting || this.state === ClientState.Running;
    }
    onReady() {
        return this._onReady;
    }
    isConnectionActive() {
        return this.state === ClientState.Running && !!this._resolvedConnection;
    }
    start() {
        this._listeners = [];
        this._providers = [];
        // If we restart then the diagnostics collection is reused.
        if (!this._diagnostics && this.languages.createDiagnosticCollection) {
            this._diagnostics = this.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName);
        }
        this.state = ClientState.Starting;
        this.resolveConnection().then((connection) => {
            connection.onLogMessage((message) => {
                switch (message.type) {
                    case protocol_1.MessageType.Error:
                        this.error(message.message);
                        break;
                    case protocol_1.MessageType.Warning:
                        this.warn(message.message);
                        break;
                    case protocol_1.MessageType.Info:
                        this.info(message.message);
                        break;
                    default: {
                        if (this.outputChannel) {
                            this.outputChannel.appendLine(message.message);
                        }
                    }
                }
            });
            const window = this.window;
            if (window) {
                connection.onShowMessage((message) => window.showMessage(message.type, message.message));
                connection.onRequest(protocol_1.ShowMessageRequest.type, (params) => {
                    const actions = params.actions || [];
                    return window.showMessage(params.type, params.message, ...actions);
                });
            }
            connection.onTelemetry((data) => {
                this._telemetryEmitter.fire(data);
            });
            this.initRegistrationHandlers(connection);
            connection.listen();
            // Error is handled in the intialize call.
            this.initialize(connection).then(undefined, () => { });
        }, (error) => {
            this.state = ClientState.StartFailed;
            this._onReadyCallbacks.reject(error);
            this.error('Starting client failed', error);
            if (this.window) {
                this.window.showMessage(protocol_1.MessageType.Error, `Couldn't start client ${this._name}`);
            }
        });
        return vscode_jsonrpc_1.Disposable.create(() => {
            if (this.needsStop()) {
                this.stop();
            }
        });
    }
    resolveConnection() {
        if (!this._connectionPromise) {
            this._connectionPromise = this.createConnection();
        }
        return this._connectionPromise;
    }
    createClientCapabilities() {
        return {
            workspace: __assign({}, this.workspace.capabilities, { didChangeConfiguration: {
                    dynamicRegistration: false
                }, didChangeWatchedFiles: {
                    dynamicRegistration: false
                }, symbol: {
                    dynamicRegistration: true
                }, executeCommand: {
                    dynamicRegistration: true
                } }),
            textDocument: {
                synchronization: __assign({}, this.workspace.synchronization, { dynamicRegistration: true }),
                completion: __assign({}, this.languages.completion, { dynamicRegistration: true }),
                hover: {
                    dynamicRegistration: true
                },
                signatureHelp: {
                    dynamicRegistration: true
                },
                references: {
                    dynamicRegistration: true
                },
                documentHighlight: {
                    dynamicRegistration: true
                },
                documentSymbol: {
                    dynamicRegistration: true
                },
                formatting: {
                    dynamicRegistration: true
                },
                rangeFormatting: {
                    dynamicRegistration: true
                },
                onTypeFormatting: {
                    dynamicRegistration: true
                },
                definition: {
                    dynamicRegistration: true
                },
                codeAction: {
                    dynamicRegistration: true
                },
                codeLens: {
                    dynamicRegistration: true
                },
                documentLink: {
                    dynamicRegistration: true
                },
                rename: {
                    dynamicRegistration: true
                }
            }
        };
    }
    initialize(connection) {
        this.refreshTrace(connection, false);
        let initOption = this._clientOptions.initializationOptions;
        const rootPath = this.workspace && this.workspace.rootPath || null;
        const rootUri = this.workspace && this.workspace.rootUri || null;
        const clientCapabilities = this.createClientCapabilities();
        let initParams = {
            processId: process.pid,
            rootPath, rootUri,
            capabilities: clientCapabilities,
            initializationOptions: is.func(initOption) ? initOption() : initOption,
            trace: vscode_jsonrpc_1.Trace.toString(this._trace)
        };
        return connection.initialize(initParams).then((result) => {
            this._resolvedConnection = connection;
            this.state = ClientState.Running;
            this._capabilites = result.capabilities;
            connection.onDiagnostics(params => this.handleDiagnostics(params));
            // backward compatibility
            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));
            connection.onRequest(protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));
            // backward compatibility
            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));
            connection.onRequest(protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));
            connection.onRequest(protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));
            connection.sendNotification(protocol_1.InitializedNotification.type, {});
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            if (this._clientOptions.documentSelector) {
                let selectorOptions = { documentSelector: this._clientOptions.documentSelector };
                let textDocumentSyncOptions = undefined;
                if (is.number(this._capabilites.textDocumentSync) && this._capabilites.textDocumentSync !== protocol_1.TextDocumentSyncKind.None) {
                    textDocumentSyncOptions = {
                        openClose: true,
                        change: this._capabilites.textDocumentSync,
                        save: {
                            includeText: false
                        }
                    };
                }
                else if (this._capabilites.textDocumentSync !== void 0 && this._capabilites.textDocumentSync !== null) {
                    textDocumentSyncOptions = this._capabilites.textDocumentSync;
                }
                if (textDocumentSyncOptions) {
                    if (textDocumentSyncOptions.openClose) {
                        this.registerHandler(protocol_1.DidOpenTextDocumentNotification.type.method, { id: UUID.generateUuid(), registerOptions: selectorOptions });
                        this.registerHandler(protocol_1.DidCloseTextDocumentNotification.type.method, { id: UUID.generateUuid(), registerOptions: selectorOptions });
                    }
                    if (textDocumentSyncOptions.change !== protocol_1.TextDocumentSyncKind.None) {
                        this.registerHandler(protocol_1.DidChangeTextDocumentNotification.type.method, {
                            id: UUID.generateUuid(),
                            registerOptions: Object.assign({}, selectorOptions, { syncKind: textDocumentSyncOptions.change })
                        });
                    }
                    if (textDocumentSyncOptions.willSave) {
                        this.registerHandler(protocol_1.WillSaveTextDocumentNotification.type.method, { id: UUID.generateUuid(), registerOptions: selectorOptions });
                    }
                    if (textDocumentSyncOptions.willSaveWaitUntil) {
                        this.registerHandler(protocol_1.WillSaveTextDocumentWaitUntilRequest.type.method, { id: UUID.generateUuid(), registerOptions: selectorOptions });
                    }
                    if (textDocumentSyncOptions.save) {
                        this.registerHandler(protocol_1.DidSaveTextDocumentNotification.type.method, {
                            id: UUID.generateUuid(),
                            registerOptions: Object.assign({}, selectorOptions, { includeText: !!textDocumentSyncOptions.save.includeText })
                        });
                    }
                }
            }
            this.hookCapabilities(connection);
            this._onReadyCallbacks.resolve();
            return result;
        }, (error) => {
            if (this._clientOptions.initializationFailedHandler) {
                if (this._clientOptions.initializationFailedHandler(error)) {
                    this.initialize(connection);
                }
                else {
                    this.stop();
                    this._onReadyCallbacks.reject(error);
                }
            }
            else if (error instanceof vscode_jsonrpc_1.ResponseError && error.data && error.data.retry && this.window) {
                this.window.showMessage(protocol_1.MessageType.Error, error.message, { title: 'Retry', id: "retry" }).then(item => {
                    if (item && item.id === 'retry') {
                        this.initialize(connection);
                    }
                    else {
                        this.stop();
                        this._onReadyCallbacks.reject(error);
                    }
                });
            }
            else {
                if (error && error.message && this.window) {
                    this.window.showMessage(protocol_1.MessageType.Error, error.message);
                }
                this.error('Server initialization failed.', error);
                this.stop();
                this._onReadyCallbacks.reject(error);
            }
        });
    }
    stop() {
        if (!this._connectionPromise) {
            this.state = ClientState.Stopped;
            return Promise.resolve();
        }
        this.state = ClientState.Stopping;
        this.cleanUp();
        // unkook listeners
        return this.resolveConnection().then(connection => {
            return connection.shutdown().then(() => {
                connection.exit();
                connection.dispose();
                this.state = ClientState.Stopped;
                this._connectionPromise = undefined;
                this._resolvedConnection = undefined;
                // Remove all markers
            });
        });
    }
    cleanUp(diagnostics = true) {
        if (this._listeners) {
            this._listeners.forEach(listener => listener.dispose());
            this._listeners = undefined;
        }
        if (this._providers) {
            this._providers.forEach(provider => provider.dispose());
            this._providers = undefined;
        }
        if (diagnostics && this._diagnostics) {
            this._diagnostics.dispose();
            this._diagnostics = undefined;
        }
        for (const handler of Array.from(this._registeredHandlers.values())) {
            handler.dispose();
        }
        this._registeredHandlers.clear();
    }
    notifyFileEvent(event) {
        this._fileEvents.push(event);
        this._fileEventDelayer.trigger(() => {
            this.onReady().then(() => {
                this.resolveConnection().then(connection => {
                    if (this.isConnectionActive()) {
                        connection.didChangeWatchedFiles({ changes: this._fileEvents });
                    }
                    this._fileEvents = [];
                });
            }, (error) => {
                this.error(`Notify file events failed.`, error);
            });
        });
    }
    forceDocumentSync() {
        this._registeredHandlers.get(protocol_1.DidChangeTextDocumentNotification.type.method).forceDelivery();
    }
    handleDiagnostics(params) {
        if (!this._diagnostics) {
            return;
        }
        this._diagnostics.set(params.uri, params.diagnostics);
    }
    createConnection() {
        const errorHandler = this.handleConnectionError.bind(this);
        const closeHandler = this.handleConnectionClosed.bind(this);
        return this.connectionProvider.get(errorHandler, closeHandler, this.outputChannel);
    }
    handleConnectionClosed() {
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.state === ClientState.Stopping || this.state === ClientState.Stopped) {
            return;
        }
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        let action = this._clientOptions.errorHandler.closed();
        if (action === CloseAction.DoNotRestart) {
            this.error('Connection to server got closed. Server will not be restarted.');
            this.state = ClientState.Stopped;
            this.cleanUp();
        }
        else if (action === CloseAction.Restart) {
            this.info('Connection to server got closed. Server will restart.');
            this.cleanUp(false);
            this.state = ClientState.Initial;
            this.start();
        }
    }
    handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === ErrorAction.Shutdown) {
            this.error('Connection to server is erroring. Shutting down server.');
            this.stop();
        }
    }
    hookConfigurationChanged(connection) {
        if (!this._clientOptions.synchronize.configurationSection || !this.workspace.configurations) {
            return;
        }
        this.workspace.configurations.onDidChangeConfiguration(() => this.onDidChangeConfiguration(connection), this, this._listeners);
        this.onDidChangeConfiguration(connection);
    }
    refreshTrace(connection, sendNotification = false) {
        const configurations = this.workspace.configurations;
        if (configurations) {
            const config = configurations.getConfiguration(this._id);
            this._trace = !!config ? vscode_jsonrpc_1.Trace.fromString(config.get('trace.server', 'off')) : vscode_jsonrpc_1.Trace.Off;
            connection.trace(this._trace, this._tracer, sendNotification);
        }
    }
    onDidChangeConfiguration(connection) {
        this.refreshTrace(connection, true);
        let keys;
        let configurationSection = this._clientOptions.synchronize.configurationSection;
        if (is.string(configurationSection)) {
            keys = [configurationSection];
        }
        else if (is.stringArray(configurationSection)) {
            keys = configurationSection;
        }
        if (keys) {
            if (this.isConnectionActive()) {
                connection.didChangeConfiguration({ settings: this.extractSettingsInformation(keys) });
            }
        }
    }
    extractSettingsInformation(keys) {
        function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
                let obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf('.');
            let config = null;
            if (index >= 0) {
                config = this.workspace.configurations.getConfiguration(key.substr(0, index)).get(key.substr(index + 1));
            }
            else {
                config = this.workspace.configurations.getConfiguration(key);
            }
            if (config) {
                let path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = config;
            }
        }
        return result;
    }
    hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
            return;
        }
        let watchers;
        if (is.array(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        watchers.forEach(watcher => {
            watcher.onFileEvent(event => this.notifyFileEvent(event), null, this._listeners);
        });
    }
    initRegistrationHandlers(_connection) {
        const syncedDocuments = new Map();
        const logger = (type, error) => { this.logFailedRequest(type, error); };
        this._registeredHandlers.set(protocol_1.DidOpenTextDocumentNotification.type.method, new DidOpenTextDocumentFeature(this, syncedDocuments));
        this._registeredHandlers.set(protocol_1.DidChangeTextDocumentNotification.type.method, new DidChangeTextDocumentFeature(this));
        if (this.workspace.onWillSaveTextDocument) {
            this._registeredHandlers.set(protocol_1.WillSaveTextDocumentNotification.type.method, new DocumentNotifiactions(this, this.workspace.onWillSaveTextDocument, protocol_1.WillSaveTextDocumentNotification.type, event => ({
                textDocument: { uri: event.textDocument.uri },
                reason: event.reason
            }), (selectors, willSaveEvent) => DocumentNotifiactions.textDocumentFilter(this.languages, selectors, willSaveEvent.textDocument)));
            if (!!this.workspace.synchronization && this.workspace.synchronization.willSaveWaitUntil) {
                this._registeredHandlers.set(protocol_1.WillSaveTextDocumentWaitUntilRequest.type.method, new WillSaveWaitUntilFeature(this));
            }
        }
        if (this.workspace.onDidSaveTextDocument) {
            this._registeredHandlers.set(protocol_1.DidSaveTextDocumentNotification.type.method, new DidSaveTextDocumentFeature(this));
        }
        this._registeredHandlers.set(protocol_1.DidCloseTextDocumentNotification.type.method, new DidCloseTextDocumentFeature(this, syncedDocuments));
        if (this.languages.registerCompletionItemProvider) {
            this._registeredHandlers.set(protocol_1.CompletionRequest.type.method, new LanguageFeature((options) => this.createCompletionProvider(options)));
        }
        if (this.languages.registerHoverProvider) {
            this._registeredHandlers.set(protocol_1.HoverRequest.type.method, new LanguageFeature((options) => this.createHoverProvider(options)));
        }
        if (this.languages.registerSignatureHelpProvider) {
            this._registeredHandlers.set(protocol_1.SignatureHelpRequest.type.method, new LanguageFeature((options) => this.createSignatureHelpProvider(options)));
        }
        if (this.languages.registerDefinitionProvider) {
            this._registeredHandlers.set(protocol_1.DefinitionRequest.type.method, new LanguageFeature((options) => this.createDefinitionProvider(options)));
        }
        if (this.languages.registerReferenceProvider) {
            this._registeredHandlers.set(protocol_1.ReferencesRequest.type.method, new LanguageFeature((options) => this.createReferencesProvider(options)));
        }
        if (this.languages.registerDocumentHighlightProvider) {
            this._registeredHandlers.set(protocol_1.DocumentHighlightRequest.type.method, new LanguageFeature((options) => this.createDocumentHighlightProvider(options)));
        }
        if (this.languages.registerDocumentSymbolProvider) {
            this._registeredHandlers.set(protocol_1.DocumentSymbolRequest.type.method, new LanguageFeature((options) => this.createDocumentSymbolProvider(options)));
        }
        if (this.languages.registerWorkspaceSymbolProvider) {
            this._registeredHandlers.set(protocol_1.WorkspaceSymbolRequest.type.method, new LanguageFeature((options) => this.createWorkspaceSymbolProvider(options)));
        }
        if (this.languages.registerCodeActionsProvider) {
            this._registeredHandlers.set(protocol_1.CodeActionRequest.type.method, new LanguageFeature((options) => this.createCodeActionsProvider(options)));
        }
        if (this.languages.registerCodeLensProvider) {
            this._registeredHandlers.set(protocol_1.CodeLensRequest.type.method, new LanguageFeature((options) => this.createCodeLensProvider(options)));
        }
        if (this.languages.registerDocumentFormattingEditProvider) {
            this._registeredHandlers.set(protocol_1.DocumentFormattingRequest.type.method, new LanguageFeature((options) => this.createDocumentFormattingProvider(options)));
        }
        if (this.languages.registerDocumentRangeFormattingEditProvider) {
            this._registeredHandlers.set(protocol_1.DocumentRangeFormattingRequest.type.method, new LanguageFeature((options) => this.createDocumentRangeFormattingProvider(options)));
        }
        if (this.languages.registerOnTypeFormattingEditProvider) {
            this._registeredHandlers.set(protocol_1.DocumentOnTypeFormattingRequest.type.method, new LanguageFeature((options) => this.createDocumentOnTypeFormattingProvider(options)));
        }
        if (this.languages.registerRenameProvider) {
            this._registeredHandlers.set(protocol_1.RenameRequest.type.method, new LanguageFeature((options) => this.createRenameProvider(options)));
        }
        if (this.languages.registerDocumentLinkProvider) {
            this._registeredHandlers.set(protocol_1.DocumentLinkRequest.type.method, new LanguageFeature((options) => this.createDocumentLinkProvider(options)));
        }
        if (this.commands) {
            this._registeredHandlers.set(protocol_1.ExecuteCommandRequest.type.method, new ExecuteCommandFeature(this, logger));
        }
    }
    handleRegistrationRequest(params) {
        return new Promise((resolve, _reject) => {
            params.registrations.forEach((element) => {
                const handler = this._registeredHandlers.get(element.method);
                const options = element.registerOptions || {};
                options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;
                const data = {
                    id: element.id,
                    registerOptions: options
                };
                if (handler) {
                    handler.register(data);
                }
            });
            resolve();
        });
    }
    handleUnregistrationRequest(params) {
        return new Promise((resolve, _reject) => {
            params.unregisterations.forEach((element) => {
                const handler = this._registeredHandlers.get(element.method);
                if (handler) {
                    handler.unregister(element.id);
                }
            });
            resolve();
        });
    }
    handleApplyWorkspaceEdit(params) {
        if (!this.workspace.applyEdit) {
            return Promise.resolve({ applied: false });
        }
        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
        // However doing it here adds some safety since the server can lag more behind then an extension.
        let workspaceEdit = params.edit;
        let openTextDocuments = new Map();
        this.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri, document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
                if (change.textDocument.version && change.textDocument.version >= 0) {
                    let textDocument = openTextDocuments.get(change.textDocument.uri);
                    if (textDocument && textDocument.version !== change.textDocument.version) {
                        versionMismatch = true;
                        break;
                    }
                }
            }
        }
        if (versionMismatch) {
            return Promise.resolve({ applied: false });
        }
        return this.workspace.applyEdit(params.edit).then(applied => { return { applied }; });
    }
    ;
    registerHandler(method, data) {
        const handler = this._registeredHandlers.get(method);
        if (handler) {
            handler.register(data);
        }
    }
    hookCapabilities(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        if (!documentSelector) {
            return;
        }
        let selectorOptions = { documentSelector: documentSelector };
        if (this._capabilites.completionProvider) {
            let options = Object.assign({}, selectorOptions, this._capabilites.completionProvider);
            this.registerHandler(protocol_1.CompletionRequest.type.method, { id: UUID.generateUuid(), registerOptions: options });
        }
        if (this._capabilites.hoverProvider) {
            this.registerHandler(protocol_1.HoverRequest.type.method, { id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
        }
        if (this._capabilites.signatureHelpProvider) {
            let options = Object.assign({}, selectorOptions, this._capabilites.signatureHelpProvider);
            this.registerHandler(protocol_1.SignatureHelpRequest.type.method, { id: UUID.generateUuid(), registerOptions: options });
        }
        if (this._capabilites.definitionProvider) {
            this.registerHandler(protocol_1.DefinitionRequest.type.method, { id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
        }
        if (this._capabilites.referencesProvider) {
            this.registerHandler(protocol_1.ReferencesRequest.type.method, { id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
        }
        if (this._capabilites.documentHighlightProvider) {
            this.registerHandler(protocol_1.DocumentHighlightRequest.type.method, { id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
        }
        if (this._capabilites.documentSymbolProvider) {
            this.registerHandler(protocol_1.DocumentSymbolRequest.type.method, { id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
        }
        if (this._capabilites.workspaceSymbolProvider) {
            this.registerHandler(protocol_1.WorkspaceSymbolRequest.type.method, { id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
        }
        if (this._capabilites.codeActionProvider) {
            this.registerHandler(protocol_1.CodeActionRequest.type.method, { id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
        }
        if (this._capabilites.codeLensProvider) {
            let options = Object.assign({}, selectorOptions, this._capabilites.codeLensProvider);
            this.registerHandler(protocol_1.CodeLensRequest.type.method, { id: UUID.generateUuid(), registerOptions: options });
        }
        if (this._capabilites.documentFormattingProvider) {
            this.registerHandler(protocol_1.DocumentFormattingRequest.type.method, { id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
        }
        if (this._capabilites.documentRangeFormattingProvider) {
            this.registerHandler(protocol_1.DocumentRangeFormattingRequest.type.method, { id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
        }
        if (this._capabilites.documentOnTypeFormattingProvider) {
            let options = Object.assign({}, selectorOptions, this._capabilites.documentOnTypeFormattingProvider);
            this.registerHandler(protocol_1.DocumentOnTypeFormattingRequest.type.method, { id: UUID.generateUuid(), registerOptions: options });
        }
        if (this._capabilites.renameProvider) {
            this.registerHandler(protocol_1.RenameRequest.type.method, { id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
        }
        if (this._capabilites.documentLinkProvider) {
            let options = Object.assign({}, selectorOptions, this._capabilites.documentLinkProvider);
            this.registerHandler(protocol_1.DocumentLinkRequest.type.method, { id: UUID.generateUuid(), registerOptions: options });
        }
        if (this._capabilites.executeCommandProvider) {
            let options = Object.assign({}, this._capabilites.executeCommandProvider);
            this.registerHandler(protocol_1.ExecuteCommandRequest.type.method, { id: UUID.generateUuid(), registerOptions: options });
        }
    }
    logFailedRequest(type, error) {
        // If we get a request cancel don't log anything.
        if (error instanceof vscode_jsonrpc_1.ResponseError && error.code === vscode_jsonrpc_1.ErrorCodes.RequestCancelled) {
            return;
        }
        this.error(`Request ${type.method} failed.`, error);
    }
    createRequestHandler(type, onError) {
        return (params, token) => {
            return this.sendRequest(type, params, token).then((result) => result, (error) => {
                this.logFailedRequest(type, error);
                const result = onError ? onError(params, error) : null;
                return Promise.reject(result);
            });
        };
    }
    createCompletionProvider(options) {
        let triggerCharacters = options.triggerCharacters || [];
        return this.languages.registerCompletionItemProvider(options.documentSelector, {
            provideCompletionItems: this.createRequestHandler(protocol_1.CompletionRequest.type, () => []),
            resolveCompletionItem: options.resolveProvider ? this.createRequestHandler(protocol_1.CompletionResolveRequest.type, (params) => params) : undefined
        }, ...triggerCharacters);
    }
    createHoverProvider(options) {
        return this.languages.registerHoverProvider(options.documentSelector, {
            provideHover: this.createRequestHandler(protocol_1.HoverRequest.type)
        });
    }
    createSignatureHelpProvider(options) {
        let triggerCharacters = options.triggerCharacters || [];
        return this.languages.registerSignatureHelpProvider(options.documentSelector, {
            provideSignatureHelp: this.createRequestHandler(protocol_1.SignatureHelpRequest.type)
        }, ...triggerCharacters);
    }
    createDefinitionProvider(options) {
        return this.languages.registerDefinitionProvider(options.documentSelector, {
            provideDefinition: this.createRequestHandler(protocol_1.DefinitionRequest.type)
        });
    }
    createReferencesProvider(options) {
        return this.languages.registerReferenceProvider(options.documentSelector, {
            provideReferences: this.createRequestHandler(protocol_1.ReferencesRequest.type, () => [])
        });
    }
    createDocumentHighlightProvider(options) {
        return this.languages.registerDocumentHighlightProvider(options.documentSelector, {
            provideDocumentHighlights: this.createRequestHandler(protocol_1.DocumentHighlightRequest.type, () => [])
        });
    }
    createDocumentSymbolProvider(options) {
        return this.languages.registerDocumentSymbolProvider(options.documentSelector, {
            provideDocumentSymbols: this.createRequestHandler(protocol_1.DocumentSymbolRequest.type, () => [])
        });
    }
    createWorkspaceSymbolProvider(_options) {
        return this.languages.registerWorkspaceSymbolProvider({
            provideWorkspaceSymbols: this.createRequestHandler(protocol_1.WorkspaceSymbolRequest.type, () => [])
        });
    }
    createCodeActionsProvider(options) {
        return this.languages.registerCodeActionsProvider(options.documentSelector, {
            provideCodeActions: this.createRequestHandler(protocol_1.CodeActionRequest.type, () => [])
        });
    }
    createCodeLensProvider(options) {
        return this.languages.registerCodeLensProvider(options.documentSelector, {
            provideCodeLenses: this.createRequestHandler(protocol_1.CodeLensRequest.type, () => []),
            resolveCodeLens: options.resolveProvider ? this.createRequestHandler(protocol_1.CodeLensResolveRequest.type, (params) => params) : undefined
        });
    }
    createDocumentFormattingProvider(options) {
        return this.languages.registerDocumentFormattingEditProvider(options.documentSelector, {
            provideDocumentFormattingEdits: this.createRequestHandler(protocol_1.DocumentFormattingRequest.type, () => [])
        });
    }
    createDocumentRangeFormattingProvider(options) {
        return this.languages.registerDocumentRangeFormattingEditProvider(options.documentSelector, {
            provideDocumentRangeFormattingEdits: this.createRequestHandler(protocol_1.DocumentRangeFormattingRequest.type, () => [])
        });
    }
    createDocumentOnTypeFormattingProvider(options) {
        let moreTriggerCharacter = options.moreTriggerCharacter || [];
        return this.languages.registerOnTypeFormattingEditProvider(options.documentSelector, {
            provideOnTypeFormattingEdits: this.createRequestHandler(protocol_1.DocumentOnTypeFormattingRequest.type, () => [])
        }, options.firstTriggerCharacter, ...moreTriggerCharacter);
    }
    createRenameProvider(options) {
        return this.languages.registerRenameProvider(options.documentSelector, {
            provideRenameEdits: this.createRequestHandler(protocol_1.RenameRequest.type, (_, error) => new Error(error.message))
        });
    }
    createDocumentLinkProvider(options) {
        return this.languages.registerDocumentLinkProvider(options.documentSelector, {
            provideDocumentLinks: this.createRequestHandler(protocol_1.DocumentLinkRequest.type, (_, error) => new Error(error.message)),
            resolveDocumentLink: options.resolveProvider ? this.createRequestHandler(protocol_1.DocumentLinkResolveRequest.type, (_, error) => new Error(error.message)) : undefined
        });
    }
}
exports.BaseLanguageClient = BaseLanguageClient;
class SettingMonitor {
    constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    start() {
        if (this._client.workspace.configurations) {
            this._client.workspace.configurations.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
            this.onDidChangeConfiguration();
        }
        return vscode_jsonrpc_1.Disposable.create(() => {
            if (this._client.needsStop()) {
                this._client.stop();
            }
        });
    }
    onDidChangeConfiguration() {
        const configurations = this._client.workspace.configurations;
        let index = this._setting.indexOf('.');
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        let enabled = rest ? configurations.getConfiguration(primary).get(rest, false) : configurations.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start();
        }
        else if (!enabled && this._client.needsStop()) {
            this._client.stop();
        }
    }
}
exports.SettingMonitor = SettingMonitor;
