/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
const cp = require("child_process");
const base_1 = require("./base");
exports.InitializeError = base_1.InitializeError;
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
exports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
exports.ResponseError = vscode_jsonrpc_1.ResponseError;
exports.RequestType = vscode_jsonrpc_1.RequestType;
exports.RequestType0 = vscode_jsonrpc_1.RequestType0;
exports.NotificationType = vscode_jsonrpc_1.NotificationType;
exports.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
const vscode_uri_1 = require("vscode-uri");
const connection_1 = require("./connection");
const is = require("./utils/is");
const electron = require("./utils/electron");
const processes_1 = require("./utils/processes");
__export(require("vscode-languageserver-types"));
__export(require("./protocol"));
__export(require("./base"));
class ConsoleLogger {
    error(message) {
        console.error(message);
    }
    warn(message) {
        console.warn(message);
    }
    info(message) {
        console.info(message);
    }
    log(message) {
        console.log(message);
    }
}
var TransportKind;
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
    TransportKind[TransportKind["pipe"] = 2] = "pipe";
})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));
class NodeConnectionProvider {
    constructor(options) {
        this._serverOptions = options.serverOptions;
        this._encoding = options.stdioEncoding || 'utf8';
        this._forceDebug = options.forceDebug === void 0 ? false : options.forceDebug;
        this.workspace = options.workspace;
        this._childProcess = undefined;
    }
    get(errorHandler, closeHandler, outputChannel) {
        return this.createRPCConnection(outputChannel).then(messageConnection => {
            const connection = connection_1.createConnection(messageConnection, errorHandler, () => {
                closeHandler();
                this._childProcess = undefined;
            });
            const shutdown = connection.shutdown.bind(connection);
            connection.shutdown = () => {
                return shutdown().then(() => {
                    let toCheck = this._childProcess;
                    this._childProcess = undefined;
                    this.checkProcessDied(toCheck);
                });
            };
            return connection;
        });
    }
    createRPCConnection(outputChannel) {
        function getEnvironment(env) {
            if (!env) {
                return process.env;
            }
            let result = Object.create(null);
            Object.keys(process.env).forEach(key => result[key] = process.env[key]);
            Object.keys(env).forEach(key => result[key] = env[key]);
        }
        function startedInDebugMode() {
            let args = process.execArgv;
            if (args) {
                return args.some((arg) => /^--debug=?/.test(arg) || /^--debug-brk=?/.test(arg));
            }
            ;
            return false;
        }
        let encoding = this._encoding;
        let server = this._serverOptions;
        // We got a function.
        if (is.func(server)) {
            return server().then((result) => {
                let info = result;
                if (info.writer && info.reader) {
                    return this.createConnection(info.reader, info.writer);
                }
                else {
                    let cp = result;
                    return this.createConnection(cp.stdout, cp.stdin);
                }
            });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
            // We are under debugging. So use debug as well.
            if (typeof v8debug === 'object' || this._forceDebug || startedInDebugMode()) {
                json = runDebug.debug;
            }
            else {
                json = runDebug.run;
            }
        }
        else {
            json = {}; // server;
        }
        if (json.module) {
            let node = json;
            let transport = node.transport || TransportKind.stdio;
            if (node.runtime) {
                let args = [];
                let options = node.options || Object.create(null);
                if (options.execArgv) {
                    options.execArgv.forEach(element => args.push(element));
                }
                args.push(node.module);
                if (node.args) {
                    node.args.forEach(element => args.push(element));
                }
                let execOptions = Object.create(null);
                execOptions.cwd = options.cwd || this.rootPath;
                execOptions.env = getEnvironment(options.env);
                let pipeName = undefined;
                if (transport === TransportKind.ipc) {
                    // exec options not correctly typed in lib
                    execOptions.stdio = [null, null, null, 'ipc'];
                    args.push('--node-ipc');
                }
                else if (transport === TransportKind.stdio) {
                    args.push('--stdio');
                }
                else if (transport === TransportKind.pipe) {
                    pipeName = vscode_jsonrpc_1.generateRandomPipeName();
                    args.push(`--pipe=${pipeName}`);
                }
                if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                    let process = cp.spawn(node.runtime, args, execOptions);
                    if (!process || !process.pid) {
                        return Promise.reject(`Launching server using runtime ${node.runtime} failed.`);
                    }
                    this._childProcess = process;
                    if (outputChannel) {
                        process.stderr.on('data', data => outputChannel.append(is.string(data) ? data : data.toString(encoding)));
                    }
                    if (transport === TransportKind.ipc) {
                        if (outputChannel) {
                            process.stdout.on('data', data => outputChannel.append(is.string(data) ? data : data.toString(encoding)));
                        }
                        return Promise.resolve(this.createConnection(new vscode_jsonrpc_1.IPCMessageReader(process), new vscode_jsonrpc_1.IPCMessageWriter(process)));
                    }
                    else {
                        return Promise.resolve(this.createConnection(process.stdout, process.stdin));
                    }
                }
                else if (transport == TransportKind.pipe) {
                    return vscode_jsonrpc_1.createClientPipeTransport(pipeName).then((transport) => {
                        let process = cp.spawn(node.runtime, args, execOptions);
                        if (!process || !process.pid) {
                            return Promise.reject(`Launching server using runtime ${node.runtime} failed.`);
                        }
                        this._childProcess = process;
                        if (outputChannel) {
                            process.stderr.on('data', data => outputChannel.append(is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => outputChannel.append(is.string(data) ? data : data.toString(encoding)));
                        }
                        return transport.onConnected().then((protocol) => {
                            return this.createConnection(protocol[0], protocol[1]);
                        });
                    });
                }
            }
            else {
                let pipeName = undefined;
                return new Promise((resolve, reject) => {
                    let args = node.args && node.args.slice() || [];
                    if (transport === TransportKind.ipc) {
                        args.push('--node-ipc');
                    }
                    else if (transport === TransportKind.stdio) {
                        args.push('--stdio');
                    }
                    else if (transport === TransportKind.pipe) {
                        pipeName = vscode_jsonrpc_1.generateRandomPipeName();
                        args.push(`--pipe=${pipeName}`);
                    }
                    let options = node.options || Object.create(null);
                    options.execArgv = options.execArgv || [];
                    options.cwd = options.cwd || this.rootPath;
                    if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                        electron.fork(node.module, args || [], options, (error, cp) => {
                            if (error || !cp) {
                                reject(error);
                            }
                            else {
                                this._childProcess = cp;
                                if (outputChannel) {
                                    cp.stderr.on('data', data => outputChannel.append(is.string(data) ? data : data.toString(encoding)));
                                }
                                if (transport === TransportKind.ipc) {
                                    if (outputChannel) {
                                        cp.stdout.on('data', data => outputChannel.append(is.string(data) ? data : data.toString(encoding)));
                                    }
                                    resolve(this.createConnection(new vscode_jsonrpc_1.IPCMessageReader(this._childProcess), new vscode_jsonrpc_1.IPCMessageWriter(this._childProcess)));
                                }
                                else {
                                    resolve(this.createConnection(cp.stdout, cp.stdin));
                                }
                            }
                        });
                    }
                    else if (transport === TransportKind.pipe) {
                        vscode_jsonrpc_1.createClientPipeTransport(pipeName).then((transport) => {
                            electron.fork(node.module, args || [], options, (error, cp) => {
                                if (error || !cp) {
                                    reject(error);
                                }
                                else {
                                    this._childProcess = cp;
                                    if (outputChannel) {
                                        cp.stderr.on('data', data => outputChannel.append(is.string(data) ? data : data.toString(encoding)));
                                        cp.stdout.on('data', data => outputChannel.append(is.string(data) ? data : data.toString(encoding)));
                                    }
                                    transport.onConnected().then((protocol) => {
                                        resolve(this.createConnection(protocol[0], protocol[1]));
                                    });
                                }
                            });
                        });
                    }
                });
            }
        }
        else if (json.command) {
            let command = json;
            let options = command.options || {};
            options.cwd = options.cwd || this.rootPath;
            let process = cp.spawn(command.command, command.args, command.options);
            if (!process || !process.pid) {
                return Promise.reject(`Launching server using command ${command.command} failed.`);
            }
            if (outputChannel) {
                process.stderr.on('data', data => outputChannel.append(is.string(data) ? data : data.toString(encoding)));
            }
            this._childProcess = process;
            return Promise.resolve(this.createConnection(process.stdout, process.stdin));
        }
        return Promise.reject(new Error(`Unsupported server configuartion ` + JSON.stringify(server, null, 4)));
    }
    createConnection(input, output) {
        let logger = new ConsoleLogger();
        return vscode_jsonrpc_1.createMessageConnection(input, output, logger);
    }
    checkProcessDied(childProcess) {
        if (!childProcess) {
            return;
        }
        setTimeout(() => {
            // Test if the process is still alive. Throws an exception if not
            try {
                process.kill(childProcess.pid, 0);
                processes_1.terminate(childProcess);
            }
            catch (error) {
            }
        }, 2000);
    }
    get rootPath() {
        if (this.workspace.rootPath) {
            return this.workspace.rootPath;
        }
        if (this.workspace.rootUri) {
            return vscode_uri_1.default.parse(this.workspace.rootUri).fsPath;
        }
        return undefined;
    }
}
exports.NodeConnectionProvider = NodeConnectionProvider;
;
