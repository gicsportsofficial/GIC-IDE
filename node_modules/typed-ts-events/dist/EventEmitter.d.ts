export declare class EventEmitter<T extends Record<keyof any, any>> {
    protected readonly catchHandler: (e: Error) => void;
    private _events;
    constructor(catchHandler?: (e: Error) => void);
    hasListeners<K extends keyof T>(eventName: K): boolean;
    getActiveEvents(): Array<keyof T>;
    trigger<K extends keyof T>(eventName: K, params: T[K]): void;
    on<K extends keyof T, SELF = undefined>(eventName: K, handler: EventEmitter.IHandler<T[K], SELF>, context?: SELF): void;
    once<K extends keyof T, SELF = undefined>(eventName: K, handler: EventEmitter.IHandler<T[K], SELF>, context?: SELF): void;
    off(): void;
    off(eventName: keyof T): void;
    off(handler: EventEmitter.IHandler<T[keyof T], any>): void;
    off(eventName: TOrEmpty<keyof T>, handler: TOrEmpty<EventEmitter.IHandler<T[keyof T], any>>): void;
    off<K extends keyof T>(eventName: K, handler: TOrEmpty<EventEmitter.IHandler<T[K], any>>): void;
    private _on;
}
declare type TOrEmpty<T> = T | null | undefined;
export declare namespace EventEmitter {
    interface IHandler<T, SELF> {
        (this: SELF, data: T): any;
    }
}
export {};
